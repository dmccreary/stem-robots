{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"STEM Robots","text":"<p>Welcome to the STEM Robots website!  This site is dedicated to helping students learn computational thinking by using low-cost ($19) robots that are custom-designed for teaching computational thinking skills.</p> <p>The curriculum is designed around Generative AI tools so that you can generate custom lesson plans for many personas and grade levels.</p>"},{"location":"about/","title":"About the STEM Robotics Program","text":"<p>This site was created to provide low-cost yet fun ways that our students can learn computational thinking. Over many years of organizing coding clubs, we have that kids love robots!  When designed thoughtfully, robots combine motion, color, sounds and displays that engage students more than any other teaching tool we have tested.</p> <p>But in the past, even simple robots offered by retailers and promoted by commercial companies were designed first to increase their stockholder value and second to provide learning value.  A typical price for a retail robot kit is $370.  They often justify this cost because they claim that the lesson plans and program examples took millions of dollars to create.  But generative AI is changing this.  Today we have tools that can generate customized lesson plans including working programs for a small fraction of these costs.</p> <p>We have heard many stories of schools that can't afford to give each student their own robot.  But at $19 per robot, we can enable many schools to dramatically decrease the robot-to-student ratios.</p> <p>This site started in 2014 with our experiments on watching kids use these projects.  Every year we would make small changes to increase the fun and lower the cost.  We are convinced you don't need to spend hundreds of dollars per robot to create a fun and engaging experience that provides a measurable improvement in STEM engagement and interest in coding.</p>"},{"location":"about/#metrics-for-a-great-stem-robotics-curriculum","title":"Metrics for a Great STEM Robotics Curriculum","text":"<p>We use ChatGPT to come up with a way to measure the value of a STEM robotics system.  Here is the prompt:</p> <p>Prompt</p> <p>Our school is fed up with vendors trying to sell us $350 STEM robots kits that use cheep parts and batteries that are not replaceable. How can we come up with a simple set of objective measures to rate the quality of STEM robots?  Include the quality of instruction manuals and curriculum that can be customized to the needs of teachers, volunteers and students.</p> <p>Return the results in markdown level three headers.</p>"},{"location":"about/#response","title":"Response","text":"<p>Here is the response:</p> <p>Developing objective measures to evaluate the quality of STEM robots, including the quality of instruction manuals and customizable curricula, is a great way to ensure value for money and educational effectiveness. Here are some key criteria you could consider:</p>"},{"location":"about/#hardware-quality","title":"Hardware Quality","text":"<ul> <li>Durability: Assess the robustness of the robot's construction. Are the materials used sturdy enough for repeated use by students?</li> <li>Modularity: Consider whether parts can be easily added or removed, which can aid in teaching different levels of complexity.</li> <li>Battery Life and Replacement: Check the battery life per charge and ensure that batteries are replaceable and reasonably priced.</li> <li>Sensor and Actuator Quality: Evaluate the performance and reliability of sensors and actuators, as these are crucial for the functionality of the robot.</li> </ul>"},{"location":"about/#cost-effectiveness","title":"Cost Effectiveness","text":"<ul> <li>Initial Cost vs. Part Quality: Compare the cost of the robot with the quality and longevity of the components used.</li> <li>Maintenance Costs: Consider long-term costs related to maintenance, part replacement, and upgrades.</li> </ul>"},{"location":"about/#ease-of-use","title":"Ease of Use","text":"<ul> <li>User-Friendly Design: Is the robot easy to assemble and disassemble? This is important for younger students or those new to robotics.</li> <li>Documentation: Look for clear, comprehensive, and well-organized instruction manuals that cater to different skill levels.</li> </ul>"},{"location":"about/#educational-value","title":"Educational Value","text":"<ul> <li>Curriculum Integration: Evaluate how well the robot's features align with educational standards and curricular goals. Can it be integrated into subjects beyond technology, such as math, science, or arts?</li> <li>Progressive Learning: Does the robot offer different levels of complexity for varied learning stages? This is essential to cater to both beginners and advanced students.</li> <li>Problem-Solving and Creativity: Assess if the robot challenges students to solve real problems and encourages creativity.</li> </ul>"},{"location":"about/#customizability","title":"Customizability","text":"<ul> <li>Software Customization: Check if the software can be easily modified or programmed by teachers and students. Support for multiple programming languages can be a plus.</li> <li>Hardware Customization: Determine if it's possible to modify or expand the hardware to meet different teaching needs or student projects.</li> </ul>"},{"location":"about/#support-and-community","title":"Support and Community","text":"<ul> <li>Technical Support: Reliable and accessible customer support is crucial for troubleshooting and guidance.</li> <li>Community Resources: A strong user community can provide valuable support and resources such as shared lesson plans, tutorials, and project ideas.</li> </ul>"},{"location":"about/#feedback-and-reviews","title":"Feedback and Reviews","text":"<ul> <li>User Feedback: Gather feedback from other educators who have used the robots. User reviews can provide insights into reliability, usability, and educational impact.</li> <li>Pilot Testing: Consider conducting a pilot test with a few robots in your school to see how they perform in real educational settings and gather firsthand feedback.</li> </ul> <p>By establishing a rubric based on these categories, your school can systematically evaluate different STEM robots and select those that offer the best learning potential and value for money. This approach not only helps in making informed purchasing decisions but also supports the educational goals of your STEM programs.</p>"},{"location":"about/#why-we-built-this-website-our-journey","title":"Why We Built This Website: Our Journey","text":"<p>Our journey to build an awesome STEM robotics website began with a simple blog post back in 2014 about repairing the motors in our old Arduino kits. Our insight was that by using a simple cable tie and some heat shrink, we prevented the kids from breaking the wires to our motors.  This little change lowered the frustration of broken kits and allowed our labs with motors to be reliable.  Sometimes little changes make a big difference.</p> <p>We started wondering if other schools were also having these problems.  Why didn't the people who supplied these kits realize how fragile the parts were? Why did they skimp on quality and cause their kits to break so easily?</p> <p>This was the first step on our journey.</p>"},{"location":"about/#our-first-robot","title":"Our First Robot","text":"<p>Yes, kids love color and motion!  Robot classes were usually the first classes to get full. However, we were frustrated by the closed Finch Robots and here that were unreliable and had no way to extend motors and sensors. So we thought about building our own robot.</p> <p>We did some research and ordered some random parts from Amazon.  We used a four-motor chassis, a $35 Arduino Uno and a motor controller.  It turns out that we only needed two motors by the way. The total price was almost $70.  But our students loved the way we had a breadboard on the top so they could add their own lights and sensors. It was a hit!  But looking back, all those wires were difficult for the kids to get right.  Pulling one wire out would make the robot stop working.</p>"},{"location":"about/#the-uno-robot-cutting-costs-and-increasing-content","title":"The Uno Robot: Cutting Costs and Increasing Content","text":"<p>After talking to several others in the Minnesota Arduino club we came across a relatively low-cost Arduino Nano that could be mounted directly on the breadboard.  The Uno Robot was only about $30 and was far more extensible than any of the commercial robots schools were buying!  We also started putting our lesson plans on GitHub to make it easier for other organizations to reuse our content.</p> <p>But the Arduino Uno ecosystem was not kind.  The lower-cost Arduino Uno chips used a driver that was not supported and each new release of the MacOS would make our drivers difficult to install.  It required admin rights to install software and it was impossible for our students to use some of their home computers.  Despite frequent posts to the Arduino community, nothing was done because the drivers were not supported and they wanted us to pay $35 for the official Arduino hardware.  We were looking for options.  We also wanted to use Python which had become the de facto first language for most high schools  The change finally happened in January 2021!</p>"},{"location":"about/#the-switch-to-raspberry-pi-pico-and-micropython","title":"The Switch to Raspberry Pi Pico and MicroPython","text":"<p>The announcement of the Raspberry Pi Pico rocked our world.  Not only was it only $4, but it also fit right on our breadboard!  It ran MicroPython and had the massive support of the entire Raspberry Pi Foundation behind it.  We knew we had a solid partner who would not try to hijack our education to line the pockets of their shareholders.</p> <p>By May of 2021 we had started to upgrade old Arduino Nano robots to the Raspberry Pi Pico.  We had a robot that had over 100 times as much RAM and cost 1/8 of the Arduino UNO!</p> <p>By June of 2021 we were sending out robot kits to our COVID-era students in their homes.</p> <p>Much of the content for this site has migrated from the amazing MicroPython for Kids website.  Although there is a lot of useful content on that site, some of our most popular STEM robot content has got buried deep within the Kits structures.  So we decided that the STEM robot really needed its own separate site.  Our site will still link to the relevant pages on that site.</p> <p>The Raspberry Pi Pico was not perfect.  Because the pin labels were on the bottom of the board we could not read any of them when they were on the breadboard. This little \"oversight\" cause endless hours of headache by forcing us to put colored marks on all our breadboards and print out pin diagrams.  But wait.  There is more!</p>"},{"location":"about/#the-cytron-rp2040-board","title":"The Cytron RP2040 Board","text":"<p>The next big advance came from a brilliant engineer from Malaysia who worked at Cytron.  He developed the Cytron Maker Pi RP2040. This $12 board is so complete that has entirely changed the ease of use of our robots.  Everything we need is included on the board including buttons and LED to test motor connections, a speaker and user programmable buttons. WOW!  Now students had far fewer wires to connect and fewer things that could go wrong.  We have eliminated all the need for soldering.  We could now spend more time learning to code and teach computational thinking.</p>"},{"location":"about/#the-time-of-flight-sensor","title":"The Time of Flight Sensor","text":"<p>The last small addition to our robot was to upgrade the front distance sensor from the old and fragile ultrasonic ping distance sensor to the new shiny time-of-flight sensor. This sensor uses the I2C bus and has both accuracy and response times that are far better then the ultrasonic sensors.  They are also about the same price - about $3 each.</p>"},{"location":"about/#the-rise-of-generative-ai","title":"The Rise of Generative AI","text":"<p>In December of 2022, ChatGPT rocked the world by being able to generate large blocks of high-quality  content just by giving it a small prompt. Although we had been writing about generating lesson plans since 2020, many people ignored us.  But after ChatGPT came out everything changed.  We were teaching classes on how to generate highly personalized lesson plans for not just STEM robotics classes but for many other topics in schools.</p>"},{"location":"about/#adding-microsims","title":"Adding MicroSims","text":"<p>We can also use Generative AI to create online simulators to help our students visualize what is going on within our robot.  For example, many students have a difficult time visualizing how pulse-width modulation works.  This simple MicroSim is allowing us to hyper-personalize both lesson plans as well as interactive simulations that are generated by teachers and run in your browser.</p> <p>We now have also included sample Python scripts so that you can generate high-quality lesson plans on many topics in the course for any grade level.</p>"},{"location":"about/#conclusion","title":"Conclusion","text":"<p>Here is a summary of what we learned:</p> <ol> <li>Open systems are more sustainable</li> <li>Vendors focus on selling you new robots, not building maintainable STEM robots</li> <li>Using interchangeable parts will lower your maintenance and repair costs</li> <li>Teach breadboarding skills early</li> <li>Python rocks - it is the language that kids want to learn and the language of data science and AI</li> <li>Generating lesson plans, sample code, and simulations is revolutionizing STEM robots</li> <li>Invest in your community and support open-source content</li> </ol> <p>Good Luck!</p>"},{"location":"about/#references","title":"References","text":"<ul> <li>Sustainable Classroom Robots - Sustainable Classroom Robots - May 21, 2021</li> <li>Raspberry Pi Pico Robot in Micropython - Sustainable Classroom Robots - Jun 6, 2021</li> <li> <p>The Cytron Maker Pi RP2040 Robotics Board - Dan McCeary's Medium Post - Aug 29, 2021</p> </li> <li> <p>A 3D-Printed Mount for Time-of-Flight Distance Sensors - Dan McCeary's Medium Post - Sep 7, 2021</p> </li> <li> <p>Our 2023 STEM Robot Update -  Dan McCeary's Medium Post - Apr 16, 2023</p> </li> <li> <p>Raspberry Pi Pico Collision Avoidance Robot Programed with Micropython for Coding Clubs - YouTube Video </p> </li> <li> <p>Doug Blanding GitHub Side</p> </li> </ul>"},{"location":"contact/","title":"Contact","text":"<p>Please contact me on LinkedIn</p> <p>Thanks! - Dan</p>"},{"location":"course-description/","title":"STEM Robots Course Description","text":"<p>This course is designed for a year-long course that teaches computational thining through the use of low-cost fun STEM robots.</p> <p>The course puts a focus on </p>"},{"location":"faq/","title":"STEM Robotics Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#can-we-print-our-own-robot-chassis-using-a-3d-printer","title":"Can we print our own robot chassis using a 3D printer?","text":"<p>Yes!  We have samples here:</p> <ul> <li>Cytron Board 3D Model</li> <li>3D Printed Parts for the Donkey Car</li> </ul>"},{"location":"faq/#can-we-print-our-own-mounts-for-sensors","title":"Can we print our own mounts for sensors?","text":"<p>Yes! We have a sample here: A 3D-printed Mount for Time-of-Flight Distance Sensors</p>"},{"location":"glossary/","title":"STEM Robots Glossary of Terms","text":"<p>If you are new to STEM robotics, this glossary is a good place to review your terminology.</p>"},{"location":"glossary/#6-volt-dc-hobby-motors","title":"6-volt DC hobby motors","text":"<p>Small electric motors designed for various hobby projects, typically running on a 6-volt power supply.</p>"},{"location":"glossary/#aa-batteries","title":"AA batteries","text":"<p>Standard size of dry cell battery typically used in portable electronic devices.</p>"},{"location":"glossary/#analog-to-digital-converter","title":"Analog to Digital Converter","text":"<p>A component that takes an analogue signal and changes it to a digital one.</p> <p>Every ADC has two parameters, its resolution, measured in digital bits, and its channels, or how many analogue signals it can accept and convert at once.</p> <ul> <li>Also know as: ADC</li> </ul>"},{"location":"glossary/#bootsel","title":"BOOTSEL","text":"<p>A button on the pico that when pressed during power up will allow you to mount the device as a USB drive.  You can then drag-and-drop any uf2 image file to reset or update the runtime libraries.</p> <p></p> <ul> <li>Also known as: Boot Selection</li> </ul>"},{"location":"glossary/#blit","title":"Blit","text":"<p>A special form of copy operation; it copies a rectangular area of pixels from one framebuffer to another.  It is used in MicroPython when doing drawing to a display such as an OLED display.</p>"},{"location":"glossary/#castellated-edge","title":"Castellated Edge","text":"<p>Plated through holes or vias located in the edges of a printed circuit board that make it easier to solder onto another circuit board.</p> <p></p> <p>The word \"Castellated\" means having grooves or slots on an edge and is derived from the turrets of a castle.</p>"},{"location":"glossary/#computational-thinking","title":"Computational Thinking","text":"<p>Computational thinking is a problem-solving methodology that involves applying concepts and techniques from computer science to understand and address complex issues.</p> <p>Computational thinking encompasses skills such as algorithmic thinking, pattern recognition, abstraction, and decomposition. This approach encourages breaking down problems into manageable parts, identifying patterns, abstracting out details to focus on the core issue, and developing step-by-step solutions (algorithms). Computational thinking is not just for computer scientists but is a fundamental skill for everyone, applicable in various fields including business, education, and research. It aids in developing logical reasoning and efficient problem-solving approaches.</p> <p>The lesson plans on this site put a strong focus on increasing computational thinking skills.  Many lessons start with a difficult problem and then proceed to divide the problem into smaller components.</p> <p>Computational Thinking Page</p>"},{"location":"glossary/#cytron-maker-pi-rp2040","title":"Cytron Maker Pi RP2040","text":"<p>A robotics board featuring the Raspberry Pi RP2040 microcontroller, designed for use in educational and hobbyist robotics projects.</p>"},{"location":"glossary/#dc-motor-drivers","title":"DC motor drivers","text":"<p>Electronic components that control the direction and speed of DC motors.</p>"},{"location":"glossary/#dupont-connectors","title":"Dupont Connectors","text":"<p>Pre-made low-cost used and used to connect breadboards to hardware such as sensors and displays.</p> <p>The connectors are available in male and female ends and are typically sold in lengths of 10 or 20cm.  They have a with a 2.54mm (100mill) pitch so they are easy to align with our standard breadboards.  They are typically sold in a ribbon of mixed colors for around $2.00 US for 40 connectors.</p> <ul> <li>Also known as: Jumper Wires</li> <li>Sample eBay Search for Jumper Wires</li> </ul>"},{"location":"glossary/#esp32","title":"ESP32","text":"<p>A series of low-cost, low-power system on a chip microcontrollers with integrated Wi-Fi and dual-mode Bluetooth.</p> <p>Typical costs for the ESP32 is are around $10 US on eBay.</p> <ul> <li>Sample on eBay $5</li> <li>Sample on Amazon $11</li> <li>Sample on Sparkfun $21</li> <li>ESP32 Quick Reference</li> <li>Sample eBay Search for ESP32 from $5 to $20</li> </ul>"},{"location":"glossary/#flash-memory","title":"Flash memory","text":"<p>A type of non-volatile memory that retains data even when the power is turned off.</p>"},{"location":"glossary/#formatted-strings","title":"Formatted Strings","text":"<p>The ability to use a simplified syntax to format strings by added the letter \"f\" before the string.  Values within curly braces are formatted from variables.</p> <pre><code>name = \"Lisa\"\nage = 12\nf\"Hello, {name}. You are {age}.\"\n</code></pre> <p>returns</p> <pre><code>Hello, Lisa. You are 12.\n</code></pre> <p>Formatted string support was added to MicroPython in release 1.17.  Most formats work except the date and time formats.  For these we must write our own formatting functions.</p> <ul> <li>Also known as: f-strings</li> <li>Also known as: Literal String Interpolation</li> <li>From Python Enhancement Proposal: PEP 498</li> <li>Official Python documentation on string formatting</li> <li>Link to Formatted Strings Docs: formatted strings</li> <li>PyFormat library for formatting strings: PyFormat.info</li> </ul>"},{"location":"glossary/#framebuffer","title":"Framebuffer","text":"<p>A region of your microcontroller RAM that stores a bitmap image of your display.</p> <p>For a 128X64 monochrome display this would be 128 * 64 = 8,192 bits or 1,024 bytes (1K).  Color displays must store up to 8 bytes per color for each color (red, green and blue).</p> <ul> <li>Wikipedia page on Framebuffer</li> <li>MicroPython Documentation on FrameBuffer ]</li> </ul>"},{"location":"glossary/#gpi-status-leds","title":"GPI status LEDs","text":"<p>General Purpose Input status Light Emitting Diodes used for indicating the state of inputs.</p>"},{"location":"glossary/#grove-connectors","title":"Grove connectors","text":"<p>Standardized connectors used for connecting various sensors and modules to microcontrollers easily.</p>"},{"location":"glossary/#i2c","title":"I2C","text":"<p>A communications protocol common in microcontroller-based systems, particularly for interfacing with sensors, memory devices and liquid crystal displays.</p> <p>I2C is similar to SPI, it's a synchronous protocol because it uses a clock line.</p> <ul> <li>Also Known as: Inter-integrated Circuit</li> <li>See also: SPI</li> </ul>"},{"location":"glossary/#i2c-protocol","title":"I2C protocol","text":"<p>Inter-Integrated Circuit protocol, a serial communication protocol used for connecting low-speed peripherals to microcontrollers.</p>"},{"location":"glossary/#interrupts","title":"Interrupts","text":"<p>A type of signal used to pause a program and execute a different program.  We use interrupts to pause our program and execute a different program when a button is pressed.</p>"},{"location":"glossary/#lipo-battery","title":"LiPo battery","text":"<p>Lithium Polymer battery, a type of rechargeable battery commonly used in portable electronics.</p>"},{"location":"glossary/#mpg-shell","title":"MPG Shell","text":"<p>A simple MicroPython shell based file explorer for ESP8266 and WiPy MicroPython based devices.</p> <p>The shell is a helper for up/downloading files to the ESP8266 (over serial line and Websockets) and WiPy (serial line and telnet). It basically offers commands to list and upload/download files on the flash FS of the device.</p> <p>GitHub Repo for MPFShell</p>"},{"location":"glossary/#micropython","title":"MicroPython","text":"<p>A lean and efficient implementation of the Python programming language that is designed to run on microcontrollers and in constrained environments.</p>"},{"location":"glossary/#microsims","title":"MicroSims","text":"<p>Small web-based programs that use simulations and animations to explain concepts.  MicroSims (short for Micro-Simulations) are small enough that a first draft can be created by generative AI programs such as ChatGPT.</p> <p>Many lessons on this site also feature MicroSims that reinforce concepts and that can be quickly extended by teachers or mentors.</p> <ul> <li>MicroSims website</li> </ul>"},{"location":"glossary/#neopixels","title":"NeoPixels","text":"<p>Individually addressable Red-Green and Blue (RGB) Light Emitting Diodes (LEDs) that can be controlled to display a wide range of colors and patterns.</p>"},{"location":"glossary/#oled-display","title":"OLED Display","text":"<p>OLED (Organic polymer Light Emitting Diode) displays are small but bright displays with high contrast, low power and a wide viewing angle.</p> <p>We use these displays throughout our labs.  The small displays are around 1\" (diagonal) and only cost around $4 to $5.  Larger 2.24\" displays cost around $20.  These displays work both with 4-wire I2C and 7-wire SPI connections.  We use the larger displays with a faster SPI for our robots with faces.</p> <p>Typical chips that control the OLED include the SSD1306 driver chips.</p> <ul> <li>See: Graph Displays</li> </ul>"},{"location":"glossary/#pwm","title":"PWM","text":"<p>A type of output signal used to control items with continuous values.  For example, we use PWM to control the brightness of a light or the speed of a motor.  We use pulse-width modulation (PWM) to control the speed of our DC motors.</p> <p></p>"},{"location":"glossary/#physical-computing","title":"Physical Computing","text":"<p>The process of using computers to read data from sensors about the world around us and then taking action on this incoming data stream. These actions are typically doing things like blinking an LED, moving a motor, or updating a display.</p>"},{"location":"glossary/#pico-pinout-diagram","title":"Pico Pinout Diagram","text":"<p>The Pico pinout diagram shows you the ways that each Pin can be used.  Different colors are used for GPIO numbers, I2C, and SPI interfaces.</p> <p></p> <ul> <li>Pinout PDF</li> </ul>"},{"location":"glossary/#piezo-buzzer","title":"Piezo buzzer","text":"<p>An electronic device that produces sound, often used for alerts and notifications in electronic circuits.</p>"},{"location":"glossary/#rgb-led","title":"RGB LED","text":"<p>Light Emitting Diodes that can emit Red, Green, and Blue light, used in various applications for color display.</p>"},{"location":"glossary/#rp2040-chip","title":"RP2040 chip","text":"<p>A custom chip created by the Raspberry Pi Foundation to power the Raspberry Pi Pico.</p>"},{"location":"glossary/#raspberry-pi-foundation","title":"Raspberry Pi Foundation","text":"<p>The company that builds the Raspberry Pi hardware and provides some software.</p>"},{"location":"glossary/#raspberry-pi-pico","title":"Raspberry Pi Pico","text":"<p>A microcontroller designed by the Raspberry Pi foundation for doing real-time control systems.</p> <p>The Pico was introduced in 2020 with a retail list price of $4.  It was a key development because it used a custom chip that had 100 times the RAM of an Arduino Nano.</p>"},{"location":"glossary/#raspberry-pi-rp2040","title":"Raspberry Pi RP2040","text":"<p>A dual-core microcontroller developed by Raspberry Pi, featuring 264K SRAM and 2MB of flash memory.</p>"},{"location":"glossary/#resolution","title":"Resolution","text":"<p>The size of our OLED screen as measured in a width x height number.</p> <p>Example: Our 2.44\" OLED displays have a resolution of 128x64 pixels.</p>"},{"location":"glossary/#rhizomatic-learning","title":"Rhizomatic Learning","text":"<p>An approach to learning that uses a non-linear, organic process, where knowledge is interconnected and grows in multiple directions, much like a rhizome. </p> <p>Rhizomatic learning is an educational concept that draws its analogy from the rhizome, a type of plant root system.</p> <p>It emphasizes the importance of context, personal interpretation, and the idea that knowledge and learning are not static but are constantly evolving. Rhizomatic learning encourages learners to create their own paths through content, fostering critical thinking, adaptability, and collaboration. This approach contrasts with traditional hierarchical models of education, offering a more fluid and dynamic understanding of knowledge acquisition.</p>"},{"location":"glossary/#spi","title":"SPI","text":"<p>An interface bus commonly used to send data between microcontrollers and small peripherals such as sensors, displays and SD cards. SPI uses separate clock and data lines, along with a select line to choose the device you wish to talk to.</p> <p>Also known as: Serial Peripheral Interface See also: I2C</p>"},{"location":"glossary/#spi-bus","title":"SPI bus","text":"<p>Serial Peripheral Interface bus, a synchronous serial communication protocol used for short-distance communication.</p>"},{"location":"glossary/#stem","title":"STEM","text":"<p>An acronym for Science, Technology, Engineering, and Mathematics education.</p>"},{"location":"glossary/#smart-car-chassis","title":"Smart Car chassis","text":"<p>The physical frame of the robot to which all other parts are mounted.</p>"},{"location":"glossary/#thonny","title":"Thonny","text":"<p>A lightweight Python IDE ideal for writing simple Python programs for first-time users.</p> <p>Thonny runs on Mac, Windows and Linux.</p> <ul> <li>Thonny web site</li> </ul>"},{"location":"glossary/#thonny-integrated-development-environment-ide","title":"Thonny Integrated Development Environment (IDE)","text":"<p>A user-friendly IDE for learning and teaching programming, particularly well-suited for use with MicroPython.</p>"},{"location":"glossary/#time-of-flight-distance-sensor","title":"Time-of-flight distance sensor","text":"<p>A sensor that measures the distance to an object by calculating the time taken for a signal to travel to the object and back.</p>"},{"location":"glossary/#uf2-file","title":"UF2 File","text":"<p>The file must be uploaded into the Raspberry Pi Pico folder to allow it to be used. The file name format looks like this:</p> <p><code>rp2-pico-20210205-unstable-v1.14-8-g1f800cac3.uf2</code></p>"},{"location":"glossary/#usb-cable","title":"USB cable","text":"<p>A cable used for data transfer and power supply, commonly used to connect devices to computers.</p>"},{"location":"glossary/#vl53l0x","title":"VL53L0X","text":"<p>A specific model of a time-of-flight distance sensor that uses the I2C protocol for communication.</p>"},{"location":"glossary/#references","title":"References","text":"<ul> <li>MicroPython for Kids Glossary#### rshell</li> <li>MicroPython Glossary</li> </ul>"},{"location":"great-ways-to-teach/","title":"Great Ways to Teach","text":"<p>We strive to make this STEM Robot an example of the best way to teach. Here are some good and bad ways to teach.</p>"},{"location":"great-ways-to-teach/#examples-of-good-pedagogy","title":"Examples of Good Pedagogy","text":""},{"location":"great-ways-to-teach/#interactive-learning","title":"Interactive Learning","text":"<ul> <li>Description: Engaging students in hands-on activities, group work, and discussions rather than just lecturing.</li> <li>Impact: Increases understanding and retention of material by actively involving students in the learning process.</li> </ul>"},{"location":"great-ways-to-teach/#differentiated-instruction","title":"Differentiated Instruction","text":"<ul> <li>Description: Tailoring lessons to meet the varied skill levels and learning styles of students.</li> <li>Impact: Helps all students learn effectively, whether they need more challenge or more support, ensuring no one is left behind.</li> </ul>"},{"location":"great-ways-to-teach/#formative-assessment","title":"Formative Assessment","text":"<ul> <li>Description: Using quizzes, discussions, and projects to gauge student understanding throughout the educational process, not just at the end.</li> <li>Impact: Allows teachers to identify where students are struggling and adjust instruction accordingly, fostering a better learning environment.</li> </ul>"},{"location":"great-ways-to-teach/#incorporation-of-technology","title":"Incorporation of Technology","text":"<ul> <li>Description: Using tools like educational software, interactive whiteboards, and AI tutors to enhance learning.</li> <li>Impact: Makes learning more engaging and accessible, and can provide personalized learning experiences.</li> </ul>"},{"location":"great-ways-to-teach/#examples-of-bad-pedagogy","title":"Examples of Bad Pedagogy","text":""},{"location":"great-ways-to-teach/#one-size-fits-all-approach","title":"One-Size-Fits-All Approach**:","text":"<ul> <li>Description: Delivering the same lesson in the same way to all students, regardless of their individual learning needs or abilities.</li> <li>Impact: Can lead to disengagement and poor understanding among students who do not resonate with the general teaching method.</li> </ul>"},{"location":"great-ways-to-teach/#lack-of-engagement","title":"Lack of Engagement**:","text":"<ul> <li>Description: Relying solely on lectures without interaction or practical application.</li> <li>Impact: Students may become passive recipients of information, leading to lower retention rates and lack of interest in the subject matter.</li> </ul>"},{"location":"great-ways-to-teach/#overemphasis-on-memorization","title":"Overemphasis on Memorization**:","text":"<ul> <li>Description: Focusing heavily on rote learning and memorization without understanding the underlying concepts.</li> <li>Impact: Students may perform well on tests but fail to apply knowledge in real-world situations, indicating a shallow level of learning.</li> </ul>"},{"location":"great-ways-to-teach/#neglecting-feedback","title":"Neglecting Feedback**:","text":"<ul> <li>Description: Failing to provide students with timely or constructive feedback on their work.</li> <li>Impact: Without feedback, students cannot learn from their mistakes or understand how to improve, which can hinder their academic progress.</li> </ul> <p>These examples highlight the importance of adopting effective pedagogical strategies that cater to diverse learning needs and encourage active participation and deeper understanding.</p>"},{"location":"journey-map/","title":"STEM Robot Journey Map","text":""},{"location":"license/","title":"Creative Commons License","text":"<p>All content in this repository is governed by the following license agreement:</p>"},{"location":"license/#license-type","title":"License Type","text":"<p>Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0 DEED)</p>"},{"location":"license/#link-to-license-agreement","title":"Link to License Agreement","text":"<p>https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en</p>"},{"location":"license/#your-rights","title":"Your Rights","text":"<p>You are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format</li> <li>Adapt \u2014 remix, transform, and build upon the material</li> </ul> <p>The licensor cannot revoke these freedoms as long as you follow the license terms.</p>"},{"location":"license/#restrictions","title":"Restrictions","text":"<ul> <li>Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> <li>No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.</li> </ul> <p>Notices</p> <p>You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.</p> <p>No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.</p> <p>This deed highlights only some of the key features and terms of the actual license. It is not a license and has no legal value. You should carefully review all of the terms and conditions of the actual license before using the licensed material.</p>"},{"location":"personas/","title":"STEM Robot Personas","text":"<p>When you generate content, make sure you mention one of the personas that us this robot it a school.</p>"},{"location":"personas/#sample-persona-prompt","title":"Sample Persona Prompt","text":"<pre><code>For the following STEM robot kit and website, generate a list of personas that might be\ninvolved in using this robot in a classroom to teach computational thinking.  The lesson plans must be integrated into the schools curriculum and learning management system.\n\nThe STEM Robot is a low-cost but fun robot designed to teach kids the principles of computational thinking. It is built around the Raspberry Pi RP2040 microcontrollers and is programmed with MicroPython. It is designed to cost under $19. The base STEM robot has the following parts:\n\n1. 2 6-volt DC hobby motors. \n2. 4 AA batteries in a battery pack. \n3. A \"Smart Car\" chassis. \n4. A Cytron Maker Pi RP2040 robotics board that includes motor drivers, 13 blue LEDs for GPIO status, 2 NeoPixels, a Piezo buzzer with mute switch, two customizable momentary buttons, 7 Grove connectors, 4 servo drivers, a power on switch, a power indicator LED. and LEDs and buttons to test the motor connections. \n5. A VL53L0X time-of-flight distance sensor that uses the I2C protocol to measure distance. \n6. A USB cable for programming the car. The robot is programmed with the Thonny Integrated Development for Python. Note that the RP2040 is a dual-core MicroController with 264K SRAM and 2MB flash memory.\n\nThe STEM Robot works with a website that stores lesson plans, sample programs and assessments.\n\nReturn the list in markdown format with each persona as a level 3 header.\nSort the list from the most frequent users of the \n</code></pre>"},{"location":"personas/#chatgpt-response","title":"ChatGPT Response","text":"<p>To effectively use the STEM Robot in a classroom setting to teach computational thinking, several personas would likely be involved, each with specific roles and responsibilities. Here's a list of potential personas:</p>"},{"location":"personas/#students-learners","title":"Students (Learners)","text":"<ul> <li>Role: Primary users of the STEM Robot.</li> <li>Responsibilities: Engaging with the robot to learn computational thinking, participating actively in problem-solving tasks, and collaborating with peers to design and program the robot.</li> </ul>"},{"location":"personas/#teacher-computational-thinkingcomputer-science","title":"Teacher (Computational Thinking/Computer Science)","text":"<ul> <li>Role: Facilitates the learning experiences involving the STEM Robot.</li> <li>Responsibilities: Planning and delivering lessons that incorporate the robot, guiding students through programming exercises, and assessing students' progress in computational thinking.</li> </ul>"},{"location":"personas/#volunteermentor","title":"Volunteer/Mentor","text":"<ul> <li>Role: Non-school staff that are drawn from the community to help teach computer science concepts</li> <li>Responsibilities: Subject matter experts on programming and hardware that help students reach their learning objectives.</li> </ul>"},{"location":"personas/#educational-technology-specialist","title":"Educational Technology Specialist","text":"<ul> <li>Role: Evaluates its educational value, and ensures it aligns with curriculum standards.</li> <li>Responsibilities: Selecting suitable technology tools, training teachers, troubleshooting technical issues, and assessing the effectiveness of the robot in teaching computational principles.</li> </ul>"},{"location":"personas/#parentguardian","title":"Parent/Guardian","text":"<ul> <li>Role: Supports learning outside of the classroom.</li> <li>Responsibilities: Encouraging practice at home, understanding the educational value of the robot, and possibly assisting in troubleshooting or overseeing projects involving the robot.</li> </ul>"},{"location":"personas/#curriculum-developer","title":"Curriculum Developer","text":"<ul> <li>Role: Designs educational content and activities that utilize the robot to teach key concepts in computational thinking.</li> <li>Responsibilities: Creating lesson plans, tutorials, and projects that make effective use of the robot's capabilities, ensuring a progressive learning curve, and aligning activities with educational standards.</li> </ul>"},{"location":"personas/#school-administrator","title":"School Administrator","text":"<ul> <li>Role: Supports and approves the integration of new technology like the STEM Robot into the educational offerings of the school.</li> <li>Responsibilities: Allocating budget for technological tools, facilitating professional development for teachers, and ensuring the technology is used responsibly within the school environment.</li> </ul>"},{"location":"personas/#technical-support-staff","title":"Technical Support Staff","text":"<ul> <li>Role: Provides backend support for the maintenance and functionality of the robots.</li> <li>Responsibilities: Regular maintenance checks, updating software as needed, and repairing any hardware issues to ensure the robots are always ready for classroom use.  Ensures student can access the website and use a local learning management system.</li> </ul> <p>Each of these personas plays a crucial role in the ecosystem around the STEM Robot, contributing to its goal of enhancing computational thinking skills among students.</p>"},{"location":"references/","title":"References","text":""},{"location":"references/#micropython-for-kids","title":"MicroPython for Kids","text":"<p>This is the original website that we built for our students.  It has hundreds of step-by-step tutorials on learning how to use MicroPython to write programs that control robots.</p> <p>MicroPython for Kids Website</p>"},{"location":"references/#introduction-to-python-with-trinket","title":"Introduction to Python with Trinket","text":"<p>This site is our most popular site for students who are new to Python programming.  This has a well-designed set of lessons that use the Trinket site which is a kid-safe place to learn Python with turtle graphics.</p> <p>Introduction to Python Website</p>"},{"location":"references/#ai-racing-league","title":"AI Racing League","text":"<p>This project uses an RC car body with a full Raspberry Pi and camera to teach the basics of machine learning and computer vision.  The cost of the hardware is about $300/car and we use a $900 PC with a GPU to train models.</p> <p>AI Racing League Website</p>"},{"location":"references/#robot-faces","title":"Robot Faces","text":"<p>For students who want to put faces on their robots, this is the site for you.  The site starts with learning basic drawing commands for squares and circles and then builds up to drawing complex faces with eyes, smiles and eyebrows.  You can even teach your robot to wink!</p> <p>Robot Faces Website</p>"},{"location":"references/#clocks-and-watches","title":"Clocks and Watches","text":"<p>Clocks and Watches Website</p>"},{"location":"references/#internet-of-things-course","title":"Internet of Things Course","text":"<p>For advanced high-school students, we encourage you to continue your learning by understanding how microcontrollers are used in the Internet of Things (IoT) field.</p> <p>Internet of Things Course</p>"},{"location":"references/#resources-for-teachers-and-mentors","title":"Resources for Teachers and Mentors","text":"<p>CoderDojo Mentor Resources</p>"},{"location":"references/#instructable","title":"Instructable","text":"<p>$25 Robot Platform for Teaching Programming - March 22nd 2017</p>"},{"location":"robot-description/","title":"Robot Description","text":""},{"location":"robot-description/#description-of-the-base-stem-robot","title":"Description of the Base STEM Robot","text":"<p>The base STEM robot has the following descriptive text.  This text is important because it is used as a \"seed\" to generate lesson plans about the robot.</p> <pre><code>The STEM Robot is a low-cost but fun robot designed to teach kids\nthe principles of computational thinking.  It is built around the\nRaspberry Pi RP2040 microcontrollers and is programed with MicroPython.\nIt is designed to cost under $19.\n\nThe base STEM robot has the following parts:\n\n1. 2x 6-volt DC hobby motors with wires pre-soldered\n2. 4x AA batteries in a battery pack with wires\n3. A \"Smart Car\" chassis that parts are mounted to with screws\n4. A Cytron Maker Pi RP2040 robotics board that\nincludes:\n    1. 2x DC motor drivers\n    2. 13x blue GPI statusLEDs\n    3. 2x RGB LED NeoPixels\n    4. a Piezo buzzer with mute switch\n    5. two customizable momentary push buttons\n    6. 7x Grove connectors with four wires\n    7. 4x servo drivers\n    8. a power on switch with a power indicator LED\n    9. 4x red LEDs and buttons to test the motor connections\n    10. a port for charging a LiPo battery\n5. A VL53L0X time-of-flight distance sensor that\nuses the I2C protocol to measure distance\n6. A USB cable for programming the robot from a PC or Mac\n\nThe robot is programmed with the Thonny Integrated\nDevelopment for MicroPython.  Note that the RP2040 is\na dual-core micro-controller with 264K SRAM and 2MB\nflash memory.  The RP2040 includes support for both I2C\nand SPI bus.\n\nThe STEM Robot works with a website that stores lesson plans,\nsample programs and assessments that can be integrated into\na school curriculum and the school's learning management system.\n</code></pre> <p>In the future, we will refer to this block of text as the ROBOT_DESCRIPTION text. If you are generating other courses, you can call this COURSE_DESCRIPTION.</p>"},{"location":"topics/","title":"STEM Robotics Topics","text":"<p>Designing a low-cost STEM robot that runs MicroPython is a fantastic way to teach computational thinking. Here are key concepts you can teach using such a robot:</p>"},{"location":"topics/#programming-concepts","title":"Programming Concepts","text":""},{"location":"topics/#1-basic-programming-concepts","title":"1. Basic Programming Concepts","text":"<ul> <li>Variables: Understanding how to store and manipulate data.</li> <li>Loops: Using <code>for</code> and <code>while</code> loops to repeat actions.</li> <li>Conditionals: Using <code>if</code>, <code>elif</code>, and <code>else</code> to make decisions.</li> <li>Functions: Writing reusable blocks of code.</li> </ul>"},{"location":"topics/#2-computational-thinking-skills","title":"2. Computational Thinking Skills","text":"<ul> <li>Decomposition: Breaking down a complex problem into smaller, more manageable parts.</li> <li>Pattern Recognition: Identifying similarities or patterns in problems.</li> <li>Abstraction: Focusing on important information only, ignoring irrelevant details.</li> <li>Algorithm Design: Creating step-by-step instructions to solve a problem.</li> </ul>"},{"location":"topics/#3-robotics-fundamentals","title":"3. Robotics Fundamentals","text":"<ul> <li>Sensors and Actuators: Understanding how robots perceive their environment and act upon it.<ul> <li>Sensors: Learning how to read data from sensors (e.g., distance, light, temperature).</li> <li>Actuators: Controlling motors, servos, and other actuators.</li> </ul> </li> <li>Control Systems: Using feedback from sensors to adjust actions (closed-loop vs. open-loop systems).</li> </ul>"},{"location":"topics/#4-electronics-basics","title":"4. Electronics Basics","text":"<ul> <li>Circuits: Understanding simple circuits and how they work.</li> <li>Power Management: Managing power supply and battery usage.</li> <li>Interfacing: Connecting different components (e.g., sensors, motors) to the microcontroller.</li> </ul>"},{"location":"topics/#5-engineering-principles","title":"5. Engineering Principles","text":"<ul> <li>Design and Prototyping: Creating and testing designs using iterative processes.</li> <li>Mechanical Design: Basics of building structures, considering weight, balance, and durability.</li> </ul>"},{"location":"topics/#6-problem-solving-skills","title":"6. Problem-Solving Skills","text":"<ul> <li>Debugging: Finding and fixing errors in the code and hardware.</li> <li>Testing and Iteration: Testing designs and making iterative improvements.</li> </ul>"},{"location":"topics/#7-communication-and-collaboration","title":"7. Communication and Collaboration","text":"<ul> <li>Documentation: Writing clear and concise documentation for projects.</li> <li>Collaboration: Working effectively in teams, sharing ideas, and dividing tasks.</li> </ul>"},{"location":"topics/#8-data-handling-and-analysis","title":"8. Data Handling and Analysis","text":"<ul> <li>Data Collection: Gathering data from sensors.</li> <li>Data Processing: Analyzing and interpreting data to make decisions.</li> <li>Visualization: Displaying data in a meaningful way.</li> </ul>"},{"location":"topics/#9-real-world-applications","title":"9. Real-World Applications","text":"<ul> <li>Automation: Understanding how robots are used in various industries.</li> <li>Ethics: Discussing the ethical implications of robotics and automation.</li> </ul>"},{"location":"topics/#practical-projects","title":"Practical Projects","text":"<ul> <li>Line Following Robot: A robot that follows a line using sensors.</li> <li>Obstacle Avoidance Robot: A robot that navigates around obstacles.</li> <li>Remote-Controlled Robot: A robot controlled via Bluetooth or Wi-Fi.</li> <li>Environment Monitoring Robot: A robot that collects and reports environmental data.</li> </ul>"},{"location":"topics/#resources-and-tools","title":"Resources and Tools","text":"<ul> <li>MicroPython Documentation: Official documentation and tutorials.</li> <li>Educational Kits: Affordable robotics kits like micro:bit, Raspberry Pi Pico, or ESP32-based kits.</li> <li>Online Communities: Forums and groups for sharing ideas and getting help (e.g., Reddit, GitHub).</li> </ul> <p>Integrating these concepts into your curriculum will provide a comprehensive and engaging learning experience for students, equipping them with valuable skills for the future.</p>"},{"location":"topics/#topics-for-a-collision-avoidance-robot","title":"Topics for a collision avoidance robot?","text":"<p>Using a low-cost time-of-flight (ToF) distance sensor for a collision avoidance robot provides a rich set of topics for teaching various STEM concepts. Here is a list of topics you could cover:</p>"},{"location":"topics/#programming-and-computational-thinking","title":"Programming and Computational Thinking","text":"<ol> <li> <p>Sensor Integration</p> <ul> <li>How ToF sensors work and their applications.</li> <li>Reading distance data from the sensor using MicroPython.</li> <li>Interpreting sensor data to make decisions.</li> <li> <p>Algorithm Design</p> </li> <li> <p>Designing algorithms for obstacle detection.</p> </li> <li>Implementing collision avoidance algorithms (e.g., stopping, turning).</li> <li> <p>Control Structures</p> </li> <li> <p>Using conditionals to react to sensor data.</p> </li> <li>Implementing loops for continuous monitoring of obstacles.</li> <li> <p>Functions and Modular Programming</p> </li> <li> <p>Writing functions to encapsulate sensor reading and movement logic.</p> </li> <li>Reusing code for different parts of the robot's behavior.</li> </ul> </li> </ol>"},{"location":"topics/#robotics-and-electronics","title":"Robotics and Electronics","text":"<ol> <li> <p>Basic Robotics Concepts</p> <ul> <li>Understanding the role of sensors and actuators in robotics.</li> <li>Using motors and servos to control the robot's movement.</li> <li> <p>Circuit Design</p> </li> <li> <p>Wiring the ToF sensor and other components to the microcontroller.</p> </li> <li>Ensuring proper power management for all components.</li> </ul> </li> </ol>"},{"location":"topics/#engineering-principles","title":"Engineering Principles","text":"<ol> <li> <p>Design and Prototyping</p> <ul> <li>Creating a chassis that can support the sensor and other components.</li> <li>Prototyping different configurations for optimal sensor placement.</li> <li> <p>Mechanical Design</p> </li> <li> <p>Understanding the physical constraints and limitations of the robot.</p> </li> <li>Designing mechanisms for smooth and efficient movement.</li> </ul> </li> </ol>"},{"location":"topics/#data-handling-and-analysis","title":"Data Handling and Analysis","text":"<ol> <li> <p>Data Collection and Processing</p> <ul> <li>Collecting distance data from the ToF sensor.</li> <li>Filtering and smoothing sensor data to improve reliability.</li> <li> <p>Visualization and Debugging</p> </li> <li> <p>Visualizing sensor data to understand robot behavior.</p> </li> <li>Debugging issues with sensor readings and robot movement.</li> </ul> </li> </ol>"},{"location":"topics/#real-world-applications-and-problem-solving","title":"Real-World Applications and Problem Solving","text":"<ol> <li> <p>Collision Avoidance Strategies</p> <ul> <li>Simple reactive behaviors: stopping and turning away from obstacles.</li> <li>More complex behaviors: path planning and navigation.</li> <li> <p>Testing and Iteration</p> </li> <li> <p>Testing the robot in different environments and scenarios.</p> </li> <li>Iterating on the design and code to improve performance.</li> </ul> </li> </ol>"},{"location":"topics/#advanced-topics","title":"Advanced Topics","text":"<ol> <li> <p>Sensor Fusion</p> <ul> <li>Combining data from multiple sensors for more accurate obstacle detection.</li> <li> <p>Machine Learning (optional)</p> </li> <li> <p>Using machine learning to improve collision avoidance over time.</p> </li> <li>Training models to predict and react to obstacles more effectively.</li> </ul> </li> </ol>"},{"location":"topics/#practical-projects-and-exercises","title":"Practical Projects and Exercises","text":"<ol> <li> <p>Basic Collision Avoidance Robot</p> <ul> <li>Building a simple robot that stops or turns when an obstacle is detected.</li> <li> <p>Maze Navigation</p> </li> <li> <p>Designing a robot that can navigate through a maze using the ToF sensor.</p> </li> <li> <p>Dynamic Obstacle Avoidance</p> </li> <li> <p>Creating a robot that can avoid moving obstacles in real-time.</p> </li> </ul> </li> </ol>"},{"location":"topics/#resources-and-tools_1","title":"Resources and Tools","text":"<ol> <li> <p>MicroPython Libraries</p> <ul> <li>Exploring libraries and modules available for ToF sensors.</li> <li> <p>Simulation Tools</p> </li> <li> <p>Using simulation environments to test and refine collision avoidance algorithms before deploying them on the physical robot.</p> </li> </ul> </li> </ol> <p>By covering these topics, students will gain a comprehensive understanding of how to use ToF sensors for collision avoidance in robotics, while also learning valuable programming, electronics, and engineering skills.</p> <p>2/2</p>"},{"location":"course-descriptions/","title":"Course Descriptions","text":"<p>Two Hours Course for Teachers with No Coding Experience</p>"},{"location":"course-descriptions/14-week-course/","title":"14 Week Course","text":"<p>Create a derailed course description that describes a 2-hour hands-on course on teaching computational thinking using a low-cost STEM robot.</p> <p>The target audience for this course is teachers that have little or no experience with coding.  The goal is to get them exposed to the ideas of teaching computational thinking using a fun hands-on $35 STEM robot.</p> <p>The robot is built around the Cytron RP2040 Maker Pi board. It has two DC motors and a time-of-flight sensor as well as a 128x64 monochrome display.</p> <p>The students will need to have Thonny installed on their desktops before the class begins.</p> <p>The rough outline is:</p> <ol> <li>What is computational thinking</li> <li>Why are fun low-cost robots the best way to teach computational thinking</li> <li>Overview of physical computing</li> <li>Getting started with Thonny</li> <li>Blinking an LED</li> <li>Changing color on a NeoPixel</li> <li>Playing a sound</li> <li>Driving a motor</li> <li>Reading the distance sensor</li> <li>Updating the display</li> <li>Running the collision avoidance program</li> <li>Putting your robot in the robot corral</li> </ol> <p>Use Bloom's taxonomy to create a prices list of learning objectives.</p>"},{"location":"course-descriptions/two-hour-hands-on/","title":"Two Hour Hands-On Course","text":""},{"location":"course-descriptions/two-hour-hands-on/#sample-prompt","title":"Sample Prompt","text":"<pre><code>Create a derailed course description that describes a 2-hour\nhands-on course on teaching computational thinking using\na low-cost STEM robot.\n\nThe target audience for this course is teachers that have\nlittle or no experience with coding.  The goal is to get\nthem exposed to the ideas of teaching computational thinking\nusing a fun hands-on $35 STEM robot.\n\nThe robot is built around the Cytron RP2040 Maker Pi board.\nIt has two DC motors and a time-of-flight sensor as well\nas a 128x64 monochrome display.\n\nThe students will need to have Thonny installed on their\ndesktops before the class begins.\n\nThe rough outline is:\n\n1. What is computational thinking\n2. Why are fun low-cost robots the best way to teach computational thinking\n3. Overview of physical computing\n4. Getting started with Thonny\n5. Blinking an LED\n6. Changing color on a NeoPixel\n7. Playing a sound\n8. Driving a motor\n9. Reading the distance sensor\n10. Updating the display\n11. Running the collision avoidance program\n12. Putting your robot in the robot corral\n\nUse Bloom's taxonomy to create a prices list of learning objectives.\n</code></pre>"},{"location":"course-descriptions/two-hour-hands-on/#chatgpt-response","title":"ChatGPT Response","text":""},{"location":"course-descriptions/two-hour-hands-on/#course-title-teaching-computational-thinking-with-a-low-cost-stem-robot","title":"Course Title: Teaching Computational Thinking with a Low-Cost STEM Robot","text":"<p>Duration: 2 Hours Target Audience: Teachers with little or no experience in coding.</p>"},{"location":"course-descriptions/two-hour-hands-on/#course-description","title":"Course Description","text":"<p>This hands-on workshop introduces educators to the fundamentals of computational thinking using an engaging and affordable $35 STEM robot built around the Cytron RP2040 Maker Pi board. Participants will gain confidence in teaching computational concepts by experimenting with physical computing tasks. The robot features two DC motors, a time-of-flight sensor, and a 128x64 monochrome display, offering a rich playground for computational exploration.</p> <p>Through guided activities, participants will learn to program the robot using MicroPython in the Thonny IDE, perform basic tasks like blinking LEDs, driving motors, and updating displays, and eventually run a collision avoidance program. This session emphasizes experiential learning and equips teachers with the skills and confidence to bring robotics into their classrooms.</p>"},{"location":"course-descriptions/two-hour-hands-on/#learning-objectives-using-blooms-taxonomy","title":"Learning Objectives (Using Bloom's Taxonomy)","text":""},{"location":"course-descriptions/two-hour-hands-on/#remembering","title":"Remembering","text":"<ol> <li>Define computational thinking and its core concepts.</li> <li>Identify the hardware components of the robot, including the Cytron RP2040 Maker Pi board, DC motors, time-of-flight sensor, and display.</li> </ol>"},{"location":"course-descriptions/two-hour-hands-on/#understanding","title":"Understanding","text":"<ol> <li>Explain why low-cost robots are effective tools for teaching computational thinking.</li> <li>Describe the role of the Thonny IDE in programming and interacting with the robot.</li> </ol>"},{"location":"course-descriptions/two-hour-hands-on/#applying","title":"Applying","text":"<ol> <li>Blink an LED and modify its timing through basic Python programming.</li> <li>Change the color of a NeoPixel LED using RGB values in code.</li> <li>Play a sound using the robot's onboard buzzer.</li> <li>Drive the motors to move the robot forward or backward.</li> </ol>"},{"location":"course-descriptions/two-hour-hands-on/#analyzing","title":"Analyzing","text":"<ol> <li>Analyze data from the time-of-flight distance sensor to determine proximity to objects.</li> <li>Break down how the collision avoidance program combines sensor input, motor control, and decision-making.</li> </ol>"},{"location":"course-descriptions/two-hour-hands-on/#evaluating","title":"Evaluating","text":"<ol> <li>Evaluate the effectiveness of the collision avoidance program by testing it in a simulated environment (robot corral).</li> <li>Assess the potential of using the robot as a teaching tool in different classroom contexts.</li> </ol>"},{"location":"course-descriptions/two-hour-hands-on/#creating","title":"Creating","text":"<ol> <li>Write and execute a simple program to update the robot's display with custom text or graphics.</li> <li>Combine individual programs to design a custom behavior for the robot.</li> </ol>"},{"location":"course-descriptions/two-hour-hands-on/#course-outline","title":"Course Outline","text":""},{"location":"course-descriptions/two-hour-hands-on/#introduction-10-minutes","title":"Introduction (10 minutes)","text":"<ol> <li>What is Computational Thinking?<ul> <li>Core principles: decomposition, pattern recognition, abstraction, and algorithm design.</li> </ul> </li> <li>Why Fun, Low-Cost Robots?<ul> <li>How hands-on activities make abstract concepts tangible and engaging.</li> </ul> </li> </ol>"},{"location":"course-descriptions/two-hour-hands-on/#exploring-physical-computing-15-minutes","title":"Exploring Physical Computing (15 minutes)","text":"<ol> <li>Overview of physical computing and how the Cytron RP2040 Maker Pi board interfaces with sensors, motors, and displays.</li> </ol>"},{"location":"course-descriptions/two-hour-hands-on/#hands-on-activities-90-minutes","title":"Hands-on Activities (90 minutes)","text":"<ol> <li>Getting Started with Thonny (5 minutes)<ul> <li>Brief walkthrough of installing and using Thonny to connect with the robot.</li> </ul> </li> <li>Blinking an LED (10 minutes)<ul> <li>Modify LED blink timings to understand basic code structures.</li> </ul> </li> <li>Changing Color on a NeoPixel (10 minutes)<ul> <li>Experiment with RGB values to create different LED colors.</li> </ul> </li> <li>Playing a Sound (5 minutes)<ul> <li>Code the onboard buzzer to play tones.</li> </ul> </li> <li>Driving a Motor (10 minutes)<ul> <li>Program motor controls for forward and backward movement.</li> </ul> </li> <li>Reading the Distance Sensor (10 minutes)<ul> <li>Write a script to read and print sensor data in real time.</li> </ul> </li> <li>Updating the Display (10 minutes)<ul> <li>Display text and simple graphics on the 128x64 monochrome screen.</li> </ul> </li> <li>Running the Collision Avoidance Program (15 minutes)<ul> <li>Load and test a pre-written collision avoidance script.</li> </ul> </li> </ol>"},{"location":"course-descriptions/two-hour-hands-on/#wrap-up-activity-5-minutes","title":"Wrap-up Activity (5 minutes)","text":"<ol> <li>Putting the Robot in the Corral<ul> <li>Test the robot's performance in a designated area to observe collision avoidance in action.</li> </ul> </li> </ol>"},{"location":"course-descriptions/two-hour-hands-on/#closing-5-minutes","title":"Closing (5 minutes)","text":"<ul> <li>Recap of key concepts.</li> <li>Resources for continuing learning.</li> <li>Q&amp;A session.</li> </ul>"},{"location":"course-descriptions/two-hour-hands-on/#required-pre-class-preparation","title":"Required Pre-Class Preparation","text":"<ul> <li>Install Thonny IDE on classroom desktops or laptops.</li> <li>Ensure access to the STEM robot kit with Cytron RP2040 Maker Pi board.</li> <li>Download workshop resources and pre-written scripts from the provided link.</li> </ul> <p>This course not only empowers educators with the tools to teach computational thinking but also inspires confidence through a fun and approachable introduction to robotics and coding.</p>"},{"location":"gallery/","title":"Gallery of Robots","text":""},{"location":"gallery/#2023","title":"2023","text":""},{"location":"gallery/#2022","title":"2022","text":""},{"location":"gallery/#2019","title":"2019","text":""},{"location":"gallery/#2017","title":"2017","text":""},{"location":"instructors-guide/","title":"Instructors Guide","text":"<p>This section describes guidelines for people teaching STEM robotics courses.  We don't just focus on the process of setting up a great STEM Robotics event or course, we also review some of the underlying processes we are attempting to teach.</p>"},{"location":"instructors-guide/#computational-thinking","title":"Computational Thinking","text":"<p>Computational thinking is a name we give to describing the underlying patterns that guide the development of computer science curriculum.  Our goal is to teach these concepts using a fun curriculum.</p> <p>Read the Section on Computational Thinking</p>"},{"location":"instructors-guide/chrome-local/","title":"Chrome Local","text":"<p>Chrome will not open <code>http://10.0.0.57</code> New security checks called Insecure Private Network Requests</p> <p>Start Chrome with this feature disabled.</p> <p><code>--disable-features=BlockInsecurePrivateNetworkRequests</code></p>"},{"location":"instructors-guide/chrome-local/#shell-script","title":"Shell Script","text":"<pre><code>#!/bin/bash\n\"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\" \\\n--disable-features=BlockInsecurePrivateNetworkRequests,PrivateNetworkAccessChecks,IsolateOrigins,site-per-process,NetworkServiceInProcess,UseDNSHttpsSvcb \\\n--disable-network-service \\\n--user-data-dir=/tmp/test-profile\n</code></pre> <p>Excellent work! You found the perfect solution! Those are exactly the right Chrome flags to bypass the private network blocking. Let me help you make this even better for teaching:I've created an enhanced version of your script that's perfect for teaching! Here's what I added:</p>"},{"location":"instructors-guide/chrome-local/#key-improvements-for-students","title":"Key Improvements for Students:","text":"<p>1. Safety Checks: - Detects if Chrome is already running - Uses unique temporary profiles - Automatic cleanup</p> <p>2. Educational Features: - Clear warnings about security implications - Landing page with helpful links - Explanations of what's happening</p> <p>3. Student-Friendly: - Step-by-step instructions - Quick links to common ports - Clear do's and don'ts</p>"},{"location":"instructors-guide/chrome-local/#what-each-flag-does-for-teaching","title":"What Each Flag Does (For Teaching):","text":"<pre><code>--disable-features=BlockInsecurePrivateNetworkRequests    # Allows HTTP to local IPs\n--disable-features=PrivateNetworkAccessChecks            # Disables network access checks  \n--disable-network-service                                 # Bypasses Chrome's network filtering\n--disable-web-security                                    # Allows mixed content\n--allow-running-insecure-content                         # Permits HTTP on local network\n--user-data-dir=\"/tmp/profile\"                          # Uses temporary profile\n</code></pre>"},{"location":"instructors-guide/chrome-local/#for-your-curriculum","title":"For Your Curriculum:","text":"<p>Create a simple instruction sheet:</p> <pre><code>## Using Chrome for Pico W Development\n\n### Method 1: Use Firefox (Recommended)\n- Just open Firefox and go to http://10.0.0.57:8080/\n- No setup required!\n\n### Method 2: Chrome with Development Script\n1. Save the script as `chrome-local.sh`\n2. Make it executable: `chmod +x chrome-local.sh`  \n3. Run it: `./chrome-local.sh`\n4. Use ONLY for Pico W testing\n5. Close when done\n\n### Why This Is Needed\nChrome blocks HTTP connections to local devices for security.\nThis is a real-world web development challenge!\n</code></pre>"},{"location":"instructors-guide/chrome-local/#student-benefits","title":"Student Benefits:","text":"<p>Educational Value: - Shows real browser security concepts - Demonstrates why developers test in multiple browsers - Teaches about HTTP vs HTTPS implications</p> <p>Practical Value: - Works reliably for IoT projects - Safe temporary profile approach - Clear security boundaries</p> <p>Would you like me to create: 1. Student handout explaining browser security? 2. Troubleshooting guide for common issues? 3. Simple version of the script for younger students?</p> <p>Your solution is perfect - this enhanced version just makes it more classroom-ready!</p>"},{"location":"instructors-guide/computational-thinking/","title":"Computational Thinking","text":"<p>Computational thinking is a name we give to describing the underlying patterns that guide the development of computer science curriculum.</p> <p>There are four key patterns that are frequently discussed when we talk about computational thinking.</p> <ol> <li>abstraction \u2013 focusing on the important information only, ignoring irrelevant detail.</li> <li>algorithms - developing a step-by-step solution to the problem, or the rules to follow to solve the problem.</li> <li>decomposition - breaking down a complex problem or system into smaller, more manageable parts.</li> <li>pattern recognition \u2013 looking for similarities among and within problems.</li> </ol> <p>We have to added the concept of expandability and bias to these concepts:</p> <ol> <li>explainability - can a computer explain why it took a specific action or made a specific recommendation?</li> <li>bias - is the result of the suggestion made by a computer skewed in a direction that makes it unfair to a group of people?</li> </ol>"},{"location":"instructors-guide/computational-thinking/#other-common-design-patterns","title":"Other Common Design Patterns","text":"<p>Although we have many different coding groups that are appropriate for beginners, there are several computer science concepts that we encourage everyone to adopt in your coding group curriculum.</p> <p>Events - What events start a program?  What events change the behavior of a program?</p> <p>Loops - How do repeat a set of tasks?</p> <p>Variables - How do we reference a common value and make our programs easier to change?</p> <p>Conditionals - How do we change program behavior based on rules.  How do we use comparisons to do this?  How do we implement if/then/else or switch/case logic to be easy to understand and maintain?</p> <p>Functions - How do we group code sections together and give them names?</p> <p>Function Parameters - How do we pass values to functions? How can parameters make functions more widely reusable? Why would we want to check the types of an input parameters?  What happens when we pass invalid data types to a function?</p> <p>Data types - What is the difference between a string of characters, an integer, a floating point number or a datetime?  How do we use the right datatype and type checking to keep our programs reliable?</p> <p>Data Structures - How do you create and manage lists, dictionaries, arrays and complex data structures?</p> <p>Sensors - How do we gather input from the real world?</p> <p>Output - How do we display text or graphic output on a small display screen or print statements to a serial console for debugging?</p> <p>Feedback - how do we prompt users for input and respond to changes in output</p> <p>Debugging - How do we find problems in our code?  How can we stop execution of our code using a debugger?  How do we inspect the value of variables when a program has paused?</p> <p>Drawing - Drawing to a graphics device is a great way to learn other concepts where you get quick visual feedback.  Drawing can be our on ramp to drawing charts and graphs.  See our SVG Labs for excellent examples of learning to program with graphics.</p> <p>Recursion - What happens when a function calls itself?  How can you draw trees that have many smaller branches?</p> <p>Commenting - How do we put hints in our code for others to better understand our code?  How do comments make code more maintainable?</p> <p>Scope - How do we protect variables from unintended updates?  How do we use global variables sparingly.  How do we use local variables and when should move variables from global to local or vice versa?</p>"},{"location":"instructors-guide/computational-thinking/#advanced-concepts","title":"Advanced concepts","text":"<p>Here are a few topics that you can explore with your move advanced students.</p> <p>Files - How do we read data in from files and write data out to files?  How do we append to the end of files?</p> <p>Regular Expressions - How do we use a short set of special characters to look for patterns in strings and text?</p> <p>Integrated Development Environments - How do we setup our desktop so that we can be productive debugging our programs?  What is syntax highlighting?  What is autocomplete?</p> <p>Logging - How do we keep a record of what has happened in our programs?</p>"},{"location":"kits/","title":"Introduction to STEM Robot Kits","text":""},{"location":"kits/#base-bot","title":"Base Bot","text":"<ul> <li>Total cost: $18</li> <li>Cytron board: $11</li> <li>Chassis Kit: $4</li> <li>Time of Flight Distance Sensor: $3</li> </ul>"},{"location":"kits/#base-bot-with-8-element-neopixel","title":"Base Bot with 8-Element NeoPixel","text":"<ul> <li>Total cost: $19</li> <li>Cytron board: $11</li> <li>Time of Flight Distance Sensor: $3</li> <li>8 Element NeoPixel Strip</li> </ul>"},{"location":"kits/#display-bot","title":"Display Bot","text":""},{"location":"kits/adjust/","title":"Adjustabot","text":"<p>This robot allows the parameters of collision avoidance to be adjusted by turning knobs.  You can effectively \"program\" this robot to change its behavior by adjusting parameters such as:</p> <ol> <li>Motor power - which determines the speed</li> <li>Distance threshold - which changes when a robot turns</li> <li>Turn time - which changes that angle of turn after a collision</li> </ol> <p>This robot is ideal for projects that don't have a lab of PCs that are used to customize a robot's program.</p>"},{"location":"kits/adjust/#parts-list","title":"Parts List","text":"<p>We start with our Display robot and add three potentiometers that can be adjusted to change the parameters.</p>"},{"location":"kits/base/","title":"Base Robot","text":"<p>This is our classic low-cost robot that can be purchased for around $19 each and can be assembled without any soldering.  It is built on the powerful [Cytron Maker Pi RP2040] board that is programmed by the same software that powers the Raspberry Pi Pico.</p> <p>MicroPython for Kids</p>"},{"location":"kits/base/#introduction-to-the-base-stem-robot","title":"Introduction to the Base STEM Robot","text":"<p>Although there are many variations of our STEM Robot, this robot was specifically designed for classrooms that don't want to require any soldering and complex wiring.</p>"},{"location":"kits/base/01-testing-motor-connections/","title":"Testing Motor Connections","text":""},{"location":"kits/base/01-testing-motor-connections/#activity-overview","title":"Activity Overview","text":"<p>Students will work with a MicroPython-controlled robot to understand motor control, PWM signals, and basic robotics programming.</p>"},{"location":"kits/base/01-testing-motor-connections/#learning-objectives","title":"Learning Objectives","text":"<p>Students will be able to:</p> <ul> <li>Understand how PWM controls motor speed and direction</li> <li>Identify the purpose of each pin configuration</li> <li>Observe and document motor behavior</li> <li>Modify code parameters to change robot behavior</li> </ul>"},{"location":"kits/base/01-testing-motor-connections/#materials-needed","title":"Materials Needed","text":"<ul> <li> <p>MicroPython-compatible microcontroller (Raspberry Pi Pico recommended)</p> </li> <li> <p>Robot chassis with two motors</p> </li> <li>Jumper wires</li> <li>Computer with MicroPython IDE</li> </ul>"},{"location":"kits/base/01-testing-motor-connections/#student-activities","title":"Student Activities","text":""},{"location":"kits/base/01-testing-motor-connections/#activity-1-code-analysis","title":"Activity 1: Code Analysis","text":"<ul> <li> <p>Read through the provided code and identify the four motor control pins</p> </li> <li> <p>Explain what the <code>POWER_LEVEL</code> constant controls</p> </li> <li>Predict what the robot will do when the code runs</li> </ul>"},{"location":"kits/base/01-testing-motor-connections/#activity-2-initial-testing","title":"Activity 2: Initial Testing","text":"<ul> <li>Connect the motors according to the pin assignments</li> <li>Run the code and observe which wheels move in which directions</li> <li>Record observations for each motor test phase</li> <li>Note any motors that don't work as expected</li> </ul>"},{"location":"kits/base/01-testing-motor-connections/#activity-3-pin-calibration","title":"Activity 3: Pin Calibration","text":"<ul> <li>If wheels move in unexpected directions, modify the pin assignments</li> <li>Test different pin combinations until all motors work correctly</li> <li>Document the correct pin configuration for your robot</li> </ul>"},{"location":"kits/base/01-testing-motor-connections/#activity-4-parameter-modification","title":"Activity 4: Parameter Modification","text":"<ul> <li>Change the <code>POWER_LEVEL</code> value and observe speed differences</li> <li>Modify the sleep times to make movements faster or slower</li> <li>Test values between 0-65535 for power level</li> </ul>"},{"location":"kits/base/01-testing-motor-connections/#activity-5-movement-programming","title":"Activity 5: Movement Programming","text":"<ul> <li>Create new functions for specific movements (forward, backward, turn left, turn right)</li> <li>Replace the test loop with a sequence of actual robot movements</li> <li>Program the robot to move in a square pattern</li> </ul>"},{"location":"kits/base/01-testing-motor-connections/#assessment-questions","title":"Assessment Questions","text":"<ul> <li>What happens if you set <code>POWER_LEVEL</code> to 0?</li> <li>Why does the code use separate pins for forward and reverse?</li> <li>How would you modify the code to make the robot turn in place?</li> </ul>"},{"location":"kits/base/01-testing-motor-connections/#sample-code","title":"Sample Code","text":"<pre><code>from machine import Pin, PWM\nfrom utime import sleep\n\nPOWER_LEVEL = 65025\n\n# change these numbers until you get the right wheel and direction\nRIGHT_FORWARD_PIN = 9\nRIGHT_REVERSE_PIN = 8\nLEFT_FORWARD_PIN = 10\nLEFT_REVERSE_PIN = 11\n\n# setup all the PWM objects with a frequency of 50 Hz\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN), freq=50)\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN), freq=50)\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN), freq=50)\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN), freq=50)\n\ndef spin_wheel(pwm):\n    pwm.duty_u16(POWER_LEVEL)\n    # keep motor on for 3 seconds\n    sleep(3)\n    pwm.duty_u16(0)\n    # turn motor off for two seconds\n    sleep(2)\n\n# the orientation is looking down from the back of the robot\nwhile True:\n    print('right forward')\n    spin_wheel(right_forward)\n\n    print('right reverse')\n    spin_wheel(right_reverse)\n\n    print('left foward')\n    spin_wheel(left_forward)\n\n    print('left_reverse')\n    spin_wheel(left_reverse)\n</code></pre>"},{"location":"kits/base/03-neopixel-test/","title":"NeoPixel Blink Test","text":""},{"location":"kits/base/03-neopixel-test/#simple-blink-test","title":"Simple Blink Test","text":"<p>This program blinks the first pixel in a NeoPixel strip red.</p> <pre><code>from machine import Pin\nfrom utime import sleep\nfrom neopixel import NeoPixel\n\nNEOPIXEL_PIN = 18\nNUMBER_PIXELS = 2\n\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nwhile True:\n    # turn first red pixel on for 1/2 second\n    strip[0] = (255,0,0)\n    strip.write()\n    sleep(.5)\n\n    # turn off for 1/2 second\n    strip[0] = (0,0,0)\n    strip.write()\n    sleep(.5)\n</code></pre>"},{"location":"kits/base/03-neopixel-test/#color-blink","title":"Color Blink","text":"<p>This will make the first pixel blink red and the second pixel blink green.</p> <pre><code>from machine import Pin\nfrom utime import sleep\nfrom neopixel import NeoPixel\n\nNEOPIXEL_PIN = 18\nNUMBER_PIXELS = 2\n\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nwhile True:\n    # turn first [0] pixel red on for 1/2 second\n    # use a red brightness of 10 out of 255 (r, g, b)\n    strip[0] = (10,0,0)\n    # turn the second pixel [1] green\n    strip[1] = (0,10,0)\n    # send data to the strip\n    strip.write()\n    # pause for 1/2 second\n    sleep(.5)\n\n    # turn both off for 1/2 second\n    strip[0] = (0,0,0)\n    strip[1] = (0,0,0)\n    strip.write()\n    sleep(.5)\n</code></pre>"},{"location":"kits/base/03-neopixel-test/#color-wheel","title":"Color Wheel","text":"<p>Each pixel will slowly change color as they move around the color wheel. The wheel function takes in a number from 0 to 255 and return the r,g and b values as it walks around the color wheel.  See the Moving Rainbow labs for details.</p> <pre><code>import machine\nfrom neopixel import NeoPixel\nfrom utime import sleep\n\nNEOPIXEL_PIN = 18\nNUMBER_PIXELS = 2\n\nstrip = NeoPixel(machine.Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\ndef wheel(pos):\n    # Input a value 0 to 255 to get a color value.\n    # The colors are a transition r - g - b - back to r.\n    if pos &lt; 0 or pos &gt; 255:\n        return (0, 0, 0)\n    if pos &lt; 85:\n        return (255 - pos * 3, pos * 3, 0)\n    if pos &lt; 170:\n        pos -= 85\n        return (0, 255 - pos * 3, pos * 3)\n    pos -= 170\n    return (pos * 3, 0, 255 - pos * 3)\n\ncounter = 0\nwhile True:\n    # set the color moduo 255\n    # start of color wheel\n    strip[0] = wheel(counter % 255)\n    # 1/2 way around the wheel\n    strip[1] = wheel((counter + 128) % 255)\n    strip.write()\n    sleep(.05)\n    counter += 1\n    # reset the counter\n    if counter == 255:\n        counter = 0\n</code></pre>"},{"location":"kits/base/06-test-sound/","title":"06 test sound","text":"<p># Testing the Robot Speaker</p> <p>This Python code is designed to make a small speaker or buzzer play different sounds! It's written for a microcontroller (like a Raspberry Pi Pico) that can control electronic components.</p>"},{"location":"kits/base/06-test-sound/#what-the-code-does","title":"What the Code Does","text":"<p>Think of this code like a simple music player that can play beeps and tones through a speaker. Here's how it works:</p>"},{"location":"kits/base/06-test-sound/#the-setup","title":"The Setup","text":"<pre><code>from machine import Pin, PWM\nfrom utime import sleep\n\nSPEAKER_PIN = 22\nspeaker = PWM(SPEAKER_PIN)\n</code></pre> <p>This part imports the tools needed to control the hardware and sets up the speaker on pin 22 of the microcontroller. PWM stands for \"Pulse Width Modulation\" - it's a way to control how much power goes to the speaker, which affects the volume and tone.</p>"},{"location":"kits/base/06-test-sound/#the-main-functions","title":"The Main Functions","text":"<p>playnote(frequency, time) - This is like pressing a key on a piano. The <code>frequency</code> determines how high or low the sound is (like different piano keys), and <code>time</code> determines how long the note plays.</p> <p>setfreq(frequency) - This changes the pitch of the sound. Higher numbers make higher-pitched sounds, lower numbers make lower-pitched sounds.</p> <p>sound_off() - This turns the speaker off completely, like lifting your finger off a piano key.</p> <p>rest(time) - This creates silence for a specific amount of time, like a pause between musical notes.</p>"},{"location":"kits/base/06-test-sound/#the-different-sound-effects","title":"The Different Sound Effects","text":"<p>The code creates three different sound patterns:</p> <p>play_no_signal() - Plays a very low, short beep (100 Hz for 0.1 seconds). This might be used to indicate something isn't working.</p> <p>play_turn() - Plays a medium-pitched, quick beep (500 Hz for 0.1 seconds). This could be used when someone takes a turn in a game.</p> <p>play_startup() - Plays a little melody: three quick medium beeps followed by a longer, higher beep. This sounds like something you'd hear when a device turns on.</p>"},{"location":"kits/base/06-test-sound/#what-happens-when-you-run-it","title":"What Happens When You Run It","text":"<p>When you run this code, it automatically plays the startup sound - three quick beeps followed by a longer, higher-pitched tone. It's like the \"power on\" sound for whatever device this code is controlling.</p>"},{"location":"kits/base/06-test-sound/#real-world-comparison","title":"Real-World Comparison","text":"<p>This is similar to how your phone makes different notification sounds, or how a microwave beeps when it's done cooking. The code is creating these simple electronic sounds by rapidly turning the speaker on and off at different speeds (frequencies).</p>"},{"location":"kits/base/06-test-sound/#full-sample-code","title":"Full Sample Code","text":"<p>```python  from machine import Pin, PWM from utime import sleep</p> <p>SPEAKER_PIN = 22</p> <p>speaker = PWM(SPEAKER_PIN)</p> <p>def playnote(frequency, time):     speaker.duty_u16(1000)     setfreq(frequency)     sleep(time)</p> <p>def play_no_signal():     playnote(100, 0.1)     sound_off()</p> <p>def play_turn():     playnote(500, .1)     sound_off()</p> <p>def setfreq(frequency):     speaker.freq(frequency)</p> <p>def sound_off():     speaker.duty_u16(0)</p> <p>def rest(time):     speaker.duty_u16(0)     sleep(time)</p> <p>def play_startup():     playnote(600, .1)     rest(.05)     playnote(600, .1)     rest(.05)     playnote(600, .1)     rest(.1)     playnote(800, .5)     sound_off()</p> <p>play_startup() ```</p>"},{"location":"kits/base/06-up-down-motor-lab/","title":"Up Down Motor Speed Lab","text":"<p>In this lab, we will make the motor speed change as the mode changes.</p> <pre><code># Motor Setup\n# motors just barely turn at this power level\nMIN_POWER_LEVEL = 10000\nMAX_POWER_LEVEL = 65025\nPOWER_STEP = int((MAX_POWER_LEVEL - MIN_POWER_LEVEL) / 10)\n# lower right pins with USB on top\nRIGHT_FORWARD_PIN = 8\nRIGHT_REVERSE_PIN = 9\nLEFT_FORWARD_PIN = 11\nLEFT_REVERSE_PIN = 10\n\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN))\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN))\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN))\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN))\n\ndef drive_speed(power_level):\n    right_forward.duty_u16(power_level)\n    left_forward.duty_u16(power_level)\n</code></pre> <p>In the main we have:</p> <pre><code>power_level = MIN_POWER_LEVEL + mode * POWER_STEP\n# turn off the motor if we are at mode 0\nif mode == 0: power_level = 0\ndrive_speed(power_level)\n</code></pre>"},{"location":"kits/base/06-up-down-motor-lab/#full-program","title":"Full Program","text":"<pre><code># Mode Up/Down Lab\n# Change a mode using the buttons on the Maker Pi RP2040 board\n# Changes the NeoPixel color and the blue GPIO status LEDs\nimport time\nfrom machine import Pin, PWM\n# We are using a MicroPython NeoPixel library from here: https://github.com/blaz-r/pi_pico_neopixel\nfrom neopixel import Neopixel\n\nBUZZER_PORT = 22\nbuzzer = PWM(Pin(BUZZER_PORT))\n\nNUMBER_PIXELS = 2\nSTATE_MACHINE = 0\nNEOPIXEL_PIN = 18\n\n# The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB\nstrip = Neopixel(NUMBER_PIXELS, STATE_MACHINE, NEOPIXEL_PIN, \"GRB\")\n\n# have up to 13 that we can use\nblue_led_pins = [0,1,2,3,4,5,6,7,16,17,26,27,28]\nnumber_leds = len(blue_led_pins)\nled_ports = []\n# create a list of the port pin object instances\nfor i in range(number_leds):\n   led_ports.append(machine.Pin(blue_led_pins[i], machine.Pin.OUT))\n\n# Color RGB values as tuples - needs some Gamma corrections\nred = (255, 0, 0)\norange = (255, 60, 0) # Gamma corrected from G=128 to be less like yellow\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130) # purple?\nviolet = (138, 43, 226) # mostly pink\ncyan = (0, 255, 255)\nlightgreen = (100, 255, 100)\nwhite = (128, 128, 128) # not too bright\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'cyan', 'lightgreen', 'white')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet, cyan, lightgreen, white)\n\n# set to be 1 to 100 for percent brightness\nstrip.brightness(100)\n\n# Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler\n\n# Motor Setup\n# motors just barely turn at this power level\nMIN_POWER_LEVEL = 10000\nMAX_POWER_LEVEL = 65025\nPOWER_STEP = int((MAX_POWER_LEVEL - MIN_POWER_LEVEL) / 10)\n# lower right pins with USB on top\nRIGHT_FORWARD_PIN = 8\nRIGHT_REVERSE_PIN = 9\nLEFT_FORWARD_PIN = 11\nLEFT_REVERSE_PIN = 10\n\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN))\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN))\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN))\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN))\n\ndef drive_speed(power_level):\n    right_forward.duty_u16(power_level)\n    left_forward.duty_u16(power_level)\n\nmode = 0 # the default mode on powerup and reset\nmode_count = len(color_names)\nlast_time = 0 # the last time we pressed the button\n\nbuiltin_led = machine.Pin(25, Pin.OUT)\n# Give our pins some logical names\nnext_mode_pin = machine.Pin(20, machine.Pin.IN, machine.Pin.PULL_DOWN)\nprevious_mode_pin = machine.Pin(21, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\n# This function gets called every time the button is pressed.  The parameter \"pin\" is not used.\ndef button_pressed_handler(pin):\n    global mode, last_time, power_level\n    new_time = time.ticks_ms()\n    # if it has been more that 1/5 of a second since the last event, we have a new event\n    if (new_time - last_time) &gt; 200:\n        # this should be pin.id but it does not work\n        if '20' in str(pin):\n            mode +=1\n            # power_level += POWER_STEP\n        else:\n            mode -=1\n            # power_level -= POWER_STEP\n        # wrap around to first mode\n        if mode &gt;= mode_count: mode = 0\n        if mode &lt; 0: mode = mode_count - 1\n        last_time = new_time\n\ndef set_blue_led_mode(mode):\n    global num_colors\n    for i in range(0, num_colors):\n        if i == mode:\n            led_ports[i].high()\n        else:\n            led_ports[i].low()\n\n# Register the handler function when either button is pressed\nnext_mode_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\nprevious_mode_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\n\n# non-linear increase is frequency - note that some are lowder\ntone_freq = [100, 150, 210, 280, 350, 450, 580, 750, 850, 950, 1000]\ndef playtone(frequency):\n    buzzer.duty_u16(1000)\n    buzzer.freq(frequency)\n\ndef bequiet():\n    buzzer.duty_u16(0)\n\n# This is for only printing when a new button press count value happens\nold_mode = -1\n\npower_level = MIN_POWER_LEVEL\nprint('found ', mode_count, ' modes.')\nwhile True:\n    # only print on change in the button_presses value\n    if mode != old_mode:\n        print('new mode:', mode, color_names[mode], tone_freq[mode], power_level)\n        # get the color mode\n        color = colors[mode]\n        strip.set_pixel(0, color)\n        strip.set_pixel(1, color)\n        strip.show()\n        set_blue_led_mode(mode)\n        playtone(tone_freq[mode])\n        time.sleep(.2)\n        bequiet()\n        power_level = MIN_POWER_LEVEL + mode * POWER_STEP\n        # turn off the motor if we are at mode 0\n        if mode == 0: power_level = 0\n        drive_speed(power_level)\n        old_mode = mode\n</code></pre>"},{"location":"kits/base/07-motor-connection-lab/","title":"Motor Drive Connection Test","text":""},{"location":"kits/base/07-motor-connection-lab/#built-in-motor-driver","title":"Built-In Motor Driver","text":"<p>The Maker Pi RP2040 board contains a MX1508 dual-channel H-bridge chip and easy-to-connect screw headers for power and motor connections.  This is fantastic for teaching robotics since students can driver two motors without ever having to use a soldering iron.</p> <p>!!! Note that the is designed to work with small DC-hobby motors and there is no documentation on exactly what motor driver chip is used or its precise current and power limitations.</p> <p>The documentation only indicates that the maximum current is 1A continuous power and 1.5A for up to 5 seconds.  The input voltage is only rated at 6 volts, which find for our standard 4 AA battery packs.</p> <p>If this motor driver chip is similar to the ubiquitous L293x motor controllers, and the current should be 1A per motor.</p> <p>I suspect that if you glued a small heat sink like a 16 pin DIP fin to the unknown motor driver IC on the main board you could drive slightly larger motors.</p> <p> Close-up of the motor driver chip.  I can't quite make out the numbers on the chip, but the logo is not \"TI\".</p>"},{"location":"kits/base/07-motor-connection-lab/#testing-the-connections","title":"Testing The Connections","text":"<p>In our standard robot, the M1 is the right wheel as you are looking from the top-back of the robot.  The M2 wheel is the left wheel.  I connect the red to the right of the two connectors and it is also the right terminal of the motors as you are looking from the rear.</p> <p>Look at the buttons near the motor connectors.  Press the M1A button and verify that the right wheel is moving forward.  Press the M1B and the motor should turn in reverse.  Similarly the M2B button should turn the left wheel forward and the M2A should turn the left wheel in reverse.  If you don't wire these connections the same way I did it is not a worry.  It is easy to change the code.</p>"},{"location":"kits/base/07-motor-connection-lab/#motor-pin-definitions","title":"Motor Pin Definitions","text":"<p>Now that we know what buttons control what motors and directions they turn, we are ready to define the pins that are associated with each robot movement.  We have four pin assignments: both forward and reverse for both the right and left motors.</p> <pre><code>RIGHT_FORWARD_PIN = 8\nRIGHT_REVERSE_PIN = 9\nLEFT_FORWARD_PIN = 11\nLEFT_REVERSE_PIN = 10\n</code></pre>"},{"location":"kits/base/07-motor-connection-lab/#testing-your-pin-definitions","title":"Testing Your Pin Definitions","text":"<p>The following program is called our motor connection test.  It will turn each motor direction for three seconds and it will print out the motor and direction in the console.</p> <pre><code>from machine import Pin, PWM\nimport time\n\nPOWER_LEVEL = 65025\n# lower right pins with USB on top\nRIGHT_FORWARD_PIN = 8\nRIGHT_REVERSE_PIN = 9\nLEFT_FORWARD_PIN = 11\nLEFT_REVERSE_PIN = 10\n\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN))\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN))\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN))\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN))\n\ndef spin_wheel(pwm):\n        pwm.duty_u16(POWER_LEVEL)\n        time.sleep(3)\n        pwm.duty_u16(0)\n        time.sleep(2)\n\nwhile True:\n    print('right forward')\n    spin_wheel(right_forward)\n\n    print('right reverse')\n    spin_wheel(right_reverse)\n\n    print('left foward')\n    spin_wheel(left_forward)\n\n    print('left_reverse')\n    spin_wheel(left_reverse)\n</code></pre>"},{"location":"kits/base/07b-drive-square-lab/","title":"Drive Square Lab","text":""},{"location":"kits/base/07b-drive-square-lab/#prerequsites","title":"Prerequsites","text":"<p>This lab assumes you have your Maker Pi RP2040 mounted on a SmartCar chassis with two motors and a battery hooked up.</p> <p>In this lab we will program our robot to drive in a square pattern. We will start out doing a \"bench test\" that will require you to put the robot up on a block so you can see the wheels turn, but it will not drive off your desktop.  You can also observe the red LED lights on the many board to see which motor direction is on.</p> <p>The main loop will look like this:</p> <pre><code>while True:\n    forward()\n    sleep(FWD_TIME)\n\n    stop()\n    sleep(STOP_TIME)\n\n    turn_right()\n    sleep(TURN_TIME)\n\n    stop()\n    sleep(STOP_TIME)\n</code></pre> <p>We will need to adjust the TURN_TIME parameter to have the robot turn 90 degrees.  A good value for most robots is about 1/2 second or sleep(.5).</p> <p>Since we will be calling the sleep function many times we will use the following import format to keep our code tidy:</p> <p><pre><code>from utime import sleep\n</code></pre> This says that whenever we want to pause our system we just use the <code>sleep(time)</code> function we mean to use the sleep function in the micropython time library.  This keeps our code small and portable.</p>"},{"location":"kits/base/07b-drive-square-lab/#adding-a-keyboard-interrupt-handler-control-c","title":"Adding a Keyboard Interrupt Handler (Control-C)","text":"<p>It is also a problem that when we stop a program running that the PWM circuits keep generating signals, which means the robot keeps moving even after we press the STOP/RESET button.  To clean this up we will allow you to run a special cleanup handler that will add a function to set all the motors to off using the <code>stop()</code> function.</p> <pre><code>try:\n    main()\nexcept KeyboardInterrupt:\n    print('Got ctrl-c')\nfinally:\n    # Optional cleanup code\n    print('Cleaning up')\n    print('Powering down all motors now.')\n    stop()\n</code></pre>"},{"location":"kits/base/07b-drive-square-lab/#full-program","title":"Full Program","text":"<p>You are now ready to test the full program.  Save the following to the main.py file, disconnect the USB connector and turn on the power on the main board.  Your robot should not we driving in a square!</p> <pre><code>from machine import Pin, PWM\nfrom utime import sleep\n\nPOWER_LEVEL = 65025\n# lower right pins with USB on top\nRIGHT_FORWARD_PIN = 8\nRIGHT_REVERSE_PIN = 9\nLEFT_FORWARD_PIN = 11\nLEFT_REVERSE_PIN = 10\n\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN))\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN))\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN))\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN))\n\nFWD_TIME = 2\nTURN_TIME = .5 # adjust this to get the turn to be 90 degrees\nSTOP_TIME = 2\n\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN))\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN))\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN))\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN))\n\n\ndef turn_motor_on(pwm):\n   pwm.duty_u16(POWER_LEVEL)\n\ndef turn_motor_off(pwm):\n   pwm.duty_u16(0)\n\ndef forward():\n    turn_motor_on(right_forward)\n    turn_motor_on(left_forward)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_reverse)\n\ndef reverse():\n    turn_motor_on(right_reverse)\n    turn_motor_on(left_reverse)\n    turn_motor_off(right_forward)\n    turn_motor_off(left_forward)\n\ndef turn_right():\n    turn_motor_on(right_forward)\n    turn_motor_on(left_reverse)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_forward)\n\ndef turn_left():\n    turn_motor_on(right_reverse)\n    turn_motor_on(left_forward)\n    turn_motor_off(right_forward)\n    turn_motor_off(left_reverse)\n\ndef stop():\n    turn_motor_off(right_forward)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_forward)\n    turn_motor_off(left_reverse)\n\nprint('Running Drive Square Lab')\nprint('Use Control-C to Stop All Motors')\n\ndef main():\n    while True:\n        print('forward')\n        forward()\n        sleep(FWD_TIME)\n\n        print('stop')\n        stop()\n        sleep(STOP_TIME)\n\n        print('turning right')\n        turn_right()\n        sleep(TURN_TIME)\n\n        print('stop')\n        stop()\n        sleep(STOP_TIME)\n\ntry:\n    main()\nexcept KeyboardInterrupt:\n    print('Got ctrl-c')\nfinally:\n    # Optional cleanup code\n    print('Cleaning up')\n    print('Powering down all motors now.')\n    stop()\n</code></pre>"},{"location":"kits/base/08-servo-lab/","title":"Maker Pi RP2040 Servo Lab","text":"<p>Servo motors are ideal for controlling the angle of an item such as a steering angle or the direction of a sensor.  The servos used in these labs are inexpensive SG90 micro-servos that draw very little power and are ideal for a teaching lab.  They can be purchased for about $3 each US on eBay.  To control a 180 degree servo, you just tell it what angle you would like it to move to.  The range of values is typically -90 to 90 degrees with 0 being the nominal resting position for many applications such as the steering wheel angle of a car.</p> <p>The Maker Pi RP2040 has four servo ports in the upper left corner of the board (with the USB on the bottom) that use ports GP12, GP13, GP14 and GP15.  You can connect any small micro servo directly to these ports.  Just make sure to get the polarity correct.  The colors for servos may vary somewhat, but the two most common standards are:</p> <ul> <li>Orange, red and brown - signal, positive and ground</li> <li>White, red, black - signal, positive and ground</li> </ul> <p>The general rule is that the lighter colors of orange and white will be the signal and the brown and black will be ground.</p>"},{"location":"kits/base/08-servo-lab/#servo-control","title":"Servo Control","text":"<p>We will use the PWM functions in our MicroPython library to send a PWM signal to each of the servos.  Servos are not controlled by the duty cycle directly.  They are controlled by the width of the pulses.  But we can control the approximate with of the pulses by holding the frequency constant and changing the duty cycle.</p> <p>We will use a 40 hertz signal to send a PWM signal to each of the servos like this.</p> <pre><code>SERVO_FREQ_HZ = 40\n# SERVO_PERIOD_MS = 1000 / SERVO_FREQ_HZ is a 25 millisecond pulse width\nmy_pwm.freq(SERVO_FREQ_HZ)\n</code></pre>"},{"location":"kits/base/08-servo-lab/#calibration-of-the-servo","title":"Calibration of the Servo","text":"<p>There are small manufacturing variations in servos.  This means to get the full sweep of a 180% servo you have to adjust the duty cycle.</p> <ul> <li>Minimum duty cycle: 1700</li> <li>Maximum duty cycle: 6300</li> </ul> <p>By some experimentation I got the following results <pre><code>SERVO_MIN_DUTY = 1725 # -90 degrees\nSERVO_MAX_DUTY = 6378 # 90 degrees\n</code></pre></p> <p>We can use a linear mapping function to convert the angle (from -90 to 90):</p> <pre><code># This will take in integers of range in (min and max) return a integer in the output range (min and max)\n# Used to convert one range of values into another using a linear function like the Arduino map() function\ndef convert(x, in_min, in_max, out_min, out_max):\n    return (x - in_min) * (out_max - out_min) // (in_max - in_min) + out_min\n\nangle = 0\nduty = convert(angle, -90, 90, SERVO_MIN_DUTY, SERVO_MAX_DUTY)\nprint('For angle: ', angle, ' the duty is: ', duty)\npwm.duty_u16(duty)\n</code></pre>"},{"location":"kits/base/08-servo-lab/#checking-your-servo-calibration-with-buttons","title":"Checking your Servo Calibration with Buttons","text":"<p>We can also use the buttons on the Maker Pi RP2040 to verify that the extreme angles are correct.  One button will increase the angle and one will decrease the angle.</p> <pre><code># Maker Pi RP2040 program to check the limits of a 180 degree servo such as a SG90 micro servo\nfrom machine import Pin, PWM\nimport time\n\nBUTTON_1_PIN = 20 # increment the angle\nBUTTON_2_PIN = 21 # decrement the angle\n\nSERVO_1_PIN = 12\nSERVO_2_PIN = 13 # MAX=5749@40\nSERVO_3_PIN = 14\nSERVO_4_PIN = 15\n# this is ususlly standard across most servos\nSERVO_FREQ_HZ = 40\n\npwm = PWM(Pin(SERVO_2_PIN))\n\n# the two button on the Maker Pi RP2040\nincrement_angle_button_pin = machine.Pin(BUTTON_1_PIN, machine.Pin.IN, machine.Pin.PULL_DOWN)\ndecrement_angle_button_pin = machine.Pin(BUTTON_2_PIN, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\n\n#  return int( ( (0.0015*SERVO_FREQ_HZ) + ((angle/90) * (0.0005*SERVO_FREQ_HZ)) ) * 65535 )\n# This will take in integers of range in (min and max) return a integer in the output range (min and max)\n# Used to convert one range of values into another using a linear function like the Arduino map() function\ndef convert(x, in_min, in_max, out_min, out_max):\n    return (x - in_min) * (out_max - out_min) // (in_max - in_min) + out_min\n\n# globals\nangle = -90\nlast_time = 0 # the last time we pressed the button\n\n# if the pin is 20 then increment, else decement\ndef button_pressed_handler(pin):\n    global angle, last_time\n    new_time = time.ticks_ms()\n    # if it has been more that 1/5 of a second since the last event, we have a new event\n    if (new_time - last_time) &gt; 200:\n        # this should be pin.id but it does not work\n        if '20' in str(pin):\n            angle +=1\n        else:\n            angle -=1\n        last_time = new_time\n # now we register the handler function when the button is pressed\nincrement_angle_button_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\ndecrement_angle_button_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\n\npwm.freq(SERVO_FREQ_HZ)\nold_angle = -1\n\nwhile True:\n    # only print on change in the button_presses value\n    if angle != old_angle:\n        duty = ServoDuty(angle)\n        print('new angle:', angle, 'duty: ', duty)\n        pwm.duty_u16(duty)\n        old_angle = angle\n</code></pre>"},{"location":"kits/base/08-servo-lab/#sample-sweep-code","title":"Sample Sweep Code","text":"<pre><code>from machine import Pin, PWM\nimport time\n\nBUTTON_1_PIN = 20\nBUTTON_2_PIN = 21\n\nSERVO_1_PIN = 12\nSERVO_2_PIN = 13\nSERVO_3_PIN = 14\nSERVO_4_PIN = 15\nSERVO_FREQ_HZ = 50\nSERVO_MIN_DUTY = 1725\nSERVO_MAX_DUTY = 6378\n# this is ususlly standard across most servos\nSERVO_FREQ_HZ = 40\n\npwm = PWM(Pin(SERVO_2_PIN))\n\n# the two button on the Maker Pi RP2040\nclock_button_pin = machine.Pin(BUTTON_1_PIN, machine.Pin.IN, machine.Pin.PULL_DOWN)\ncounter_clock_button_pin = machine.Pin(BUTTON_2_PIN, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\n# globals\nangle = 90\nlast_time = 0 # the last time we pressed the button\n\ndef button_pressed_handler(pin):\n    global angle, last_time\n    new_time = time.ticks_ms()\n    # if it has been more that 1/5 of a second since the last event, we have a new event\n    if (new_time - last_time) &gt; 200:\n        # this should be pin.id but it does not work\n        if '20' in str(pin):\n            angle +=1\n        else:\n            angle -=1\n        # wrap around to first mode\n        if mode &gt;= mode_count: mode = 0\n        if mode &lt; 0: mode = mode_count - 1\n        last_time = new_time\n\n# now we register the handler function when the button is pressed\nclock_button_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\ncounter_clock_button_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)      \n#  return int( ( (0.0015*SERVO_FREQ_HZ) + ((angle/90) * (0.0005*SERVO_FREQ_HZ)) ) * 65535 )\n\n# Thisw will take in integers of range in (min and max) return a integer in the output range (min and max)\n# Used to convert one range of values into another using a linear function like the Arduino map() function\ndef convert(x, in_min, in_max, out_min, out_max):\n    return (x - in_min) * (out_max - out_min) // (in_max - in_min) + out_min\n\n# -90 should generate 1725\n# 90 should generate 7973\n\nold_angle = -1\n\npwm.freq(50)\nwhile True:\n    for angle in range(-90, 90):\n        duty = convert(angle, -90, 90, SERVO_MIN_DUTY, SERVO_MAX_DUTY)\n        print('angle:', angle, 'duty: ', duty)\n        pwm.duty_u16(duty)\n        old_angle = angle\n        time.sleep(.01)\n    for angle in range(90, -90, -1):\n        duty = convert(angle, -90, 90, SERVO_MIN_DUTY, SERVO_MAX_DUTY)\n        print('angle:', angle, 'duty: ', duty)\n        pwm.duty_u16(duty)\n        old_angle = angle\n        time.sleep(.01)\n</code></pre>"},{"location":"kits/base/08-servo-lab/#shutting-down-all-servos","title":"Shutting Down All Servos","text":"<pre><code>from machine import Pin, PWM\nimport time\n\nSERVO_1_PIN = 12\nSERVO_2_PIN = 13\nSERVO_3_PIN = 14\nSERVO_4_PIN = 15\n\nprint('shutting down all servos!')\nfor i in range(12, 16):\n    print('Servo', i, 'shutting down')\n    pwm1 = PWM(Pin(SERVO_1_PIN))\n    pwm1.duty_u16(0)\n</code></pre>"},{"location":"kits/base/08-servo-lab/#adding-cleanup-code","title":"Adding Cleanup Code","text":"<p>PWM signals continue to be generated even after you do a STOP/RESET on your microcontroller.  This could drain batteries and wear out your servo motors.  To stop the servos from getting PWM signals you can add an interrupt to your code to catch these signals and set the PWM duty cycle back to zero. This</p>"},{"location":"kits/base/08-servo-lab/#references","title":"References","text":"<p>MicroPython Reference Page - this page is not very helpful.  The implication is that servo controls are standardized across MicroPython system.  This does not appear to be the case.</p>"},{"location":"kits/base/09-i2c-scanner-test/","title":"I2C Scanner Test","text":"<p>How do we know that our connection to the distance sensor is wired correctly?  The quick way to test this is to run a program called the I2C scanner.  It will return a list of all the devices it finds on the I2C bus.</p> <p>We first run the I2C scanner program to verify that the sensor is connected correct and is responding to the I2C bus scan.</p> <pre><code>import machine\n# Pins on the Grove Connector 1 on the Maker Pi RP2040 are GP0 and GP1\nsda=machine.Pin(0)\nscl=machine.Pin(1)\ni2c=machine.I2C(0, sda=sda, scl=scl, freq=400000)\nprint(\"I2C device ID list:\", i2c.scan())\n</code></pre> <p>This should return a list of the devices it finds.  If you just have the Time-of-Flight sensor it will look like this:</p> <pre><code>[41]\n``\n\n```py\ndevice_id = i2c.scan()[0]\n</code></pre>"},{"location":"kits/base/09-i2c-scanner-test/#testing-for-the-time-of-flight-sensor","title":"Testing for the Time-of-Flight Sensor","text":"<pre><code>import machine\nsda=machine.Pin(0)\nscl=machine.Pin(1)\ni2c=machine.I2C(0, sda=sda, scl=scl, freq=400000)\n\n# i2c.scan() returns a list of devices that have been found\n# i2c.scan()[0] is the first device found\ndevice_id = i2c.scan()[0]\nprint(\"Device found at decimal\", device_id)\n\nif device_id == 41:\n    print(\"TEST PASS\")\nelse:\n    print(\"No device found at decimal 41\")\n    print(\"TEST FAIL\")\n</code></pre>"},{"location":"kits/base/10-time-of-flight-lab/","title":"Time of Flight Distance Sensor Lab","text":"<p>In this lab we create a program that will show the distance measured by the Time-of-Flight sensor by printing the distance on the console and also displaying the distance on 11 blue LEDs.</p> <p>First, make sure you have your driver for the Time-of-Flight sensor installed.</p> <p>You can copy the code from here and save it in the file VL53L0X.py.  Note the zero between the \"L\" and \"X\" in the file name, not the letter \"O\".</p> <p>We use a non-linear distance scale as we get closer to an object.  We store the numbers of each LED and the distance it should change in a lists:</p> <pre><code>blue_led_pins = [2, 3, 4,  5,  6,  7,  16, 17, 26, 27, 28]\ndist_scale =    [2, 6, 10, 20, 30, 40, 50, 60, 80, 110, 150]\n</code></pre>"},{"location":"kits/base/10-time-of-flight-lab/#calibration","title":"Calibration","text":"<p>There are three numbers you can change when you calibrate the sensor:</p> <pre><code>ZERO_DIST = 60 # The value of the sensor when an object is 0 CM away\nMAX_DIST = 1200 # max raw distance we are able to read\nSCALE_DIST = .3 # multiplier for raw to calibrated distance in CM\n</code></pre>"},{"location":"kits/base/10-time-of-flight-lab/#full-program","title":"Full Program","text":"<pre><code># Demo for Maker Pi RP2040 board using the VL32L0X time of flight distance sensor\n# Note the driver I used came from here: https://github.com/CoderDojoTC/micropython/blob/main/src/drivers/VL53L0X.py\n# Perhaps derived from here: https://github.com/uceeatz/VL53L0X/blob/master/VL53L0X.py\n\n# This demo makes the blue LEDs show the distance and prints the distance on the console\nimport machine\nimport time\nimport VL53L0X\n\nsda=machine.Pin(0) # row one on our standard Pico breadboard\nscl=machine.Pin(1) # row two on our standard Pico breadboard\ni2c=machine.I2C(0, sda=sda, scl=scl, freq=400000)\n# print(\"Device found at decimal\", i2c.scan())\n\n# The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs which we can use 11\n# The distance scale is non linear\n# GP0 and GP1 will always be on since they are the I2C Data and Clock\nblue_led_pins = [2, 3, 4,  5,  6,  7,  16, 17, 26, 27, 28]\ndist_scale =    [2, 6, 10, 20, 30, 40, 50, 60, 80, 110, 150]\nnumber_leds = len(blue_led_pins)\nled_ports = []\ndelay = .05\n\n# initial calibration parameters\nZERO_DIST = 60\nMAX_DIST = 1200 # max raw distance we are able to read\nSCALE_DIST = .3 # multiplier for raw to calibrated distance\n\n# create a list of the ports\nfor i in range(number_leds):\n   led_ports.append(machine.Pin(blue_led_pins[i], machine.Pin.OUT))\n\n# Create a VL53L0X object\ntof = VL53L0X.VL53L0X(i2c)\n\n\n# get the normalized time-of-flight distance\ndef get_distance():\n    global zero_dist, scale_factor\n    tof_distance = tof.read()\n    if tof_distance &gt; MAX_DIST:\n        return tof_distance\n    # if our current time-of-flight distance is lower than our zero distance then reset the zero distance\n    if tof_distance &lt; ZERO_DIST:\n        zero_dist = tof_distance\n    return  int((tof_distance - ZERO_DIST) * SCALE_DIST)\n\n# use the dist_scale to turn on LEDs\ndef led_show_dist(in_distance):\n    global number_leds\n    for led_index in range(0, number_leds):\n        if in_distance &gt; dist_scale[led_index]:\n            led_ports[led_index].high()\n        else:\n            led_ports[led_index].low()\n\nprint('Using', number_leds, ' blue leds to show distance.')\n\n# blue up\nfor i in range(0, number_leds):\n    led_ports[i].high()\n    time.sleep(delay)\n    led_ports[i].low()\n# blue down\nfor i in range(number_leds - 1, 0, -1):\n    led_ports[i].high()\n    time.sleep(delay)\n    led_ports[i].low()\n\n# start our time-of-flight sensor\ntof.start()\n# autocalibrate the minimum distance\nmin_distance = 1000\n\n\n# loop forever\nwhile True:\n    raw_distance = get_distance()\n    # recalibrate if we have a new min distance\n    if raw_distance &lt; min_distance:\n        min_distance = raw_distance\n    calibrated_distance = raw_distance - min_distance\n    print(raw_distance, calibrated_distance)\n    led_show_dist(calibrated_distance)\n    time.sleep(0.05)\n\n# clean up\ntof.stop()\n</code></pre>"},{"location":"kits/base/10-time-of-flight-lab/#references","title":"References","text":"<p>Kevin McAleer's GitHub Repo on the Vl53lx0 Kevin McAleer's 662 line driver - I am not sure we need all 662 lines of code. Kevin McAleer's Time of Flight Test</p>"},{"location":"kits/base/11-ping-lab/","title":"Ultrasonic Ping Sensor Lab","text":"<p>The Grove sensors on our Maker Pi RP2040 only supply 3.3 volts.  So the standard very popular low cost HC-SR04 will not work, since it requires 5 volts of power.  We have two options.  One is to get a separate 5V power source, but the other is to purchase the new HC-SR04P (for Pico?) sensor that will work with our 3.3 volt power on our Grove connector.</p> <p>Using the Grove 4 connection wire the HC-SP04P sensor with the trigger on GPIO-16 (White cable) and the echo on GPIO-17 (Yellow cable),  VCC (Red cable), and GND (Black cable)</p> <p></p> <p>All wired up </p> <p></p> <pre><code># Sample code to test HC-SR04 Ultrasonice Ping Sensor\n# Connect GND to any GND pin on the Pico\n# Connnect VCC to VBUS or 5 Volt power\n\nfrom machine import Pin, Timer\nimport utime\n\nTRIGGER_PIN = 16 # With USB on the top, this pin is the bottom left corner\nECHO_PIN = 17 # One up from bottom left corner\n\n# Init HC-SR04 pins\ntrigger = Pin(TRIGGER_PIN, Pin.OUT) # send trigger out to sensor\necho = Pin(ECHO_PIN, Pin.IN) # get the delay interval back\n\ndef ping():\n    trigger.low()\n    utime.sleep_us(2) # Wait 2 microseconds low\n    trigger.high()\n    utime.sleep_us(5) # Stay high for 5 miroseconds\n    trigger.low()\n    while echo.value() == 0:\n        signaloff = utime.ticks_us()\n    while echo.value() == 1:\n        signalon = utime.ticks_us()\n    timepassed = signalon - signaloff\n    distance = (timepassed * 0.0343) / 2\n    return distance\n\nwhile True:\n    print(\"Distance:\", ping(), \"cm\")\n    utime.sleep(.25)\n</code></pre> <p>More advanced version with sound</p> <pre><code># Sample code to test HC-SR04 Ultrasonice Ping Sensor\n# Connect GND to any GND pin on the Pico\n# Connnect VCC to VBUS or 5 Volt power\n\nfrom machine import Pin, Timer, PWM\nimport utime\n\nTRIGGER_PIN = 16 # With USB on the top, this pin is the bottom left corner\nECHO_PIN = 17 # One up from bottom left corner\n\n# Init HC-SR04 pins\ntrigger = Pin(TRIGGER_PIN, Pin.OUT) # send trigger out to sensor\necho = Pin(ECHO_PIN, Pin.IN) # get the delay interval back\n\nBUZZER_PORT = 22\nbuzzer = PWM(Pin(BUZZER_PORT))\n\n#  Note the non-linear increases in frequency - note that some are louder\ntone_freq = [100, 150, 210, 280, 350, 450, 580, 750, 850, 950, 1000]\ndef playtone(frequency):\n    buzzer.duty_u16(1000)\n    buzzer.freq(frequency)\n\ndef bequiet():\n    buzzer.duty_u16(0)\n\ndef ping():\n    trigger.low()\n    utime.sleep_us(2) # Wait 2 microseconds low\n    trigger.high()\n    utime.sleep_us(5) # Stay high for 5 miroseconds\n    trigger.low()\n    while echo.value() == 0:\n        signaloff = utime.ticks_us()\n    while echo.value() == 1:\n        signalon = utime.ticks_us()\n    timepassed = signalon - signaloff\n    distance = (timepassed * 0.0343) / 2\n    return distance\n\nwhile True:\n    dist=round(ping())\n    print(\"Distance:\", dist, \"cm\")\n    if dist &lt; 20:\n        print(\"Panic\")\n        playtone(350)\n        # Beep faster the closer you get\n        utime.sleep(.05/(20/dist))\n        bequiet()\n    utime.sleep(.1)\n</code></pre>"},{"location":"kits/base/11-ping-lab/#link-to-sample-ping-lab","title":"Link to Sample Ping Lab","text":"<p>This code is very similar to the previous ping lab but with the different GPIO lines used. </p> <p>Link to Standard Ping Lab</p>"},{"location":"kits/base/12-time-of-flight-sound-lab/","title":"Time of Flight Distance Sensor Test","text":"<pre><code># Demo for Maker Pi RP2040 board\n\nfrom machine import Pin,PWM\nimport time\nimport VL53L0X\nbuzzer=PWM(Pin(22))\n\nsda=machine.Pin(0) # row one on our standard Pico breadboard\nscl=machine.Pin(1) # row two on our standard Pico breadboard\ni2c=machine.I2C(0, sda=sda, scl=scl, freq=400000)\n# print(\"Device found at decimal\", i2c.scan())\n\n# The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs\nblue_led_pins = [2, 3,  4,  5,  6,  7, 16, 17, 26, 27, 28]\n# dist_scale =    [2, 4, 6, 8, 10, 13, 16, 20, 25, 35, 50, 75, 100]\ndist_scale =    [2, 4, 6, 8, 10, 15, 20, 25, 50, 100, 150, 200, 300]\n\nnumber_leds = len(blue_led_pins)\nled_ports = []\ndelay = .05\n\n# calibration parameters\nzero_dist = 65 # distance measure when an object is about 1/2 cm away\nmax_dist = 350 # max distance we are able to read\nscale_factor = .2\n\n# create a list of the ports\nfor i in range(number_leds):\n   led_ports.append(machine.Pin(blue_led_pins[i], machine.Pin.OUT))\n\n# Create a VL53L0X object\ntof = VL53L0X.VL53L0X(i2c)\n\n# blue up\nfor i in range(0, number_leds):\n    led_ports[i].high()\n    time.sleep(delay)\n    led_ports[i].low()\n# blue down\nfor i in range(number_leds - 1, 0, -1):\n    led_ports[i].high()\n    time.sleep(delay)\n    led_ports[i].low()\n\n# get the normalized time-of-flight distance\ndef get_distance():\n    global zero_dist, scale_factor\n    tof_distance = tof.read()\n    if tof_distance &gt; max_dist:\n        return tof_distance\n    # if our current time-of-flight distance is lower than our zero distance then reset the zero distance\n    if tof_distance &lt; zero_dist:\n        zero_dist = tof_distance\n    return  int((tof_distance - zero_dist) * scale_factor)\n\ndef led_show_dist(in_distance):\n    global number_leds\n    for led_index in range(0, number_leds):\n        if in_distance &gt; dist_scale[led_index]:\n            led_ports[led_index].high()\n        else:\n            led_ports[led_index].low()\n\ndef playtone(frequency):\n    buzzer.duty_u16(1000)\n    buzzer.freq(frequency)\n\ndef bequiet():\n    buzzer.duty_u16(0)\n\ndef play_no_signal():\n    playtone(100)\n    time.sleep(0.1)\n    bequiet()\n\ndef play_turn():\n    playtone(500)\n    time.sleep(0.1)\n    bequiet()\n\n# start our time-of-flight sensor\ntof.start()\nvalid_distance = 1\n\n# loop forever\ndef main():\n    while True:\n        global valid_distance\n        distance = get_distance()\n        if distance &gt; 1000:\n            # only print if we used to have a valid distance\n            if valid_distance == 1:\n                print('no signal')\n\n            valid_distance = 0\n        else:\n            print(distance)\n            if distance &lt; 30:\n                play_turn()\n            valid_distance = 1\n            led_show_dist(distance)\n        time.sleep(0.05)\n\n# clean up\n\n\n# This allows us to stop the sound by doing a Stop or Control-C which is a keyboard intrrup\ntry:\n    main()\nexcept KeyboardInterrupt:\n    print('Got ctrl-c')\nfinally:\n    # Optional cleanup code\n    print('turning off sound')\n    buzzer.duty_u16(0)\n    tof.stop()\n</code></pre>"},{"location":"kits/base/20-collision-avoidance-robot/","title":"Maker Pi RP2040 Collision Avoidance Robot","text":"<p>This robot works very similar to our standard CoderDojo Collision Avoidance Robot but all the pins are now configured to use the connections on the Maker Pi RP2040 board.</p> <p>The board is mounted on a SmartCar Chassis and Grove Connector 0 is used to connect to a Time-of-Flight distance sensor that is using the I2C bus.</p>"},{"location":"kits/base/20-collision-avoidance-robot/#random-turn-direction","title":"Random Turn Direction","text":"<pre><code>if dist &lt; TURN_DIST:\n    play_reverse()\n    reverse()\n    sleep(REVERSE_TIME)\n    # half right and half left turns\n    if urandom.random() &lt; .5:\n        turn_right()\n        play_turn_right()\n    else:\n        turn_left()\n        play_turn_left()\n    sleep(TURN_TIME)\n    forward()\n</code></pre> <pre><code># Demo for Maker Pi RP2040 board\n\nfrom machine import Pin,PWM\nfrom time import sleep, sleep_ms\nimport urandom\nimport VL53L0X\n\n# Piezo Buzzer is on GP22\nbuzzer=PWM(Pin(22))\n\n# this is the max power level\nPOWER_LEVEL = 65025\n\n# Motor Pins are A: 8,9 and B: 10,11\nRIGHT_FORWARD_PIN = 8\nRIGHT_REVERSE_PIN = 9\nLEFT_FORWARD_PIN = 11\nLEFT_REVERSE_PIN = 10\n\n# our PWM objects\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN))\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN))\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN))\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN))\n\n\ndef turn_motor_on(pwm):\n   pwm.duty_u16(65025)\n\ndef turn_motor_off(pwm):\n   pwm.duty_u16(0)\n\ndef forward():\n    turn_motor_on(right_forward)\n    turn_motor_on(left_forward)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_reverse)\n\ndef reverse():\n    turn_motor_on(right_reverse)\n    turn_motor_on(left_reverse)\n    turn_motor_off(right_forward)\n    turn_motor_off(left_forward)\n\ndef turn_right():\n    turn_motor_on(right_forward)\n    turn_motor_on(left_reverse)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_forward)\n\ndef turn_left():\n    turn_motor_on(right_reverse)\n    turn_motor_on(left_forward)\n    turn_motor_off(right_forward)\n    turn_motor_off(left_reverse)\n\ndef stop():\n    turn_motor_off(right_forward)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_forward)\n    turn_motor_off(left_reverse)\n\n# Time of flight sensor is on the I2C bus on Grove connector 0\nsda=machine.Pin(0) # row one on our standard Pico breadboard\nscl=machine.Pin(1) # row two on our standard Pico breadboard\ni2c=machine.I2C(0, sda=sda, scl=scl, freq=400000)\n# print(\"Device found at decimal\", i2c.scan())\n\n# The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs\nblue_led_pins = [2, 3,  4,  5,  6,  7, 16, 17, 26, 27, 28]\n# dist_scale =    [2, 4, 6, 8, 10, 13, 16, 20, 25, 35, 50, 75, 100]\ndist_scale =    [2, 4, 6, 8, 10, 15, 20, 25, 50, 100, 150, 200, 300]\n\nnumber_leds = len(blue_led_pins)\nled_ports = []\ndelay = .05\n\n# calibration parameters\nzero_dist = 65 # distance measure when an object is about 1/2 cm away\nmax_dist = 350 # max distance we are able to read\nscale_factor = .2\n\n# create a list of the ports\nfor i in range(number_leds):\n   led_ports.append(machine.Pin(blue_led_pins[i], machine.Pin.OUT))\n\n# Create a VL53L0X object\ntof = VL53L0X.VL53L0X(i2c)\n\n# blue up\nfor i in range(0, number_leds):\n    led_ports[i].high()\n    time.sleep(delay)\n    led_ports[i].low()\n# blue down\nfor i in range(number_leds - 1, 0, -1):\n    led_ports[i].high()\n    time.sleep(delay)\n    led_ports[i].low()\n\n# get the normalized time-of-flight distance\ndef get_distance():\n    global zero_dist, scale_factor\n    tof_distance = tof.read()\n    if tof_distance &gt; max_dist:\n        return tof_distance\n    # if our current time-of-flight distance is lower than our zero distance then reset the zero distance\n    if tof_distance &lt; zero_dist:\n        zero_dist = tof_distance\n    return  int((tof_distance - zero_dist) * scale_factor)\n\ndef led_show_dist(in_distance):\n    global number_leds\n    for led_index in range(0, number_leds):\n        if in_distance &gt; dist_scale[led_index]:\n            led_ports[led_index].high()\n        else:\n            led_ports[led_index].low()\n\ndef playtone(frequency):\n    buzzer.duty_u16(1000)\n    buzzer.freq(frequency)\n\ndef bequiet():\n    buzzer.duty_u16(0)\n\ndef play_no_signal():\n    playtone(100)\n    time.sleep(0.1)\n    bequiet()\n\ndef play_turn():\n    playtone(500)\n    sleep(0.1)\n    bequiet()\n\n# start our time-of-flight sensor\ntof.start()\nvalid_distance = 1\n\n# loop forever\ndef main():\n    global valid_distance\n    while True:  \n        distance = get_distance()\n        if distance &gt; 1000:\n            # only print if we used to have a valid distance\n            if valid_distance == 1:\n                print('no signal')      \n            valid_distance = 0\n        else:\n            print(distance)\n            if distance &lt; 30:\n                play_turn()\n                # back up for 1/2 second\n                reverse()\n                sleep(0.5)\n                turn_right()\n                sleep(0.75)\n                forward()\n            else:\n                print('forward')\n                forward()\n            valid_distance = 1\n            led_show_dist(distance)\n        sleep(0.05)\n\n# clean up\n\n\n# This allows us to stop the sound by doing a Stop or Control-C which is a keyboard intrrup\ntry:\n    main()\nexcept KeyboardInterrupt:\n    print('Got ctrl-c')\nfinally:\n    # Optional cleanup code\n    print('turning off sound')\n    buzzer.duty_u16(0)\n    print('powering down all motors')\n    stop()\n    print('stopping time of flight sensor')\n    tof.stop()\n</code></pre>"},{"location":"kits/base/21-collision-avoidance-ping/","title":"Maker Pi RP2040 Collision Avoidance Robot With Ping Sensor","text":"<p>This robot works very similar to our standard CoderDojo Collision Avoidance Robot but all the pins are now configured to use the connections on the Maker Pi RP2040 board.</p> <p>The board is mounted on a SmartCar Chassis and Grove Connector 4 is used to connect the ultrasonic ping sensor.  Connect the Trigger on white and Echo on yellow.  The black should be connected to GND and the Red is connected to the VCC which on the </p> <p>The robot has an initial mode of 0, which will run the blue LEDs and change colors on the Neopixels.  By pressing the on-board button you will start the collision avoidance program.</p>"},{"location":"kits/base/21-collision-avoidance-ping/#robot-parameters","title":"Robot Parameters","text":"<p>There are four different robot parameters you can adjust.  They change the speed and distance before the robot backs up.  You can also adjust the time the robots goes into reverse and the time it turns.</p> <pre><code>POWER_LEVEL = 35000 # max is \nTURN_DISTANCE = 20 # distance in cm we decide to turn - try 20\nREVERSE_TIME = .4 # how long we backup\nTURN_TIME = .4 # how long we turn\n</code></pre>"},{"location":"kits/base/21-collision-avoidance-ping/#full-source-code","title":"Full Source Code","text":"<pre><code># Demo for Maker Pi RP2040 board using Ping sensor\nfrom machine import Pin, PWM, Timer\nimport utime\nimport urandom\nfrom neopixel import Neopixel\n\n# Adjust these parameters to tune the collision avoidance behavior\n\nPOWER_LEVEL = 35000\nTURN_DISTANCE = 20 # distance we decide to turn - try 20\nREVERSE_TIME = .4 # how long we backup\nTURN_TIME = .4 # how long we turn\n\n# startup mode is 0 - motors off and LEDs flashing\n# mode 1 is slow\n# mode 2 is medium\n# mode 3 is fast\nmode = 0\n\n# Use the Grove 4 Connector and put trigger on white and echo on yellow\nTRIGGER_PIN = 16 # With USB on the top, this pin is the bottom left corner\nECHO_PIN = 17 # One up from bottom left corner\n\n# Init HC-SR04P pins\ntrigger = Pin(TRIGGER_PIN, Pin.OUT) # send trigger out to sensor\necho = Pin(ECHO_PIN, Pin.IN) # get the delay interval back\n\nfaster_pin = machine.Pin(20, machine.Pin.IN, machine.Pin.PULL_DOWN)\nslower_pin = machine.Pin(21, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\nlast_time = 0 # the last time we pressed the button\n\n# This function gets called every time the button is pressed.  The parameter \"pin\" is not used.\ndef button_pressed_handler(pin):\n    global mode, last_time\n    new_time = utime.ticks_ms()\n    # if it has been more that 1/5 of a second since the last event, we have a new event\n    if (new_time - last_time) &gt; 200:\n        # this should be pin.id but it does not work\n        if '20' in str(pin):\n            mode +=1\n        else:\n            mode -=1\n        # deal with ends\n        if mode &gt; 4: mode = 2\n        if mode &lt; 0: mode = 0\n        last_time = new_time\n\n# now we register the handler function when the button is pressed\nfaster_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\nslower_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\n\n# Piezo Buzzer is on GP22\nbuzzer=PWM(Pin(22))\n\nMAX_POWER_LEVEL = 65025\n\nMAX_DISTANCE = 100 # ignore anything above this\n\n# Motor Pins are A: 8,9 and B: 10,11\nRIGHT_FORWARD_PIN = 11\nRIGHT_REVERSE_PIN = 10\nLEFT_FORWARD_PIN = 9\nLEFT_REVERSE_PIN = 8\n\n# our PWM objects\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN))\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN))\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN))\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN))\n\n# returns distance in cm\ndef ping():\n    print('in ping')\n    trigger.low()\n    utime.sleep_us(2) # Wait 2 microseconds low\n    trigger.high()\n    utime.sleep_us(5) # Stay high for 5 miroseconds\n    trigger.low()\n    while echo.value() == 0:\n        signaloff = utime.ticks_us()\n    print('echo is 1')\n    while echo.value() == 1:\n        signalon = utime.ticks_us()\n    timepassed = signalon - signaloff\n    distance = (timepassed * 0.0343) / 2\n    print(distance)\n    return int(distance)\n\ndef turn_motor_on(pwm):\n   pwm.duty_u16(65025)\n\ndef turn_motor_off(pwm):\n   pwm.duty_u16(0)\n\ndef forward():\n    turn_motor_on(right_forward)\n    turn_motor_on(left_forward)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_reverse)\n\ndef reverse():\n    turn_motor_on(right_reverse)\n    turn_motor_on(left_reverse)\n    turn_motor_off(right_forward)\n    turn_motor_off(left_forward)\n\ndef turn_right():\n    turn_motor_on(right_forward)\n    turn_motor_on(left_reverse)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_forward)\n\ndef turn_left():\n    turn_motor_on(right_reverse)\n    turn_motor_on(left_forward)\n    turn_motor_off(right_forward)\n    turn_motor_off(left_reverse)\n\ndef stop():\n    turn_motor_off(right_forward)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_forward)\n    turn_motor_off(left_reverse)\n\n# The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs\n# remove 16 and 17 since the are used for the ping sensor\nblue_led_pins = [0, 1, 2, 3,  4,  5,  6,  7, 26, 27, 28]\n# dist_scale =    [2, 4, 6, 8, 10, 13, 16, 20, 25, 35, 50, 75, 100]\ndist_scale =    [2, 4, 6, 8, 10, 15, 20, 25, 50, 100, 150, 200, 300]\n\nNUMBER_PIXELS = 2\nSTATE_MACHINE = 0\nNEOPIXEL_PIN = 18\n\n# The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB\nstrip = Neopixel(NUMBER_PIXELS, STATE_MACHINE, NEOPIXEL_PIN, \"GRB\")\nstrip.brightness(100)\n\nnumber_leds = len(blue_led_pins)\nled_ports = []\nred = (255, 0, 0)\norange = (255, 60, 0) # Gamma corrected from G=128 to be less like yellow\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130) # purple?\nviolet = (138, 43, 226) # mostly pink\ncyan = (0, 255, 255)\nlightgreen = (100, 255, 100)\nwhite = (128, 128, 128) # not too bright\npink = (255, 128, 128)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'cyan', 'lightgreen', 'white')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet, cyan, lightgreen, white, pink)\n\n# create a list of the ports\nfor i in range(number_leds):\n   led_ports.append(machine.Pin(blue_led_pins[i], machine.Pin.OUT))\n\nLED_DELAY = .08\ndef run_lights():\n    for i in range(0, number_leds):\n        led_ports[i].high()\n        strip.set_pixel(0, colors[i])\n        strip.set_pixel(1, colors[i])\n        strip.show()\n        utime.sleep(LED_DELAY)\n        led_ports[i].low()\n    # blue down\n    for i in range(number_leds - 1, 0, -1):\n        led_ports[i].high()\n        strip.set_pixel(0, colors[i])\n        strip.set_pixel(1, colors[i])\n        strip.show()\n        utime.sleep(LED_DELAY)\n        led_ports[i].low()\n\ndef led_show_dist(in_distance):\n    global number_leds\n    for led_index in range(0, number_leds):\n        if in_distance &gt; dist_scale[led_index]:\n            led_ports[led_index].high()\n        else:\n            led_ports[led_index].low()\n\ndef play_no_signal():\n    playnote(100, 0.1)\n    sound_off()\n\ndef play_turn():\n    playnote(500, .1)\n    sound_off()\n\ndef setfreq(frequency):\n    buzzer.freq(frequency)\n\ndef playnote(frequency, time):\n    buzzer.duty_u16(1000)\n    setfreq(frequency)\n    utime.sleep(time)\n\ndef sound_off():\n    buzzer.duty_u16(0)\n\ndef rest(time):\n    buzzer.duty_u16(0)\n    utime.sleep(time)\n\ndef play_startup():\n    playnote(600, .2)\n    rest(.05)\n    playnote(600, .2)\n    rest(.05)\n    playnote(600, .2)\n    rest(.1)\n    playnote(800, .4)\n    sound_off()\n\nvalid_distance = 1\n# loop forever\ndef main():\n    global valid_distance\n    print(\"running main()\")\n\n    play_startup()\n\n    while True:\n        if mode == 0:\n            stop()\n            run_lights()\n        else:\n            distance = ping()\n            print('Distance:', distance)\n            if distance &gt; MAX_DISTANCE:\n                # only print if we used to have a valid distance\n                if valid_distance == 1:\n                    print('no signal')      \n                valid_distance = 0\n            else:\n                print(distance)\n                if distance &lt; TURN_DISTANCE:\n                    play_turn()\n                    # back up for a bit\n                    reverse()\n                    utime.sleep(REVERSE_TIME)\n                    # half right and half left turns\n                    if urandom.random() &lt; .5:\n                        turn_right()\n                    else:\n                        turn_left()\n                    utime.sleep(TURN_TIME)\n                    forward()\n                else:\n                    print('forward')\n                    forward()\n                valid_distance = 1\n                led_show_dist(distance)\n            utime.sleep(0.05)\n\n# clean up\n\n# This allows us to stop the sound and motors when we do a Stop or Control-C which is a keyboard interrupt\ntry:\n    main()\nexcept KeyboardInterrupt:\n    print('Got ctrl-c')\nfinally:\n    # Optional cleanup code\n    print('turning off sound')\n    buzzer.duty_u16(0)\n    print('shutting motors down')\n    stop()\n</code></pre>"},{"location":"kits/base/21-collision-avoidance-ping/#experiments","title":"Experiments","text":"<ol> <li>Adjust the power level and the distance before turning.  See how these change the performance of the robot.</li> <li>Adjust the angle of the ping sensor by gently heating the plexiglass holder.  How does this change the robot behavior?</li> <li>Add additional modes that change the power and the turn distance.  You can have one mode for slow, one for medium and one for fast.</li> <li>Change the Neopixel colors to indicate the distance to an object.</li> <li>Change the pattern of the blue LEDs to indicate the distance to the object.</li> </ol>"},{"location":"kits/base/23-microswitch-bot/","title":"MicroSwitch Robot using the Cytron Maker Pi RP2040","text":"<p>This robot was inspired by my friend, Michael York.</p> <p>Microswitches can be purchased for under $1.  They can be mounted on the front of our robot.  When the robot hits a wall in front of it the switch will open (or close) and the robot controller can make the robot go in reverse or turn.</p> <p>In the example below, we attached a stiff wire to the lever of the microswitch.</p> <p></p> <p>In the example below, we connected three microswitches to the front of our robot.</p> <p></p> <p>If the left switch is activated, the robot should turn to the right.  If the right switch is activated, the robot should go to the left.</p> <p>This image shows how we used two of the Grove connectors to read in the values of the switches.</p> <p></p>"},{"location":"kits/base/23-microswitch-bot/#testing-switches","title":"Testing Switches","text":"<p>The following code can be used to test your switches.  A line on the console prints out which of the three switches are activated using the pin <code>value()</code> function.</p> <pre><code>from machine import Pin\nfrom time import sleep\n\n# GPIO is the internal built-in LED\nled0 = Pin(0, Pin.OUT)\nled1 = Pin(1, Pin.OUT)\nled2 = Pin(2, Pin.OUT)\n\n# input on the lower left of the Pico using a built-in pull-down resistor to keep the value from floating\nmiddle_switch = Pin(7, Pin.IN, Pin.PULL_DOWN) \nright_switch = Pin(28, Pin.IN, Pin.PULL_DOWN)\nleft_switch = Pin(27, Pin.IN, Pin.PULL_DOWN)\n\nwhile True:\n    if middle_switch.value(): # if the value changes\n        led0.on()\n        print('middle')\n    else: led0.off()\n\n    if right_switch.value(): # if the value changes\n        led1.on()\n        print('right')\n    else: led1.off()\n\n    if left_switch.value(): # if the value changes\n        led2.on()\n        print('left')\n    else: led2.off()\n    sleep(.1)\n</code></pre>"},{"location":"kits/base/23-microswitch-bot/#sample-collision-avoidance-robot-code","title":"Sample Collision Avoidance Robot Code","text":"<pre><code>from machine import Pin, PWM\nfrom time import sleep\n\n# GPIO is the internal built-in LED\nled0 = Pin(0, Pin.OUT)\nled1 = Pin(1, Pin.OUT)\nled2 = Pin(2, Pin.OUT)\n\n# input on the lower left of the Pico using a built-in pull-down resistor to keep the value from floating\nmiddle_switch = Pin(7, Pin.IN, Pin.PULL_DOWN) \nright_switch = Pin(28, Pin.IN, Pin.PULL_DOWN)\nleft_switch = Pin(27, Pin.IN, Pin.PULL_DOWN)\n\n# Go slow to avoid bending wires\nPOWER_LEVEL = 25000 # max is 65000\n\n# These values depend on motor wiring\nRIGHT_FORWARD_PIN = 10\nRIGHT_REVERSE_PIN = 11\nLEFT_FORWARD_PIN = 9\nLEFT_REVERSE_PIN = 8\n\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN))\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN))\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN))\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN))\n\ndef turn_motor_on(pwm):\n   pwm.duty_u16(POWER_LEVEL)\n\ndef turn_motor_off(pwm):\n   pwm.duty_u16(0)\n\ndef forward():\n    turn_motor_on(right_forward)\n    turn_motor_on(left_forward)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_reverse)\n\ndef reverse():\n    turn_motor_on(right_reverse)\n    turn_motor_on(left_reverse)\n    turn_motor_off(right_forward)\n    turn_motor_off(left_forward)\n\ndef turn_right():\n    turn_motor_on(right_forward)\n    turn_motor_on(left_reverse)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_forward)\n\ndef turn_left():\n    turn_motor_on(right_reverse)\n    turn_motor_on(left_forward)\n    turn_motor_off(right_forward)\n    turn_motor_off(left_reverse)\n\ndef stop():\n    turn_motor_off(right_forward)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_forward)\n    turn_motor_off(left_reverse)\n\ndef main():\n    while True:\n        if middle_switch.value(): # if the value changes\n            print('middle')\n            led0.on()\n            reverse()\n            sleep(1)\n            turn_right()\n            sleep(.75)\n            forward()\n        else:\n            led0.off()\n            forward()\n\n        if right_switch.value(): # if the value changes\n            print('right')\n            led1.on()\n            reverse()\n            sleep(.75)\n            turn_left()\n            sleep(.5)\n            forward()\n        else:\n            led1.off()\n            forward()\n\n        if left_switch.value(): # if the value changes\n            led2.on()\n            print('left')\n            reverse()\n            sleep(.75)\n            turn_right()\n            sleep(.5)\n            forward()\n        else:\n            led2.off()\n            forward()\n\nprint('middle', middle_switch.value())\nprint('left', left_switch.value())\nprint('right', right_switch.value())\n\ntry:\n    main()\nexcept KeyboardInterrupt:\n    print('Got ctrl-c')\nfinally:\n    # Optional cleanup code\n    print('turning off sound')\n    # sound_off()\n    print('turning off motors')\n    stop()\n</code></pre>"},{"location":"kits/base/24-ping-servo-meter/","title":"Cytron Maker Pi RP2040 Ping Servo Meter Bot","text":"<p>This robot works very similar to our standard CoderDojo Collision Avoidance Robot.  However it adds a 180 degree servo to show the distance to the object in front of it.  It also uses a OLED display to present instructions and display the distance to the object.</p> <p>This program was contributed by Joe Glenn for the Minneapolis Bakken Museum Droid December event in December 2021.</p> <p></p>"},{"location":"kits/base/24-ping-servo-meter/#test-servo","title":"Test Servo","text":"<p>This program tests the servo by sweeping the angle from 0 to 180 and back.</p> <pre><code># servo sweep test\n# Brown: GND\n# Orange/Red : VCC\n# Yellow: Signal\n#\n# Time for high level (Radio Shack Micro-servo @ 5V)\n# 0.5 ms :   0 degree\n# 1.0 ms :  45 degree\n# 1.5 ms :  90 degree\n# 2.0 ms : 135 degree\n# 2.5 ms : 180 degree\n\nfrom machine import Pin, PWM\nfrom time import sleep\n\nSERVO_PIN = 15\nservoPin = PWM(Pin(SERVO_PIN))\nservoPin.freq(50)\n\ndef servo(degrees):\n    if degrees &gt; 180: degrees=180\n    if degrees &lt; 0: degrees=0\n    maxDuty=8000 # duty*100\n    minDuty=2000 # duty*100\n    #maxDuty=2000 # test\n    #minDuty=8000 # test\n    newDuty=minDuty+(maxDuty-minDuty)*(degrees/180)\n    servoPin.duty_u16(int(newDuty))\n\nwhile True:\n\n  for degree in range(0,180,1):\n    servo(degree)\n    sleep(0.01)\n    print(\"increasing -- \"+str(degree))\n\n  for degree in range(180, 0, -1):\n    servo(degree)\n    sleep(0.01)\n    print(\"decreasing -- \"+str(degree))\n</code></pre>"},{"location":"kits/base/24-ping-servo-meter/#main-python-code","title":"Main Python Code","text":"<pre><code># Demo for Maker Pi RP2040 board using Ping sensor, servo and i2c display\n\nfrom machine import Pin, PWM, Timer\nimport utime\nimport urandom\nfrom ssd1306 import SSD1306_I2C\nfrom neopixel import Neopixel\nfrom machine import Pin, I2C\nfrom ssd1306 import SSD1306_I2C\nimport framebuf\nimport math\nimport utime\n#\n# Ping Sensor\n# Use the Grove 4 Connector and put trigger on white and echo on yellow\n#\nPING_TRIGGER_PIN = 7 # GP7\nPING_ECHO_PIN = 28 # GP28\n\n#\n# i2c OLED 128x32\n#\nOLED_SDA_PIN = 26 # GP26\nOLED_SCL_PIN = 27 # GP27\n\n#\n# Servo\n# GND: Brown\n# VCC: Orange/Red\n# GP15 Yellow: Signal\n#\n# Time for high level (Radio Shack Micro-servo @ 5V)\n# 0.5 ms :   0 degree\n# 1.0 ms :  45 degree\n# 1.5 ms :  90 degree\n# 2.0 ms : 135 degree\n# 2.5 ms : 180 degree\nSERVO_PIN = 15\n\n# IQR Pins\nFASTER_PIN = 20\nSLOWER_PIN = 21\n\n# built-in Buzzer\nBUZZER_PIN = 22\n\n# Adjust these parameters to tune the collision avoidance behavior\n\nPOWER_LEL = 35000\nTURN_DISTANCE = 20 # distance we decide to turn - try 20\nREVERSE_TIME = .4 # how long we backup\nTURN_TIME = .4 # how long we turn\n\n# startup mode is 0 - motors off and LEDs flashing\n# mode 1 is slow\n# mode 2 is medium\n# mode 3 is fast\nmode = 0\n\n# Init HC-SR04P pins\ntrigger = Pin(PING_TRIGGER_PIN, Pin.OUT) # send trigger out to sensor\necho = Pin(PING_ECHO_PIN, Pin.IN) # get the delay interval back\n\nfaster_pin = machine.Pin(FASTER_PIN, machine.Pin.IN, machine.Pin.PULL_DOWN)\nslower_pin = machine.Pin(SLOWER_PIN, machine.Pin.IN, machine.Pin.PULL_DOWN)\n\nlast_time = 0 # the last time we pressed the button\n\n#\n# DISPLAY STUFF\n#\n# Display Image &amp; text on I2C driven ssd1306 OLED display \n\n\nWIDTH  = 128 # oled display width\nHEIGHT = 32  # oled display height\n\n# Explicit Method\nsda=machine.Pin(OLED_SDA_PIN)\nscl=machine.Pin(OLED_SCL_PIN)\ni2c=machine.I2C(1,sda=sda, scl=scl, freq=40000) # 400k is too fast and has issues\nprint( 'i2c={:02X}'.format( i2c.scan()[0] ) )\n#print(help(i2c))\n#print(help(i2c.init))\n#print(help(i2c.scan))\n#print(help(i2c.start))\n#print(help(i2c.stop))\n#print(help(i2c.readinto))\n#print(help(i2c.write))\n#print(help(i2c.readfrom))\n#print(help(i2c.readfrom_into))\n#print(help(i2c.writeto))\n#print(help(i2c.writevto))\n#print(help(i2c.readfrom_mem))\n#print(help(i2c.readfrom_mem_into))\n#print(help(i2c.writeto_mem))\n#exit\n\noled = SSD1306_I2C(128, 32, i2c)\n\n# Raspberry Pi logo as 32x32 bytearray\nbuffer = bytearray(b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00|?\\x00\\x01\\x86@\\x80\\x01\\x01\\x80\\x80\\x01\\x11\\x88\\x80\\x01\\x05\\xa0\\x80\\x00\\x83\\xc1\\x00\\x00C\\xe3\\x00\\x00~\\xfc\\x00\\x00L'\\x00\\x00\\x9c\\x11\\x00\\x00\\xbf\\xfd\\x00\\x00\\xe1\\x87\\x00\\x01\\xc1\\x83\\x80\\x02A\\x82@\\x02A\\x82@\\x02\\xc1\\xc2@\\x02\\xf6&gt;\\xc0\\x01\\xfc=\\x80\\x01\\x18\\x18\\x80\\x01\\x88\\x10\\x80\\x00\\x8c!\\x00\\x00\\x87\\xf1\\x00\\x00\\x7f\\xf6\\x00\\x008\\x1c\\x00\\x00\\x0c \\x00\\x00\\x03\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\n\n# Load the raspberry pi logo into the framebuffer (the image is 32x32)\nfb = framebuf.FrameBuffer(buffer, 32, 32, framebuf.MONO_HLSB)\n\ndef blk():\n    oled.fill(0)\n    oled.show()\n\ndef horiz(l,t,r,c):  # left, right , top\n    n = r-l+1        # Horizontal line\n    for i in range(n):\n        oled.pixel(l + i, t, c)\n\ndef vert(l,t,b,c):   # left, top, bottom\n    n = b-t+1        # Vertical line\n    for i in range(n):\n        oled.pixel(l, t+i,c)\n\ndef box(l,t,r,b,c):  # left, top, right, bottom\n    horiz(l,t,r,c)   # Hollow rectangle\n    horiz(l,b,r,c)\n    vert(l,t,b,c)\n    vert(r,t,b,c)\n\ndef ring2(cx,cy,r,c):   # Centre (x,y), radius, colour\n    for angle in range(0, 90, 2):  # 0 to 90 degrees in 2s\n        y3=int(r*math.sin(math.radians(angle)))\n        x3=int(r*math.cos(math.radians(angle)))\n        oled.pixel(cx-x3,cy+y3,c)  # 4 quadrants\n        oled.pixel(cx-x3,cy-y3,c)\n        oled.pixel(cx+x3,cy+y3,c)\n        oled.pixel(cx+x3,cy-y3,c)\n\n#print(help(oled.text()))\n#print(help())\n#help('modules')\n#help(oled)\n#help(oled.text)\n#help(framebuf.FrameBuffer)\n#help(framebuf.FrameBuffer.help())\n\n# Clear the oled display in case it has junk on it.\noled.fill(0) # Black\n\n# Blit the image from the framebuffer to the oled display\noled.blit(fb, 96, 0)\n\n# Basic stuff\noled.text(\"Raspberry Pi\",5,5)\noled.text(\"RP2040\",5,15)\noled.text(\"press GP21\",5,25)\noled.pixel(10,60,1)\n\n#ring2(50,43,20,1)  # Empty circle             \n# Finally update the oled display so the image &amp; text is displayed\noled.show()\nutime.sleep(1)\n\n\n#\n# Back to the motor control stuff. (sorry... i'm soppy today)\n# \n# This function gets called every time the button is pressed.  The parameter \"pin\" is not used.\ndef button_pressed_handler(pin):\n    global mode, last_time\n    new_time = utime.ticks_ms()\n    # if it has been more that 1/5 of a second since the last event, we have a new event\n    if (new_time - last_time) &gt; 200:\n        # this should be pin.id but it does not work\n        if '21' in str(pin):\n            mode +=1\n        else:\n            mode -=1\n        # deal with ends\n        if mode &gt; 4: mode = 2\n        if mode &lt; 0: mode = 0\n        last_time = new_time\n\n# now we register the handler function when the button is pressed\nfaster_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\nslower_pin.irq(trigger=machine.Pin.IRQ_FALLING, handler = button_pressed_handler)\n\n# Piezo Buzzer is on GP22\nbuzzer=PWM(Pin(BUZZER_PIN))\n\nMAX_POWER_LEVEL = 65025\n\nMAX_DISTANCE = 100 # ignore anything above this\n\n# Motor Pins are A: 8,9 and B: 10,11\nRIGHT_FORWARD_PIN = 11 # this must be wired backword?\nRIGHT_REVERSE_PIN = 10 \nLEFT_FORWARD_PIN = 9\nLEFT_REVERSE_PIN = 8\n\n# our PWM objects\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN))\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN))\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN))\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN))\n\n# returns distance in cm\ndef ping():\n    #print('in ping')\n    trigger.low()\n    utime.sleep_us(2) # Wait 2 microseconds low\n    trigger.high()\n    utime.sleep_us(5) # Stay high for 5 miroseconds\n    trigger.low()\n    while echo.value() == 0:\n        signaloff = utime.ticks_us()\n    #print('echo is 1')\n    while echo.value() == 1:\n        signalon = utime.ticks_us()\n    timepassed = signalon - signaloff\n    distance = (timepassed * 0.0343) / 2\n    print(distance)\n\n    return int(distance)\n\ndef turn_motor_on(pwm):\n   #pwm.duty_u16(65025)\n   pwm.duty_u16(16000)\n\ndef turn_motor_off(pwm):\n   pwm.duty_u16(0)\n\ndef forward():\n    turn_motor_on(right_forward)\n    turn_motor_on(left_forward)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_reverse)\n\ndef reverse():\n    turn_motor_on(right_reverse)\n    turn_motor_on(left_reverse)\n    turn_motor_off(right_forward)\n    turn_motor_off(left_forward)\n\ndef turn_right():\n    turn_motor_on(right_forward)\n    turn_motor_on(left_reverse)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_forward)\n\ndef turn_left():\n    turn_motor_on(right_reverse)\n    turn_motor_on(left_forward)\n    turn_motor_off(right_forward)\n    turn_motor_off(left_reverse)\n\ndef stop():\n    turn_motor_off(right_forward)\n    turn_motor_off(right_reverse)\n    turn_motor_off(left_forward)\n    turn_motor_off(left_reverse)\n\n# The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs\nblue_led_pins = [0, 1, 2, 3, 4, 5, 6, 7, 26, 27, 28]\nblue_led_pins.remove(PING_TRIGGER_PIN)\nblue_led_pins.remove(PING_ECHO_PIN)\nblue_led_pins.remove(OLED_SDA_PIN)\nblue_led_pins.remove(OLED_SCL_PIN)\n\n\n# dist_scale =    [2, 4, 6, 8, 10, 13, 16, 20, 25, 35, 50, 75, 100]\ndist_scale =    [2, 4, 6, 8, 10, 15, 20, 25, 50, 100, 150, 200, 300]\n\nNUMBER_PIXELS = 2\nSTATE_MACHINE = 0\nNEOPIXEL_PIN = 18\n\n# The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB\nstrip = Neopixel(NUMBER_PIXELS, STATE_MACHINE, NEOPIXEL_PIN, \"GRB\")\nstrip.brightness(100)\n\nnumber_leds = len(blue_led_pins)\nled_ports = []\nred = (255, 0, 0)\norange = (255, 60, 0) # Gamma corrected from G=128 to be less like yellow\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130) # purple?\nviolet = (138, 43, 226) # mostly pink\ncyan = (0, 255, 255)\nlightgreen = (100, 255, 100)\nwhite = (128, 128, 128) # not too bright\npink = (255, 128, 128)\ncolor_names = ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'cyan', 'lightgreen', 'white')\nnum_colors = len(color_names)\ncolors = (red, orange, yellow, green, blue, indigo, violet, cyan, lightgreen, white, pink)\n\n# create a list of the ports\nfor i in range(number_leds):\n   led_ports.append(machine.Pin(blue_led_pins[i], machine.Pin.OUT))\n\nLED_DELAY = .08\ndef run_lights():\n    for i in range(0, number_leds):\n        led_ports[i].high()\n        strip.set_pixel(0, colors[i])\n        strip.set_pixel(1, colors[i])\n        strip.show()\n        utime.sleep(LED_DELAY)\n        led_ports[i].low()\n    # blue down\n    for i in range(number_leds - 1, 0, -1):\n        led_ports[i].high()\n        strip.set_pixel(0, colors[i])\n        strip.set_pixel(1, colors[i])\n        strip.show()\n        utime.sleep(LED_DELAY)\n        led_ports[i].low()\n\ndef led_show_dist(in_distance):\n    global number_leds\n    for led_index in range(0, number_leds):\n        if in_distance &gt; dist_scale[led_index]:\n            led_ports[led_index].high()\n        else:\n            led_ports[led_index].low()\n\ndef play_no_signal():\n    playnote(100, 0.1)\n    sound_off()\n\ndef play_turn():\n    playnote(500, .1)\n    sound_off()\n\ndef setfreq(frequency):\n    buzzer.freq(frequency)\n\ndef playnote(frequency, time):\n    buzzer.duty_u16(1000)\n    setfreq(frequency)\n    utime.sleep(time)\n\ndef sound_off():\n    buzzer.duty_u16(0)\n\ndef rest(time):\n    buzzer.duty_u16(0)\n    utime.sleep(time)\n\ndef play_startup():\n    playnote(600, .2)\n    rest(.05)\n    playnote(600, .2)\n    rest(.05)\n    playnote(600, .2)\n    rest(.1)\n    playnote(800, .4)\n    sound_off()\n\ndef servo(degrees):\n    if degrees &gt; 180: degrees=180\n    if degrees &lt; 0: degrees=0\n    maxDuty=8000 # duty*100\n    minDuty=2000 # duty*100\n    #maxDuty=2000 # test\n    #minDuty=8000 # test\n    newDuty=minDuty+(maxDuty-minDuty)*(degrees/180)\n    servoPin.duty_u16(int(newDuty))\n\nservoPin = PWM(Pin(SERVO_PIN))\nservoPin.freq(50)\n\nvalid_distance = 1\n\ndef main():\n    global valid_distance\n    print(\"running main()\")\n\n    play_startup()\n    oled_count=0 # repeat every\n    oled_count_max=0 # times through loop\n    servo_count=0 \n    servo_count_max=0 # when to update\n    servo_degrees = 0\n    servo(servo_degrees) # start in that pos\n\n    # loop forever\n    while True:\n        if mode == 0:\n            stop()\n            run_lights()\n        else:\n            distance = ping()\n            print('Distance:', distance)\n            oled_count += 1\n            if oled_count &gt; oled_count_max:\n                oled.fill(0) # Black\n                oled.text(\"Distance:\",5,5)\n                oled.text(\"{:f}\".format(distance),5,15)\n                oled.show()\n                oled_count = 0\n\n            servo_count += 1\n            if servo_count &gt; servo_count_max:\n                if distance &gt; MAX_DISTANCE:\n                    servo_degrees = 0\n                else:\n                    servo_degrees = 180-distance/MAX_DISTANCE*180\n                servo(servo_degrees)\n                servo_count = 0\n\n            if distance &gt; MAX_DISTANCE:\n                # only print if we used to have a valid distance\n                if valid_distance == 1:\n                    print('no signal')      \n                valid_distance = 0\n            else:\n                print(distance)\n                #note=distance*10\n                #playnote(note, .025)\n\n                if distance &lt; TURN_DISTANCE:\n                    play_turn()\n                    # back up for a bit\n                    reverse()\n                    utime.sleep(REVERSE_TIME)\n                    # half right and half left turns\n                    if urandom.random() &lt; .5:\n                        turn_right()\n                    else:\n                        turn_left()\n                    utime.sleep(TURN_TIME)\n                    forward()\n                else:\n                    print('forward')\n                    forward()\n                valid_distance = 1\n                led_show_dist(distance)\n            utime.sleep(0.05)\n\n# clean up\n\n# This allows us to stop the sound and motors when we do a Stop or Control-C which is a keyboard interrupt\ntry:\n    main()\nexcept KeyboardInterrupt:\n    print('Got ctrl-c')\nexcept Exception as e: print(e)\nfinally:\n    # Optional cleanup code\n    print('turning off sound')\n    buzzer.duty_u16(0)\n    print('shutting motors down')\n    stop()\n</code></pre>"},{"location":"kits/base/25-line-follower/","title":"Line Follower Robot","text":"<p>Line following robot projects is a favorite project for our students.  They teach the students the concept of feedback to keep a robot following a line on a track or on the floor.  They are not easy to get working and require careful calibration of the sensor sensitivity and carefully adjusting the right and left motor power to keep the robot on track.  Once the student gets the robot working it is a time for celebration!</p> <p>The total cost of the kit is about $20.</p>"},{"location":"kits/base/25-line-follower/#parts-list","title":"Parts List","text":"Part Name Description Price Link Cytron Board Main board with RP2040 and motor driver. Kits come with Grove connectors and a screwdriver. $12 SmartCar Chassis SmartCar chassis with wheels and 4 AA battery pack IR Sensors (2) Low cost IR light sensors $1"},{"location":"kits/base/25-line-follower/#ir-sensors","title":"IR Sensors","text":"<p>We can purchase IR sensors on eBay for about $1 each in quantity 10. The sensors send a digital 0/1 signal to the microcontroller depending on if they are over the line. Our job is to write some MicroPython code to keep the robot following the line. Each IR sensor has a small trim potentiometer that we must adjust for the correct sensitivity for each room. </p> <p></p> <p>Each IR sensor has a small trim potentiometer that we must adjust for the correct sensitivity for each room.  Some of our rooms have a white floor with a black line and some of our rooms have a dark floor with a white line.  You may have to adjust both the trim potentiometer and the logic of the code for different situations.</p> <p>Use the Grove connectors to hook up the IR sensors.  I used the red (VCC), black (GDN) and white wires (Data) and I just cut off the yellow wires to keep them out of the way.  I then connected the Grove connectors to ports 2 and 3 of the Cytron board.</p> <p>I connected the motors to the MOTOR 1 and MOTOR 2 headers with a screwdriver and I hooked the battery wires up to the power header of the board.</p> <pre><code>from machine import Pin\nfrom utime import sleep\n\nRIGHT_SENSOR_PIN = 2\nLEFT_SENSOR_PIN = 4\n\nright_sensor = Pin(RIGHT_SENSOR_PIN)\nleft_sensor = Pin(LEFT_SENSOR_PIN)\n\nwhile True:\n    r = right_sensor.value()\n    l = left_sensor.value()\n    print(\"r\", r, \"l=\", l)\n    if r == 0:\n        print(\"right over white\")\n    if l == 0:\n        print(\"left over white\")\n    sleep(.2)\n</code></pre>"},{"location":"kits/base/25-line-follower/#full-source-code","title":"Full Source Code","text":"<pre><code>from machine import Pin, PWM\nfrom time import sleep\n\n# sensor setup\nRIGHT_SENSOR_PIN = 2\nLEFT_SENSOR_PIN = 4\n\nright_sensor = Pin(RIGHT_SENSOR_PIN)\nleft_sensor = Pin(LEFT_SENSOR_PIN)\n\n# speaker pin on the Cytron Maker Pi RP2040\nSPEAKER_PIN = 22\n# create a Pulse Width Modulation Object on this pin\nspeaker = PWM(Pin(SPEAKER_PIN))\n# set the duty cycle\nspeaker.duty_u16(1000)\n\n# Motor setup\nRIGHT_FORWARD_PIN = 11\nRIGHT_REVERSE_PIN =10\nLEFT_FORWARD_PIN = 8\nLEFT_REVERSE_PIN = 9\n\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN))\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN))\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN))\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN))\n\nMAX_POWER_LEVEL = 65025\nQUARTER_POWER = 65025 &gt;&gt; 2\nSLOW_DRIVE_POWER = 16000\nBOOST_LEVEL = 15000\n\n# while True:\ndef spin_wheel(pwm):\n    pwm.duty_u16(SLOW_DRIVE_POWER)\n    sleep(2)\n    pwm.duty_u16(0)\n    sleep(1)\n\ndef forward():\n    right_forward.duty_u16(SLOW_DRIVE_POWER)\n    right_reverse.duty_u16(0)\n    left_forward.duty_u16(SLOW_DRIVE_POWER)\n    left_reverse.duty_u16(0)\n    speaker.duty_u16(0)\n\ndef right():\n    right_forward.duty_u16(SLOW_DRIVE_POWER - BOOST_LEVEL)\n    right_reverse.duty_u16(0)\n    left_forward.duty_u16(SLOW_DRIVE_POWER + BOOST_LEVEL)\n    left_reverse.duty_u16(0)\n    speaker.duty_u16(1000)\n    speaker.freq(800)\n\ndef left():\n    right_forward.duty_u16(SLOW_DRIVE_POWER + BOOST_LEVEL)\n    right_reverse.duty_u16(0)\n    left_forward.duty_u16(SLOW_DRIVE_POWER - BOOST_LEVEL)\n    left_reverse.duty_u16(0)\n    speaker.duty_u16(1000)\n    speaker.freq(1000)\n\ndef stop():\n    right_forward.duty_u16(0)\n    right_reverse.duty_u16(0)\n    left_forward.duty_u16(0)\n    left_reverse.duty_u16(0)\n    speaker.duty_u16(0)\n\ndef main():\n    while True:\n        r = right_sensor.value()\n        l = left_sensor.value()\n        if r == 0 and l == 1:\n            print(\"right over white - turning left\")\n            right()\n        if l == 0:\n            print(\"left over white\")\n            left()\n        else:\n            forward()\n\n# end of main()\n\ntry:\n    main()\nexcept KeyboardInterrupt:\n    print('Got ctrl-c')\nfinally:\n    # Cleanup code\n    print('Cleaning up')\n    print('Powering down all motors now.')\n    stop()\n</code></pre>"},{"location":"kits/bump-switch/","title":"Bump Switch Robot","text":"<p>https://dmccreary.github.io/micropython/micropython/kits/maker-pi-rp2040-robot/23-microswitch-bot/</p>"},{"location":"kits/line-follower/","title":"Line Follower Robot","text":"<ul> <li>Line Follower Robot on the MicroPython for Kids Site</li> </ul>"},{"location":"kits/ultrasonic/","title":"Ultrasonic Robot","text":"<p>Ultrasonic Robot on the MicroPython for Kids Site</p>"},{"location":"kits/wifi-bot/","title":"Wireless STEM Robot","text":"<p>This robot uses the Cytron Robo Pico board that allows us to use a Raspberry Pi Pico W board as our microcontroller.  The \"W\" has builtin WiFi and Bluetooth hardware so we can control our robot wirelessly.</p>"},{"location":"kits/wifi-bot/#cytron-robo-pico-pinout","title":"Cytron Robo Pico Pinout","text":"<p>Note that the GPIO breakout female header allows us to connect our display cable directly to the board without using Grove connectors!</p>"},{"location":"kits/wifi-bot/#source-code","title":"Source Code","text":"<p>We can use the base robot source code as a starting point for our wireless robot.</p>"},{"location":"kits/wifi-bot/#micropython-wireless-functions","title":"MicroPython Wireless Functions","text":"<p>When you stop/restart Thonny you MUST make sure you have loaded the Pico \"W\" version of software.</p> <pre><code>MicroPython v1.25.0 on 2025-04-15; Raspberry Pi Pico W with RP2040\n</code></pre> <p>Raspbeery Pi Pico MicroPython Wireless Functions</p>"},{"location":"kits/wifi-bot/#secrets-file","title":"Secrets File","text":"<p>Our WiFi connection stores the local wireless network name and password in a file called <code>secrets.py</code>.  It has the following format:</p> <pre><code>SSID = \"MY_WIFI_NETWORK_NAME\"\nPASSWORD = \"MY_WIFI_PASSWORD\"\n</code></pre> <p>Note that you should take steps to make sure the <code>secrets.py</code> file is not checked into public GitHub repositories. The best way to do this is to add the following line to your .gitignore file:</p> <pre><code>secrets.py\n</code></pre> <p>This will work even though the file is at any level of the GitHub repository.</p>"},{"location":"kits/wifi-bot/#testing-your-secrets-file","title":"Testing Your Secrets File","text":"<p>Once you have your <code>secrets.py</code> file configured you can test it with a simple \"ping test\" program</p> <pre><code>import network\nimport secrets\nfrom utime import sleep\n\nprint('Connecting to WiFi Network Name:', secrets.SSID)\nwlan = network.WLAN(network.STA_IF)\nwlan.active(True) # power up the WiFi chip\nprint('Waiting for wifi chip to power up...')\nsleep(3) # wait three seconds for the chip to power up and initialize\n\nwlan.connect(secrets.SSID, secrets.PASSWORD)\nprint('Waiting for access point to log us in.')\nsleep(2)\n\nif wlan.isconnected():\n  print('Success! We have connected to your access point!')\n  print('Try to ping the device at', wlan.ifconfig()[0])\nelse:\n  print('Failure! We have not connected to your access point!  Check your secrets.py file for errors.')\n</code></pre> <p>Here is the Thonny console log when that prgram is running.</p> <pre><code>Connecting to WiFi Network Name: anndan\nWaiting for wifi chip to power up...\nWaiting for access point to log us in.\nSuccess! We have connected to your access point!\nTry to ping the device at 10.0.0.57\n</code></pre> <p>To test this you must open your Terminal application (or PowerSheel on Windows) and run the ping commend:</p> <pre><code>ping 10.0.0.57\n</code></pre> <p>Sample result:</p> <pre><code>PING 10.0.0.57 (10.0.0.57): 56 data bytes\nRequest timeout for icmp_seq 0\nRequest timeout for icmp_seq 1\nRequest timeout for icmp_seq 2\n64 bytes from 10.0.0.57: icmp_seq=1 ttl=255 time=2741.073 ms\n64 bytes from 10.0.0.57: icmp_seq=2 ttl=255 time=1740.994 ms\n64 bytes from 10.0.0.57: icmp_seq=3 ttl=255 time=740.691 ms\n</code></pre> <p>Note that your IP address might be different.  In this mode, ping will usually have three timeouts and then repond in about three seconds.  The is slow because the Raspberry Pi Pico is in a power saving mode by default.  It takes time to load the networking code into the WiFi chip.  We will fix this in the next labs.</p>"},{"location":"kits/wifi-bot/#ping-test-slow","title":"Ping Test Slow","text":"<p>In this lab we </p> <p>Ping Test Slow Lab</p>"},{"location":"kits/wifi-bot/#ping-test-slow_1","title":"Ping Test Slow","text":"<p>Ping Test Fast Lab</p>"},{"location":"kits/wifi-bot/#simple-web-server","title":"Simple Web Server","text":"<p>Simple Web Server Lab</p>"},{"location":"kits/wifi-bot/02-ping-test-slow/","title":"Ping Test","text":"<p>Here is a more detailed ping test program that will give use feedback.</p>"},{"location":"kits/wifi-bot/02-ping-test-slow/#source-code","title":"Source Code","text":"<pre><code>import network\nimport secrets\nimport time\nfrom machine import Pin\n\n# Optional: Use onboard LED for status indication\nled = Pin(\"LED\", Pin.OUT)\n\ndef blink_led(times=1, delay=0.2):\n    \"\"\"Blink the onboard LED for status indication\"\"\"\n    for _ in range(times):\n        led.on()\n        time.sleep(delay)\n        led.off()\n        time.sleep(delay)\n\ndef connect_wifi(max_retries=10):\n    \"\"\"Connect to WiFi with retry logic\"\"\"\n    print(f'Connecting to WiFi Network: {secrets.SSID}')\n\n    wlan = network.WLAN(network.STA_IF)\n    wlan.active(True)\n\n    print('Powering up WiFi chip...')\n    time.sleep(3)\n\n    retry_count = 0\n    while retry_count &lt; max_retries:\n        try:\n            print(f'Connection attempt {retry_count + 1}/{max_retries}')\n            wlan.connect(secrets.SSID, secrets.PASSWORD)\n\n            # Wait for connection with timeout\n            timeout = 15  # seconds\n            start_time = time.time()\n\n            while not wlan.isconnected() and (time.time() - start_time) &lt; timeout:\n                time.sleep(1)\n                print('.', end='')\n\n            print()  # New line after dots\n\n            if wlan.isconnected():\n                return wlan\n            else:\n                print(f'Timeout on attempt {retry_count + 1}')\n                retry_count += 1\n                time.sleep(2)\n\n        except Exception as e:\n            print(f'Error on attempt {retry_count + 1}: {e}')\n            retry_count += 1\n            time.sleep(2)\n\n    return None\n\ndef display_network_info(wlan):\n    \"\"\"Display detailed network information\"\"\"\n    config = wlan.ifconfig()\n    status = wlan.status()\n\n    print('\\n' + '='*50)\n    print('NETWORK CONNECTION SUCCESSFUL!')\n    print('='*50)\n    print(f'IP Address:     {config[0]}')\n    print(f'Subnet Mask:    {config[1]}')\n    print(f'Gateway:        {config[2]}')\n    print(f'DNS Server:     {config[3]}')\n    print(f'WiFi Status:    {status}')\n    print(f'Network SSID:   {secrets.SSID}')\n    print('='*50)\n    print(f'\\nTo test connectivity, run this command on your computer:')\n    print(f'ping {config[0]}')\n    print('\\nPress Ctrl+C to stop the program')\n    print('='*50)\n\ndef keep_alive_loop(wlan):\n    \"\"\"Keep the device alive and monitor connection\"\"\"\n    last_status_time = time.time()\n    status_interval = 30  # Print status every 30 seconds\n\n    try:\n        while True:\n            current_time = time.time()\n\n            # Check if still connected\n            if wlan.isconnected():\n                # Blink LED to show device is alive\n                blink_led(1, 0.1)\n\n                # Print periodic status\n                if current_time - last_status_time &gt;= status_interval:\n                    print(f'[{time.ticks_ms()}ms] Device alive - IP: {wlan.ifconfig()[0]}')\n                    last_status_time = current_time\n\n            else:\n                print('WiFi connection lost! Attempting to reconnect...')\n                blink_led(3, 0.2)  # Fast blinks for error\n                wlan = connect_wifi()\n                if wlan:\n                    display_network_info(wlan)\n                else:\n                    print('Failed to reconnect. Restarting in 10 seconds...')\n                    time.sleep(10)\n                    continue\n\n            time.sleep(1)  # Short delay to prevent excessive CPU usage\n\n    except KeyboardInterrupt:\n        print('\\nProgram stopped by user')\n        led.off()\n    except Exception as e:\n        print(f'Unexpected error: {e}')\n        blink_led(5, 0.1)  # Error indication\n\ndef main():\n    \"\"\"Main program function\"\"\"\n    print('Raspberry Pi Pico W - Enhanced Ping Test')\n    print('========================================')\n\n    # Initial LED indication\n    blink_led(2, 0.5)\n\n    # Connect to WiFi\n    wlan = connect_wifi()\n\n    if wlan:\n        display_network_info(wlan)\n        blink_led(3, 0.2)  # Success indication\n        keep_alive_loop(wlan)\n    else:\n        print('\\nFAILED TO CONNECT!')\n        print('Check your secrets.py file for correct SSID and PASSWORD')\n        print('Ensure your WiFi network is available and credentials are correct')\n        blink_led(10, 0.1)  # Error indication\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"kits/wifi-bot/02-ping-test-slow/#thonny-console","title":"Thonny Console","text":"<pre><code>To test connectivity, run this command on your computer:\nping 10.0.0.57\n\nPress Ctrl+C to stop the program\n==================================================\n[905892ms] Device alive - IP: 10.0.0.57\n[935923ms] Device alive - IP: 10.0.0.57\n[965953ms] Device alive - IP: 10.0.0.57\n[995982ms] Device alive - IP: 10.0.0.57\n</code></pre>"},{"location":"kits/wifi-bot/02-ping-test-slow/#unix-ping","title":"UNIX Ping","text":"<pre><code>$ ping 10.0.0.57\nPING 10.0.0.57 (10.0.0.57): 56 data bytes\nRequest timeout for icmp_seq 0\nRequest timeout for icmp_seq 1\nRequest timeout for icmp_seq 2\n64 bytes from 10.0.0.57: icmp_seq=1 ttl=255 time=2741.073 ms\n64 bytes from 10.0.0.57: icmp_seq=2 ttl=255 time=1740.994 ms\n64 bytes from 10.0.0.57: icmp_seq=3 ttl=255 time=740.691 ms\nRequest timeout for icmp_seq 6\n64 bytes from 10.0.0.57: icmp_seq=4 ttl=255 time=3689.621 ms\n64 bytes from 10.0.0.57: icmp_seq=5 ttl=255 time=2688.303 ms\n64 bytes from 10.0.0.57: icmp_seq=6 ttl=255 time=1685.861 ms\n64 bytes from 10.0.0.57: icmp_seq=7 ttl=255 time=683.353 ms\n64 bytes from 10.0.0.57: icmp_seq=8 ttl=255 time=3668.818 ms\n64 bytes from 10.0.0.57: icmp_seq=9 ttl=255 time=2670.315 ms\n64 bytes from 10.0.0.57: icmp_seq=10 ttl=255 time=1670.126 ms\n64 bytes from 10.0.0.57: icmp_seq=11 ttl=255 time=668.585 ms\n64 bytes from 10.0.0.57: icmp_seq=12 ttl=255 time=3698.265 ms\n64 bytes from 10.0.0.57: icmp_seq=13 ttl=255 time=2697.344 ms\n64 bytes from 10.0.0.57: icmp_seq=14 ttl=255 time=1696.499 ms\n64 bytes from 10.0.0.57: icmp_seq=15 ttl=255 time=693.715 ms\n64 bytes from 10.0.0.57: icmp_seq=16 ttl=255 time=3641.492 ms\n64 bytes from 10.0.0.57: icmp_seq=17 ttl=255 time=2640.483 ms\n64 bytes from 10.0.0.57: icmp_seq=18 ttl=255 time=1637.462 ms\n64 bytes from 10.0.0.57: icmp_seq=19 ttl=255 time=636.293 ms\n^C\n--- 10.0.0.57 ping statistics ---\n24 packets transmitted, 19 packets received, 20.8% packet loss\nround-trip min/avg/max/stddev = 636.293/2104.700/3698.265/1089.064 ms\n</code></pre> <p>No, this is not ideal since the average respons time is 3600 millisecond (3.6) seconds. However, it's common for microcontrollers like the Pico W which by default goes into \"deep sleep\" between pings.</p> <p>What you're seeing indicates the device is entering power-saving modes between network activity. Here's what's happening:</p> <p>What Those Results Mean</p> <ol> <li>Initial Timeouts: The Pico W was likely in a deep sleep or power-saving mode and took time to \"wake up\" to network requests.</li> <li>High Initial Latency: The extremely high response times (3+ seconds) show the WiFi chip and network stack were initializing/waking up.</li> </ol> <p>In our next lab we will Disable WiFi Power Management to get under 20 millisecond response times.</p>"},{"location":"kits/wifi-bot/03-ping-test-fast/","title":"Ping Test 2","text":"<p>Although having your device responed in three seconds may not be a problem for some applications, for real-time control of a robot the delay is too long.  To get a faster response, we need to add a single line of code that will remove the low-power option:</p> <pre><code># Disable power management for better ping responsiveness\nwlan.config(pm=0xa11140)  # Disable WiFi power management\n</code></pre> <p>By default the wireless chip will active power-saving mode when it is idle, which might lead it to being less responsive. If you are running a server or need more responsiveness, you can change this by toggling the power mode.</p> <p>This is usually done immediatly after you make the WiFi chip active:</p> <pre><code>import network\n\nwlan = network.WLAN(network.STA_IF)\nwlan.active(True)\nwlan.config(pm = 0xa11140)\n</code></pre>"},{"location":"kits/wifi-bot/03-ping-test-fast/#full-source-code-for-fast-ping","title":"Full Source Code for Fast Ping","text":"<pre><code>import network\nimport secrets\nimport time\nfrom machine import Pin\n\n# Optional: Use onboard LED for status indication\nled = Pin(\"LED\", Pin.OUT)\n\ndef blink_led(times=1, delay=0.2):\n    \"\"\"Blink the onboard LED for status indication\"\"\"\n    for _ in range(times):\n        led.on()\n        time.sleep(delay)\n        led.off()\n        time.sleep(delay)\n\ndef connect_wifi(max_retries=10):\n    \"\"\"Connect to WiFi with retry logic\"\"\"\n    print(f'Connecting to WiFi Network: {secrets.SSID}')\n\n    wlan = network.WLAN(network.STA_IF)\n    wlan.active(True)\n\n    # Disable power management for better ping responsiveness\n    wlan.config(pm=0xa11140)  # Disable WiFi power management\n\n    print('Powering up WiFi chip...')\n    time.sleep(3)\n\n    retry_count = 0\n    while retry_count &lt; max_retries:\n        try:\n            print(f'Connection attempt {retry_count + 1}/{max_retries}')\n            wlan.connect(secrets.SSID, secrets.PASSWORD)\n\n            # Wait for connection with timeout\n            timeout = 15  # seconds\n            start_time = time.time()\n\n            while not wlan.isconnected() and (time.time() - start_time) &lt; timeout:\n                time.sleep(1)\n                print('.', end='')\n\n            print()  # New line after dots\n\n            if wlan.isconnected():\n                return wlan\n            else:\n                print(f'Timeout on attempt {retry_count + 1}')\n                retry_count += 1\n                time.sleep(2)\n\n        except Exception as e:\n            print(f'Error on attempt {retry_count + 1}: {e}')\n            retry_count += 1\n            time.sleep(2)\n\n    return None\n\ndef display_network_info(wlan):\n    \"\"\"Display detailed network information\"\"\"\n    config = wlan.ifconfig()\n    status = wlan.status()\n\n    print('\\n' + '='*50)\n    print('NETWORK CONNECTION SUCCESSFUL!')\n    print('='*50)\n    print(f'IP Address:     {config[0]}')\n    print(f'Subnet Mask:    {config[1]}')\n    print(f'Gateway:        {config[2]}')\n    print(f'DNS Server:     {config[3]}')\n    print(f'WiFi Status:    {status}')\n    print(f'Network SSID:   {secrets.SSID}')\n    print(f'Power Mgmt:     DISABLED (for better ping response)')\n    print('='*50)\n    print(f'\\nTo test connectivity, run this command on your computer:')\n    print(f'ping {config[0]}')\n    print('\\nExpected ping response: &lt;50ms (much improved!)')\n    print('Press Ctrl+C to stop the program')\n    print('='*50)\n\ndef keep_alive_loop(wlan):\n    \"\"\"Keep the device alive and monitor connection with active networking\"\"\"\n    last_status_time = time.time()\n    status_interval = 10  # Print status every 10 seconds\n    ping_counter = 0\n\n    try:\n        while True:\n            current_time = time.time()\n\n            # Check if still connected\n            if wlan.isconnected():\n                # Blink LED to show device is alive\n                blink_led(1, 0.05)\n\n                # Print periodic status with ping counter\n                if current_time - last_status_time &gt;= status_interval:\n                    ping_counter += 1\n                    print(f'[Alive #{ping_counter}] IP: {wlan.ifconfig()[0]} - Ready for ping')\n                    last_status_time = current_time\n\n            else:\n                print('WiFi connection lost! Attempting to reconnect...')\n                blink_led(3, 0.2)  # Fast blinks for error\n                wlan = connect_wifi()\n                if wlan:\n                    display_network_info(wlan)\n                else:\n                    print('Failed to reconnect. Restarting in 10 seconds...')\n                    time.sleep(10)\n                    continue\n\n            time.sleep(0.1)  # Very short delay to keep system responsive\n\n    except KeyboardInterrupt:\n        print('\\nProgram stopped by user')\n        led.off()\n    except Exception as e:\n        print(f'Unexpected error: {e}')\n        blink_led(5, 0.1)  # Error indication\n\ndef main():\n    \"\"\"Main program function\"\"\"\n    print('Raspberry Pi Pico W - Enhanced Ping Test')\n    print('========================================')\n\n    # Initial LED indication\n    blink_led(2, 0.5)\n\n    # Connect to WiFi\n    wlan = connect_wifi()\n\n    if wlan:\n        display_network_info(wlan)\n        blink_led(3, 0.2)  # Success indication\n        keep_alive_loop(wlan)\n    else:\n        print('\\nFAILED TO CONNECT!')\n        print('Check your secrets.py file for correct SSID and PASSWORD')\n        print('Ensure your WiFi network is available and credentials are correct')\n        blink_led(10, 0.1)  # Error indication\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"kits/wifi-bot/03-ping-test-fast/#sample-thonny-console","title":"Sample Thonny Console","text":"<pre><code>==================================================\nIP Address:     10.0.0.57\nSubnet Mask:    255.255.255.0\nGateway:        10.0.0.1\nDNS Server:     75.75.75.75\nWiFi Status:    3\nNetwork SSID:   YOUR_SSID\nPower Mgmt:     DISABLED (for better ping response)\n==================================================\n</code></pre>"},{"location":"kits/wifi-bot/03-ping-test-fast/#sample-ping-response","title":"Sample Ping Response","text":"<pre><code>$ ping 10.0.0.57\nPING 10.0.0.57 (10.0.0.57): 56 data bytes\nRequest timeout for icmp_seq 0\n64 bytes from 10.0.0.57: icmp_seq=1 ttl=255 time=16.394 ms\n64 bytes from 10.0.0.57: icmp_seq=2 ttl=255 time=14.642 ms\n64 bytes from 10.0.0.57: icmp_seq=3 ttl=255 time=14.630 ms\n64 bytes from 10.0.0.57: icmp_seq=4 ttl=255 time=7.264 ms\n64 bytes from 10.0.0.57: icmp_seq=5 ttl=255 time=19.538 ms\n64 bytes from 10.0.0.57: icmp_seq=6 ttl=255 time=17.745 ms\n^C\n--- 10.0.0.57 ping statistics ---\n7 packets transmitted, 6 packets received, 14.3% packet loss\nround-trip min/avg/max/stddev = 7.264/15.036/19.538/3.877 ms\n</code></pre> <p>Note that the average is now about 19 milliseconds!</p>"},{"location":"kits/wifi-bot/03-ping-test-fast/#what-we-achieved","title":"What We Achieved","text":"<p>Before: 3+ second delays, multiple timeouts, inconsistent performance After: Consistent 7-19ms response times with just one initial timeout</p>"},{"location":"kits/wifi-bot/03-ping-test-fast/#the-results-breakdown","title":"The Results Breakdown","text":"<p>Single Initial Timeout: This is normal - the very first ping packet sometimes gets lost while the network stack finishes initializing. This is much better than the multiple timeouts you had before.</p> <p>Consistent Sub-20ms Latency: Your 7-19ms range is excellent for a microcontroller! For comparison: - Typical PC WiFi devices on local network: 5-10ms - Raspberry Pi Pico W: 10-30ms (now achieved!) - Previous version: 1000-3000ms (terrible!)</p> <p>Stable Performance: No more wake-up delays - the device stays responsive to all subsequent pings.</p>"},{"location":"kits/wifi-bot/03-ping-test-fast/#why-this-worked","title":"Why This Worked","text":"<p>The <code>wlan.config(pm=0xa11140)</code> command disabled WiFi power management, preventing the chip from: - Entering deep sleep between packets - Taking seconds to wake up from power-saving modes - Causing those massive latency spikes</p> <p>Your Pico W is now behaving like a proper network device that's always ready to respond. This makes it suitable for applications that need reliable network connectivity, like IoT sensors, web servers, or remote monitoring systems.</p> <p>Perfect for any project where you need dependable network responsiveness!</p>"},{"location":"kits/wifi-bot/03-ping-test-fast/#references","title":"References","text":"<p>Connecting to the Internet with Raspberry Pi Pico W-series - documentation by the Raspberry Pi Foundation</p>"},{"location":"kits/wifi-bot/05-simple-web-server/","title":"Simple Web Server","text":""},{"location":"kits/wifi-bot/05-simple-web-server/#simple-led-web-server-code-walkthrough","title":"Simple LED Web Server - Code Walkthrough","text":""},{"location":"kits/wifi-bot/05-simple-web-server/#introduction","title":"Introduction","text":"<p>This tutorial explains how to create a web server on a Raspberry Pi Pico W that can control an LED through a web page. Think of it like creating your own mini-website that can control real hardware!</p>"},{"location":"kits/wifi-bot/05-simple-web-server/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to connect your Pico W to WiFi</li> <li>How to create a simple web server</li> <li>How to control hardware (LED) from a webpage</li> <li>Basic Python programming concepts</li> </ul>"},{"location":"kits/wifi-bot/05-simple-web-server/#prerequisites","title":"Prerequisites","text":"<ul> <li>You need a <code>secrets.py</code> file with your WiFi credentials:</li> </ul> <pre><code>SSID = \"YourWiFiName\"\nPASSWORD = \"YourWiFiPassword\"\n</code></pre>"},{"location":"kits/wifi-bot/05-simple-web-server/#section-1-importing-libraries","title":"Section 1: Importing Libraries","text":"<pre><code>import network\nimport socket\nimport secrets\nimport time\nfrom machine import Pin\n</code></pre> <p>What's happening here?</p> <p><code>import</code> statements tell Python to load special tools (called libraries) that we need:</p> <ul> <li><code>network</code> - Tools for connecting to WiFi</li> <li><code>socket</code> - Tools for creating web servers (like a mailbox for internet messages)</li> <li><code>secrets</code> - Your WiFi password file (keeps it separate and safe)</li> <li><code>time</code> - Tools for waiting and timing</li> <li><code>Pin</code> - From the <code>machine</code> library, this controls the physical pins on your Pico W</li> </ul> <p>Think of imports like getting tools from a toolbox - you only take out what you need for the job.</p>"},{"location":"kits/wifi-bot/05-simple-web-server/#section-2-setting-up-the-led","title":"Section 2: Setting Up the LED","text":"<pre><code># Setup the onboard LED\nled = Pin(\"LED\", Pin.OUT)\nled_state = False  # Track LED state\n</code></pre> <p>What's happening here?</p> <p><code>led = Pin(\"LED\", Pin.OUT)</code> - This creates a connection to the built-in LED on your Pico W - \"LED\" tells it which pin to use (the built-in one) - Pin.OUT means we want to control it (send signals OUT to it)</p> <p><code>led_state = False</code> - This creates a variable to remember if the LED is on or off - <code>False</code> means \"off\"  - <code>True</code> would mean \"on\" - This is like a sticky note that says \"remember: LED is currently off\"</p>"},{"location":"kits/wifi-bot/05-simple-web-server/#section-3-connecting-to-wifi","title":"Section 3: Connecting to WiFi","text":"<pre><code>def connect_wifi():\n    \"\"\"Connect to WiFi network using credentials from secrets.py\"\"\"\n    print(f'Connecting to WiFi: {secrets.SSID}')\n\n    wlan = network.WLAN(network.STA_IF)\n    wlan.active(True)\n    wlan.connect(secrets.SSID, secrets.PASSWORD)\n\n    # Wait for connection\n    while not wlan.isconnected():\n        print('.', end='')\n        time.sleep(1)\n\n    print(f'\\nConnected! IP: {wlan.ifconfig()[0]}')\n    return wlan\n</code></pre> <p>What's happening here?</p> <p><code>def connect_wifi():</code> - This creates a function (a reusable block of code) called <code>connect_wifi</code> - Functions are like recipes - you write them once, then use them whenever needed</p> <p><code>print(f'Connecting to WiFi: {secrets.SSID}')</code> - Shows which network we're connecting to - <code>f'...'</code> is called an f-string - it lets you put variables inside text - <code>secrets.SSID</code> gets your network name from the secrets file</p> <p><code>wlan = network.WLAN(network.STA_IF)</code> - Creates a WiFi object - Think of this like turning on your phone's WiFi</p> <p><code>wlan.active(True)</code> - Turns on the WiFi radio <code>wlan.connect(secrets.SSID, secrets.PASSWORD)</code> - Attempts to connect using your credentials</p> <p>The while loop:</p> <p><pre><code>while not wlan.isconnected():\n    print('.', end='')\n    time.sleep(1)\n</code></pre> - <code>while</code> means \"keep doing this as long as...\" - <code>not wlan.isconnected()</code> means \"as long as we're NOT connected\" - <code>print('.', end='')</code> prints a dot without going to a new line - <code>time.sleep(1)</code> waits 1 second - This creates the \"Connecting...\" dots you see</p> <p><code>return wlan</code> - Gives back the WiFi object so other parts of the code can use it</p>"},{"location":"kits/wifi-bot/05-simple-web-server/#section-4-controlling-the-led","title":"Section 4: Controlling the LED","text":"<pre><code>def toggle_led():\n    \"\"\"Toggle the LED on/off and return current state\"\"\"\n    global led_state\n    led_state = not led_state\n\n    if led_state:\n        led.on()\n        print(\"LED turned ON\")\n    else:\n        led.off()\n        print(\"LED turned OFF\")\n\n    return \"ON\" if led_state else \"OFF\"\n</code></pre> <p>What's happening here?</p> <p><code>global led_state</code> - This tells Python we want to change the <code>led_state</code> variable we created earlier - Without <code>global</code>, Python would create a new, separate variable</p> <p><code>led_state = not led_state</code> - This flips the state - If <code>led_state</code> was <code>False</code>, <code>not False</code> becomes <code>True</code> - If <code>led_state</code> was <code>True</code>, <code>not True</code> becomes <code>False</code> - It's like a light switch - if it's off, turn it on; if it's on, turn it off</p> <p>The if/else statement: <pre><code>if led_state:\n    led.on()\n    print(\"LED turned ON\")\nelse:\n    led.off()\n    print(\"LED turned OFF\")\n</code></pre> - <code>if led_state:</code> means \"if led_state is True\" - <code>led.on()</code> physically turns the LED on - <code>else:</code> means \"otherwise\" (if led_state is False) - <code>led.off()</code> physically turns the LED off</p> <p><code>return \"ON\" if led_state else \"OFF\"</code> - This is a shortcut way to return text - If <code>led_state</code> is <code>True</code>, return <code>\"ON\"</code> - If <code>led_state</code> is <code>False</code>, return <code>\"OFF\"</code></p>"},{"location":"kits/wifi-bot/05-simple-web-server/#section-5-creating-the-web-page","title":"Section 5: Creating the Web Page","text":"<pre><code>def generate_html():\n    \"\"\"Create simple HTML page with LED toggle button\"\"\"\n    html = f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;LED Control&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Simple LED Control&lt;/h1&gt;\n    &lt;p&gt;LED Status: &lt;strong&gt;{toggle_led.__globals__['led_state'] and \"ON\" or \"OFF\"}&lt;/strong&gt;&lt;/p&gt;\n    &lt;button onclick=\"toggleLED()\"&gt;Toggle LED&lt;/button&gt;\n\n    &lt;script&gt;\n        function toggleLED() {{\n            fetch('/toggle', {{method: 'POST'}})\n            .then(() =&gt; location.reload());\n        }}\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n    return html\n</code></pre> <p>What's happening here?</p> <p><code>html = f\"\"\"...\"\"\"</code> - Creates a multi-line string containing HTML code - <code>f\"\"\"...\"\"\"</code> lets us put Python variables inside the HTML - HTML is the language used to create web pages</p> <p>Key HTML parts: - <code>&lt;title&gt;LED Control&lt;/title&gt;</code> - Sets the browser tab title - <code>&lt;h1&gt;Simple LED Control&lt;/h1&gt;</code> - Creates a big heading - <code>&lt;p&gt;LED Status: &lt;strong&gt;...&lt;/strong&gt;&lt;/p&gt;</code> - Shows the current LED status - <code>&lt;button onclick=\"toggleLED()\"&gt;Toggle LED&lt;/button&gt;</code> - Creates a clickable button</p> <p>The JavaScript part: <pre><code>function toggleLED() {\n    fetch('/toggle', {method: 'POST'})\n    .then(() =&gt; location.reload());\n}\n</code></pre> - This runs when someone clicks the button - <code>fetch('/toggle', {method: 'POST'})</code> sends a message to our server - <code>.then(() =&gt; location.reload())</code> refreshes the page after the LED toggles</p>"},{"location":"kits/wifi-bot/05-simple-web-server/#section-6-the-web-server","title":"Section 6: The Web Server","text":"<pre><code>def start_server(wlan):\n    \"\"\"Start web server and handle requests\"\"\"\n    # Create socket and bind to port 80\n    s = socket.socket()\n    s.bind(('0.0.0.0', 80))\n    s.listen(1)\n\n    print(f'Web server running at: http://{wlan.ifconfig()[0]}')\n\n    while True:\n        # Accept incoming connection\n        client, addr = s.accept()\n        print(f'Client connected: {addr}')\n\n        # Read the request\n        request = client.recv(1024).decode('utf-8')\n\n        if 'GET / ' in request:\n            # Serve main page\n            html = generate_html()\n            client.send('HTTP/1.1 200 OK\\r\\n\\r\\n')\n            client.send(html)\n\n        elif 'POST /toggle' in request:\n            # Toggle LED and send response\n            state = toggle_led()\n            client.send('HTTP/1.1 200 OK\\r\\n\\r\\n')\n            client.send(f'LED is {state}')\n\n        client.close()\n</code></pre> <p>What's happening here?</p> <p>Setting up the server: <pre><code>s = socket.socket()\ns.bind(('0.0.0.0', 80))\ns.listen(1)\n</code></pre> - <code>socket.socket()</code> creates a \"mailbox\" for internet messages - <code>s.bind(('0.0.0.0', 80))</code> says \"listen on all network connections, port 80\" - Port 80 is the standard port for websites - <code>s.listen(1)</code> says \"allow 1 person to connect at a time\"</p> <p>The main server loop: <pre><code>while True:\n    # This runs forever, handling one visitor at a time\n</code></pre></p> <p>Handling visitors: <pre><code>client, addr = s.accept()\nprint(f'Client connected: {addr}')\nrequest = client.recv(1024).decode('utf-8')\n</code></pre> - <code>s.accept()</code> waits for someone to visit our website - <code>client.recv(1024)</code> reads their request (what page they want) - <code>.decode('utf-8')</code> converts the message to readable text</p> <p>Understanding the request: <pre><code>if 'GET / ' in request:\n    # Someone wants to see the main page\n    html = generate_html()\n    client.send('HTTP/1.1 200 OK\\r\\n\\r\\n')\n    client.send(html)\n\nelif 'POST /toggle' in request:\n    # Someone clicked the toggle button\n    state = toggle_led()\n    client.send('HTTP/1.1 200 OK\\r\\n\\r\\n')\n    client.send(f'LED is {state}')\n</code></pre></p> <ul> <li><code>GET /</code> means \"show me the main page\"</li> <li><code>POST /toggle</code> means \"toggle the LED\"</li> <li><code>HTTP/1.1 200 OK</code> is like saying \"Everything's fine, here's what you asked for\"</li> </ul> <p><code>client.close()</code> - Ends the conversation with that visitor</p>"},{"location":"kits/wifi-bot/05-simple-web-server/#section-7-the-main-program","title":"Section 7: The Main Program","text":"<pre><code>def main():\n    \"\"\"Main program - connect to WiFi and start server\"\"\"\n    print('Simple LED Web Server')\n    print('====================')\n\n    # Turn off LED initially\n    led.off()\n\n    # Connect to WiFi\n    wlan = connect_wifi()\n\n    # Start web server\n    start_server(wlan)\n\n# Run the program\nif __name__ == '__main__':\n    main()\n</code></pre> <p>What's happening here?</p> <p><code>def main():</code> - Creates the main function that runs our program</p> <p><code>led.off()</code> - Makes sure the LED starts in the \"off\" position</p> <p><code>wlan = connect_wifi()</code> - Calls our WiFi function and saves the result</p> <p><code>start_server(wlan)</code> - Starts the web server (this runs forever)</p> <p><code>if __name__ == '__main__':</code> - This is Python's way of saying \"if this file is being run directly (not imported), then run the main() function\"</p>"},{"location":"kits/wifi-bot/05-simple-web-server/#how-everything-works-together","title":"How Everything Works Together","text":"<ol> <li>Startup: Program turns off LED and connects to WiFi</li> <li>Server starts: Creates a \"mailbox\" at your Pico's IP address</li> <li>Waiting: Server waits for someone to visit the website</li> <li>Visitor arrives: Someone types the IP address in their browser</li> <li>Send webpage: Server sends the HTML page with the button</li> <li>Button clicked: Visitor clicks \"Toggle LED\"</li> <li>Message sent: Browser sends a \"toggle\" message to the server</li> <li>LED changes: Server runs the toggle function, changing the LED</li> <li>Response sent: Server tells the browser \"LED is now ON/OFF\"</li> <li>Page refreshes: Browser reloads to show the new status</li> <li>Repeat: Back to step 5, ready for the next click</li> </ol>"},{"location":"kits/wifi-bot/05-simple-web-server/#key-programming-concepts-you-learned","title":"Key Programming Concepts You Learned","text":"<p>Variables: Storing information (like <code>led_state</code>)</p> <p>Functions: Reusable blocks of code (like <code>toggle_led()</code>)</p> <p>Loops: Repeating actions (<code>while</code> loops)</p> <p>Conditionals: Making decisions (<code>if/else</code> statements)</p> <p>Libraries: Using pre-written code (<code>import</code> statements)</p> <p>Global variables: Sharing data between functions</p> <p>Return values: Functions giving back results</p> <p>String formatting: Putting variables in text (<code>f\"...\"</code>)</p>"},{"location":"kits/wifi-bot/05-simple-web-server/#real-world-applications","title":"Real-World Applications","text":"<p>This same pattern is used in:</p> <ul> <li>Smart home devices (controlling lights, thermostats)</li> <li>IoT (Internet of Things) sensors</li> <li>Industrial control systems</li> <li>Home automation projects</li> <li>Remote monitoring systems</li> </ul> <p>You've just built the foundation for controlling any device over the internet!</p>"},{"location":"kits/wifi-bot/05-simple-web-server/#full-source-code","title":"Full Source Code","text":"<p>Here is the full source code.  It is about 70 lines.</p> <pre><code>import network\nimport socket\nimport secrets\nimport time\nfrom machine import Pin\n\n# Setup the onboard LED\nled = Pin(\"LED\", Pin.OUT)\nled_state = False  # Track LED state\n\ndef connect_wifi():\n    \"\"\"Connect to WiFi network using credentials from secrets.py\"\"\"\n    print(f'Connecting to WiFi: {secrets.SSID}')\n\n    wlan = network.WLAN(network.STA_IF)\n    wlan.active(True)\n    wlan.connect(secrets.SSID, secrets.PASSWORD)\n\n    # Wait for connection\n    while not wlan.isconnected():\n        print('.', end='')\n        time.sleep(1)\n\n    print(f'\\nConnected! IP: {wlan.ifconfig()[0]}')\n    return wlan\n\ndef toggle_led():\n    \"\"\"Toggle the LED on/off and return current state\"\"\"\n    global led_state\n    led_state = not led_state\n\n    if led_state:\n        led.on()\n        print(\"LED turned ON\")\n    else:\n        led.off()\n        print(\"LED turned OFF\")\n\n    return \"ON\" if led_state else \"OFF\"\n\ndef generate_html():\n    \"\"\"Create simple HTML page with LED toggle button\"\"\"\n    html = f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;LED Control&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Simple LED Control&lt;/h1&gt;\n    &lt;p&gt;LED Status: &lt;strong&gt;{toggle_led.__globals__['led_state'] and \"ON\" or \"OFF\"}&lt;/strong&gt;&lt;/p&gt;\n    &lt;button onclick=\"toggleLED()\"&gt;Toggle LED&lt;/button&gt;\n\n    &lt;script&gt;\n        function toggleLED() {{\n            fetch('/toggle', {{method: 'POST'}})\n            .then(() =&gt; location.reload());\n        }}\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n    return html\n\ndef start_server(wlan):\n    \"\"\"Start web server and handle requests\"\"\"\n    # Create socket and bind to port 80\n    s = socket.socket()\n    s.bind(('0.0.0.0', 80))\n    s.listen(1)\n\n    print(f'Web server running at: http://{wlan.ifconfig()[0]}')\n\n    while True:\n        # Accept incoming connection\n        client, addr = s.accept()\n        print(f'Client connected: {addr}')\n\n        # Read the request\n        request = client.recv(1024).decode('utf-8')\n\n        if 'GET / ' in request:\n            # Serve main page\n            html = generate_html()\n            client.send('HTTP/1.1 200 OK\\r\\n\\r\\n')\n            client.send(html)\n\n        elif 'POST /toggle' in request:\n            # Toggle LED and send response\n            state = toggle_led()\n            client.send('HTTP/1.1 200 OK\\r\\n\\r\\n')\n            client.send(f'LED is {state}')\n\n        client.close()\n\ndef main():\n    \"\"\"Main program - connect to WiFi and start server\"\"\"\n    print('Simple LED Web Server')\n    print('====================')\n\n    # Turn off LED initially\n    led.off()\n\n    # Connect to WiFi\n    wlan = connect_wifi()\n\n    # Start web server\n    start_server(wlan)\n\n# Run the program\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"kits/wifi-bot/web-server-test/","title":"Web Server Test","text":"<p>In this lab we will create a web interface to test all your robot's hardware:</p> <ol> <li>LED control with visual feedback</li> <li>NeoPixel colors with real-time status updates</li> <li>Speaker tones at different frequencies</li> <li>Motor movements with automatic 2-second safety timeouts</li> <li>Emergency stop functionality</li> </ol> <p>The debugging output in the Thonny console should also help you understand exactly what's happening when each command is executed. This makes it a great development and testing tool for your STEM robot project.</p> <p></p>"},{"location":"kits/wifi-bot/web-server-test/#thonny-console-log","title":"Thonny Console Log","text":"<pre><code>&gt;&gt;&gt; %Run -c $EDITOR_CONTENT\n\nMPY: soft reboot\nRobot Web Server Test Interface\n===================================\nNeoPixels set to off\nConnecting to WiFi Network: anndan\nPowering up WiFi chip...\nConnection attempt 1/10\n\n\n==================================================\nWIFI CONNECTION SUCCESSFUL!\n==================================================\nIP Address: 10.0.0.57\nNetwork: anndan\n==================================================\n\nWeb server started!\nOpen your browser and go to: http://10.0.0.57\nRobot control interface ready!\n==================================================\nClient connected from ('10.0.0.2', 58686)\nFull request received (482 bytes)\nClient connected from ('10.0.0.2', 58687)\nFull request received (420 bytes)\nUnknown request: GET /favicon.ico HTTP/1.1\nHost: 10.0.0.57\nConnection: keep-alive\nPragma: no-cache\nCache-Control:...\nClient connected from ('10.0.0.2', 58688)\nFull request received (422 bytes)\nPOST request received, length: 422\nRequest body: 'cmd=toggle_led'\nExecuting command: 'toggle_led'\nLED turned ON\nCommand 'toggle_led' executed successfully\nClient connected from ('10.0.0.2', 58690)\nFull request received (493 bytes)\nClient connected from ('10.0.0.2', 58691)\nFull request received (422 bytes)\nPOST request received, length: 422\nRequest body: 'cmd=toggle_led'\nExecuting command: 'toggle_led'\nLED turned OFF\nCommand 'toggle_led' executed successfully\nClient connected from ('10.0.0.2', 58692)\nFull request received (424 bytes)\nPOST request received, length: 424\nRequest body: 'cmd=neopixel_red'\nExecuting command: 'neopixel_red'\nNeoPixels set to red\nCommand 'neopixel_red' executed successfully\nClient connected from ('10.0.0.2', 58693)\nFull request received (493 bytes)\nClient connected from ('10.0.0.2', 58694)\nFull request received (426 bytes)\nPOST request received, length: 426\nRequest body: 'cmd=neopixel_green'\nExecuting command: 'neopixel_green'\nNeoPixels set to green\nCommand 'neopixel_green' executed successfully\nClient connected from ('10.0.0.2', 58698)\nFull request received (425 bytes)\nPOST request received, length: 425\nRequest body: 'cmd=neopixel_blue'\nExecuting command: 'neopixel_blue'\nNeoPixels set to blue\nCommand 'neopixel_blue' executed successfully\nClient connected from ('10.0.0.2', 58699)\nFull request received (424 bytes)\nPOST request received, length: 424\nRequest body: 'cmd=neopixel_off'\nExecuting command: 'neopixel_off'\nNeoPixels set to off\nCommand 'neopixel_off' executed successfully\nClient connected from ('10.0.0.2', 58700)\nFull request received (421 bytes)\nPOST request received, length: 421\nRequest body: 'cmd=play_tone'\nExecuting command: 'play_tone'\nPlayed tone: 1000Hz for 0.5s\nCommand 'play_tone' executed successfully\nClient connected from ('10.0.0.2', 58701)\nFull request received (424 bytes)\nPOST request received, length: 424\nRequest body: 'cmd=move_forward'\nExecuting command: 'move_forward'\nMoving forward\nCommand 'move_forward' executed successfully\nClient connected from ('10.0.0.2', 58702)\nFull request received (423 bytes)\nPOST request received, length: 423\nRequest body: 'cmd=stop_motors'\nExecuting command: 'stop_motors'\nCommand 'stop_motors' executed successfully\nClient connected from ('10.0.0.2', 58703)\nFull request received (424 bytes)\nPOST request received, length: 424\nRequest body: 'cmd=move_reverse'\nExecuting command: 'move_reverse'\nMoving reverse\nCommand 'move_reverse' executed successfully\nClient connected from ('10.0.0.2', 58704)\nFull request received (423 bytes)\nPOST request received, length: 423\nRequest body: 'cmd=stop_motors'\nExecuting command: 'stop_motors'\nCommand 'stop_motors' executed successfully\n</code></pre>"},{"location":"kits/wifi-bot/web-server-test/#source-code","title":"Source Code","text":"<pre><code>import network\nimport socket\nimport secrets\nimport time\nfrom machine import Pin, PWM\nimport neopixel\nimport config\n\n# Hardware setup based on config.py\nled = Pin(\"LED\", Pin.OUT)\n\n# Motor PWM setup\nright_forward = PWM(Pin(config.RIGHT_FORWARD_PIN))\nright_reverse = PWM(Pin(config.RIGHT_REVERSE_PIN))\nleft_forward = PWM(Pin(config.LEFT_FORWARD_PIN))\nleft_reverse = PWM(Pin(config.LEFT_REVERSE_PIN))\n\n# Set PWM frequency for motors (1000 Hz is good for motors)\nright_forward.freq(1000)\nright_reverse.freq(1000)\nleft_forward.freq(1000)\nleft_reverse.freq(1000)\n\n# NeoPixel setup\nnp = neopixel.NeoPixel(Pin(config.NEOPIXEL_PIN), config.NUMBER_NEOPIXELS)\n\n# Speaker setup\nspeaker = PWM(Pin(config.SPEAKER_PIN))\n\n# Global variables for state tracking\nled_state = False\ncurrent_neopixel_color = \"off\"\n\ndef blink_led(times=1, delay=0.2):\n    \"\"\"Blink the onboard LED for status indication\"\"\"\n    for _ in range(times):\n        led.on()\n        time.sleep(delay)\n        led.off()\n        time.sleep(delay)\n\ndef connect_wifi(max_retries=10):\n    \"\"\"Connect to WiFi with retry logic\"\"\"\n    print(f'Connecting to WiFi Network: {secrets.SSID}')\n\n    wlan = network.WLAN(network.STA_IF)\n    wlan.active(True)\n\n    # Disable power management for better responsiveness\n    wlan.config(pm=0xa11140)\n\n    print('Powering up WiFi chip...')\n    time.sleep(3)\n\n    retry_count = 0\n    while retry_count &lt; max_retries:\n        try:\n            print(f'Connection attempt {retry_count + 1}/{max_retries}')\n            wlan.connect(secrets.SSID, secrets.PASSWORD)\n\n            timeout = 15\n            start_time = time.time()\n\n            while not wlan.isconnected() and (time.time() - start_time) &lt; timeout:\n                time.sleep(1)\n                print('.', end='')\n\n            print()\n\n            if wlan.isconnected():\n                return wlan\n            else:\n                print(f'Timeout on attempt {retry_count + 1}')\n                retry_count += 1\n                time.sleep(2)\n\n        except Exception as e:\n            print(f'Error on attempt {retry_count + 1}: {e}')\n            retry_count += 1\n            time.sleep(2)\n\n    return None\n\ndef stop_motors():\n    \"\"\"Stop all motors\"\"\"\n    right_forward.duty_u16(0)\n    right_reverse.duty_u16(0)\n    left_forward.duty_u16(0)\n    left_reverse.duty_u16(0)\n\ndef move_forward():\n    \"\"\"Move robot forward\"\"\"\n    stop_motors()\n    time.sleep(0.1)\n    right_forward.duty_u16(32000)  # About 50% power\n    left_forward.duty_u16(32000)\n    print(\"Moving forward\")\n\ndef move_reverse():\n    \"\"\"Move robot in reverse\"\"\"\n    stop_motors()\n    time.sleep(0.1)\n    right_reverse.duty_u16(32000)\n    left_reverse.duty_u16(32000)\n    print(\"Moving reverse\")\n\ndef turn_right():\n    \"\"\"Turn robot right\"\"\"\n    stop_motors()\n    time.sleep(0.1)\n    left_forward.duty_u16(32000)   # Left wheel forward\n    right_reverse.duty_u16(32000)  # Right wheel reverse\n    print(\"Turning right\")\n\ndef turn_left():\n    \"\"\"Turn robot left\"\"\"\n    stop_motors()\n    time.sleep(0.1)\n    right_forward.duty_u16(32000)  # Right wheel forward\n    left_reverse.duty_u16(32000)   # Left wheel reverse\n    print(\"Turning left\")\n\ndef set_neopixels(color):\n    \"\"\"Set NeoPixels to specified color\"\"\"\n    global current_neopixel_color\n    current_neopixel_color = color\n\n    if color == \"red\":\n        for i in range(config.NUMBER_NEOPIXELS):\n            np[i] = (255, 0, 0)\n    elif color == \"green\":\n        for i in range(config.NUMBER_NEOPIXELS):\n            np[i] = (0, 255, 0)\n    elif color == \"blue\":\n        for i in range(config.NUMBER_NEOPIXELS):\n            np[i] = (0, 0, 255)\n    else:  # off\n        for i in range(config.NUMBER_NEOPIXELS):\n            np[i] = (0, 0, 0)\n\n    np.write()\n    print(f\"NeoPixels set to {color}\")\n\ndef play_tone(frequency=1000, duration=0.5):\n    \"\"\"Play a tone on the speaker\"\"\"\n    speaker.freq(frequency)\n    speaker.duty_u16(32768)  # 50% duty cycle\n    time.sleep(duration)\n    speaker.duty_u16(0)  # Turn off\n    print(f\"Played tone: {frequency}Hz for {duration}s\")\n\ndef toggle_led():\n    \"\"\"Toggle the onboard LED\"\"\"\n    global led_state\n    led_state = not led_state\n    if led_state:\n        led.on()\n        print(\"LED turned ON\")\n    else:\n        led.off()\n        print(\"LED turned OFF\")\n\ndef generate_html():\n    \"\"\"Generate the HTML page for robot control\"\"\"\n    html = f\"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Robot Test Interface&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;style&gt;\n        body {{\n            font-family: Arial, sans-serif;\n            max-width: 600px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f0f0f0;\n        }}\n        .container {{\n            background-color: white;\n            padding: 20px;\n            border-radius: 10px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }}\n        h1 {{\n            color: #333;\n            text-align: center;\n        }}\n        .section {{\n            margin: 20px 0;\n            padding: 15px;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }}\n        .section h3 {{\n            margin-top: 0;\n            color: #555;\n        }}\n        button {{\n            background-color: #4CAF50;\n            color: white;\n            padding: 10px 20px;\n            margin: 5px;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n            font-size: 16px;\n        }}\n        button:hover {{\n            background-color: #45a049;\n        }}\n        .motor-btn {{\n            background-color: #2196F3;\n        }}\n        .motor-btn:hover {{\n            background-color: #1976D2;\n        }}\n        .stop-btn {{\n            background-color: #f44336;\n        }}\n        .stop-btn:hover {{\n            background-color: #d32f2f;\n        }}\n        .status {{\n            margin-top: 20px;\n            padding: 10px;\n            background-color: #e8f5e8;\n            border-radius: 5px;\n        }}\n        .color-buttons {{\n            display: flex;\n            gap: 10px;\n            flex-wrap: wrap;\n        }}\n        .red-btn {{ background-color: #f44336; }}\n        .green-btn {{ background-color: #4CAF50; }}\n        .blue-btn {{ background-color: #2196F3; }}\n        .off-btn {{ background-color: #757575; }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;h1&gt;Robot Test Interface v2&lt;/h1&gt;\n\n        &lt;div class=\"section\"&gt;\n            &lt;h3&gt;Onboard LED&lt;/h3&gt;\n            &lt;button onclick=\"sendCommand('toggle_led')\"&gt;Toggle LED&lt;/button&gt;\n            &lt;p&gt;Current state: &lt;span id=\"led-status\"&gt;{'ON' if led_state else 'OFF'}&lt;/span&gt;&lt;/p&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"section\"&gt;\n            &lt;h3&gt;NeoPixels&lt;/h3&gt;\n            &lt;div class=\"color-buttons\"&gt;\n                &lt;button class=\"red-btn\" onclick=\"sendCommand('neopixel_red')\"&gt;Red&lt;/button&gt;\n                &lt;button class=\"green-btn\" onclick=\"sendCommand('neopixel_green')\"&gt;Green&lt;/button&gt;\n                &lt;button class=\"blue-btn\" onclick=\"sendCommand('neopixel_blue')\"&gt;Blue&lt;/button&gt;\n                &lt;button class=\"off-btn\" onclick=\"sendCommand('neopixel_off')\"&gt;Off&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;p&gt;Current color: &lt;span id=\"neopixel-status\"&gt;{current_neopixel_color}&lt;/span&gt;&lt;/p&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"section\"&gt;\n            &lt;h3&gt;Speaker&lt;/h3&gt;\n            &lt;button onclick=\"sendCommand('play_tone')\"&gt;Play Tone (1000Hz)&lt;/button&gt;\n            &lt;button onclick=\"sendCommand('play_tone_low')\"&gt;Low Tone (500Hz)&lt;/button&gt;\n            &lt;button onclick=\"sendCommand('play_tone_high')\"&gt;High Tone (1500Hz)&lt;/button&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"section\"&gt;\n            &lt;h3&gt;Motor Control&lt;/h3&gt;\n            &lt;div&gt;\n                &lt;button class=\"motor-btn\" onclick=\"sendCommand('move_forward')\"&gt;Forward&lt;/button&gt;\n                &lt;button class=\"motor-btn\" onclick=\"sendCommand('move_reverse')\"&gt;Reverse&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;button class=\"motor-btn\" onclick=\"sendCommand('turn_left')\"&gt;Turn Left&lt;/button&gt;\n                &lt;button class=\"motor-btn\" onclick=\"sendCommand('turn_right')\"&gt;Turn Right&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;button class=\"stop-btn\" onclick=\"sendCommand('stop_motors')\"&gt;STOP&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;p&gt;&lt;em&gt;Note: Motors will run for 2 seconds then auto-stop&lt;/em&gt;&lt;/p&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"status\"&gt;\n            &lt;h3&gt;System Status&lt;/h3&gt;\n            &lt;p&gt;WiFi: Connected&lt;/p&gt;\n            &lt;p&gt;Last command: &lt;span id=\"last-command\"&gt;None&lt;/span&gt;&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        function sendCommand(command) {{\n            console.log('Sending command:', command);\n            document.getElementById('last-command').textContent = 'Sending: ' + command;\n\n            fetch('/command', {{\n                method: 'POST',\n                headers: {{\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                }},\n                body: 'cmd=' + encodeURIComponent(command)\n            }})\n            .then(response =&gt; {{\n                console.log('Response status:', response.status);\n                return response.text();\n            }})\n            .then(data =&gt; {{\n                console.log('Response data:', data);\n                document.getElementById('last-command').textContent = command + ' (' + data + ')';\n\n                // Update status displays based on command\n                if (command === 'toggle_led') {{\n                    // Will be updated on next page load or we can toggle the display\n                    setTimeout(() =&gt; location.reload(), 500);\n                }}\n                if (command.startsWith('neopixel_')) {{\n                    const color = command.replace('neopixel_', '');\n                    document.getElementById('neopixel-status').textContent = color;\n                }}\n            }})\n            .catch(error =&gt; {{\n                console.error('Error:', error);\n                document.getElementById('last-command').textContent = 'Error: ' + command + ' - ' + error.message;\n            }});\n        }}\n\n        // Add some debug info\n        console.log('Robot control interface loaded');\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n    return html\n\ndef handle_command(command):\n    \"\"\"Handle robot commands from web interface\"\"\"\n    try:\n        if command == \"toggle_led\":\n            toggle_led()\n        elif command == \"neopixel_red\":\n            set_neopixels(\"red\")\n        elif command == \"neopixel_green\":\n            set_neopixels(\"green\")\n        elif command == \"neopixel_blue\":\n            set_neopixels(\"blue\")\n        elif command == \"neopixel_off\":\n            set_neopixels(\"off\")\n        elif command == \"play_tone\":\n            play_tone(1000, 0.5)\n        elif command == \"play_tone_low\":\n            play_tone(500, 0.5)\n        elif command == \"play_tone_high\":\n            play_tone(1500, 0.5)\n        elif command == \"move_forward\":\n            move_forward()\n            time.sleep(2)  # Run for 2 seconds\n            stop_motors()\n        elif command == \"move_reverse\":\n            move_reverse()\n            time.sleep(2)\n            stop_motors()\n        elif command == \"turn_left\":\n            turn_left()\n            time.sleep(2)\n            stop_motors()\n        elif command == \"turn_right\":\n            turn_right()\n            time.sleep(2)\n            stop_motors()\n        elif command == \"stop_motors\":\n            stop_motors()\n        else:\n            print(f\"Unknown command: {command}\")\n            return False\n        return True\n    except Exception as e:\n        print(f\"Error executing command {command}: {e}\")\n        return False\n\ndef start_web_server(wlan):\n    \"\"\"Start the web server\"\"\"\n    addr = socket.getaddrinfo('0.0.0.0', 80)[0][-1]\n    s = socket.socket()\n    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    s.bind(addr)\n    s.listen(1)\n\n    ip = wlan.ifconfig()[0]\n    print(f'\\nWeb server started!')\n    print(f'Open your browser and go to: http://{ip}')\n    print(f'Robot control interface ready!')\n    print('='*50)\n\n    while True:\n        try:\n            cl, addr = s.accept()\n            print(f'Client connected from {addr}')\n\n            # Set a timeout for receiving data\n            cl.settimeout(2.0)\n\n            # Read the request in chunks to ensure we get it all\n            request = b''\n            try:\n                while True:\n                    chunk = cl.recv(1024)\n                    if not chunk:\n                        break\n                    request += chunk\n                    # Check if we have the complete request\n                    if b'\\r\\n\\r\\n' in request:\n                        break\n            except:\n                # Timeout or error reading - proceed with what we have\n                pass\n\n            request = request.decode('utf-8')\n            print(f\"Full request received ({len(request)} bytes)\")\n\n            # Parse the request\n            if 'GET / ' in request:\n                # Serve the main page\n                response = generate_html()\n                cl.send('HTTP/1.1 200 OK\\r\\n')\n                cl.send('Content-Type: text/html\\r\\n')\n                cl.send(f'Content-Length: {len(response)}\\r\\n')\n                cl.send('\\r\\n')\n                cl.send(response)\n\n            elif 'POST /command' in request:\n                # Handle command - improved parsing with debugging\n                print(f\"POST request received, length: {len(request)}\")\n\n                # Find the body of the request\n                body_start = request.find('\\r\\n\\r\\n')\n                if body_start != -1:\n                    body = request[body_start + 4:]\n                    print(f\"Request body: '{body}'\")\n\n                    # Parse URL-encoded data\n                    if body.startswith('cmd='):\n                        command = body[4:].strip()  # Remove 'cmd=' prefix and whitespace\n                        print(f\"Executing command: '{command}'\")\n                        success = handle_command(command)\n\n                        if success:\n                            response = \"OK\"\n                            print(f\"Command '{command}' executed successfully\")\n                        else:\n                            response = \"ERROR\"\n                            print(f\"Command '{command}' failed\")\n\n                        cl.send('HTTP/1.1 200 OK\\r\\n')\n                        cl.send('Content-Type: text/plain\\r\\n')\n                        cl.send('Access-Control-Allow-Origin: *\\r\\n')\n                        cl.send(f'Content-Length: {len(response)}\\r\\n')\n                        cl.send('\\r\\n')\n                        cl.send(response)\n                    else:\n                        print(f\"Invalid body format: '{body}'\")\n                        cl.send('HTTP/1.1 400 Bad Request\\r\\n\\r\\n')\n                else:\n                    print(\"No body found in POST request\")\n                    cl.send('HTTP/1.1 400 Bad Request\\r\\n\\r\\n')\n            else:\n                # 404 for other requests\n                print(f\"Unknown request: {request[:100]}...\")\n                cl.send('HTTP/1.1 404 Not Found\\r\\n\\r\\n')\n\n        except Exception as e:\n            print(f'Web server error: {e}')\n        finally:\n            try:\n                cl.close()\n            except:\n                pass\n\ndef main():\n    \"\"\"Main program function\"\"\"\n    print('Robot Web Server Test Interface')\n    print('===================================')\n\n    # Initialize hardware\n    stop_motors()\n    set_neopixels(\"off\")\n    led.off()\n\n    # Initial LED indication\n    blink_led(2, 0.5)\n\n    # Connect to WiFi\n    wlan = connect_wifi()\n\n    if wlan:\n        config = wlan.ifconfig()\n        print('\\n' + '='*50)\n        print('WIFI CONNECTION SUCCESSFUL!')\n        print('='*50)\n        print(f'IP Address: {config[0]}')\n        print(f'Network: {secrets.SSID}')\n        print('='*50)\n\n        blink_led(3, 0.2)  # Success indication\n\n        # Start the web server\n        start_web_server(wlan)\n    else:\n        print('\\nFAILED TO CONNECT!')\n        print('Check your secrets.py file for correct SSID and PASSWORD')\n        blink_led(10, 0.1)  # Error indication\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"learning-graphs/","title":"Learning Graphs","text":""},{"location":"learning-graphs/#enumeration","title":"Enumeration","text":""},{"location":"learning-graphs/#dependencies","title":"Dependencies","text":""},{"location":"learning-graphs/#taxonomies","title":"Taxonomies","text":""},{"location":"learning-graphs/01-course-description/","title":"Course Description","text":""},{"location":"learning-graphs/01-course-description/#prompt","title":"Prompt","text":"<pre><code>Please generate a detailed course description for the following course\nusing Bloom's 2001 taxonomy.\n\nCreate a derailed course description that describes a 14 week\nhands-on course on teaching computational thinking using\na low-cost STEM robot.\n\nThe target audience for this course is students in the 9 to 12th grade\nof high school that have\nlittle or no experience with coding.  The goal is to get\nthem exposed to the ideas of computational thinking\nusing a fun hands-on $35 STEM robot.\n\nThe robot is built around the Cytron RP2040 Maker Pi board.\nIt has two DC motors and a time-of-flight sensor as well\nas a 128x64 monochrome OLED display.  All coding\nis done using MicroPython v1.24.1 using the Thonny.\n\nThe students will have access to Thonny installed on their\ncomputer lab systems before the class begins.\n\nThe rough outline is:\n\n1. What is computational thinking: algorithms, abstraction, decomposition and pattern matching\n2. Why fun low-cost robots the best way to learn computational thinking\n3. Overview of physical computing: sensors, motors, displays and controllers\n5. Overview of the robot hardware (DC motor, Cytron board, Time-of-flight sensor, OLED display)\n5. Getting started with Thonny: desktop, syntax of Python\n6. Blinking an LED on the Cytron board\n7. Changing color on a NeoPixel\n8. Moving a pixel up and down a LED NeoPixel strip\n9. Playing a sound\n10. Driving a motor forward and reverse\n12. The I2C bus\n13. Reading the distance sensor\n14. The SPI bus\n15. Using the OLED display\n16. Drawing commands (text, line, circle, polygon)\n17. Drawing a chart of distance measurements\n18. Running the collision avoidance program\n19. Changing the collision avoidance parameters\n20. Drawing a face on the robot\n21. Student projects: adding sensors, breadboarding, displays, AI\n22. Summary: What we have learned about computational thinking\n\nUse Bloom's taxonomy to create a list of learning objectives.\n</code></pre>"},{"location":"learning-graphs/01-course-description/#chatgpt-response","title":"ChatGPT Response","text":""},{"location":"learning-graphs/01-course-description/#course-description_1","title":"Course Description","text":"<p>This 14-week, hands-on course introduces high school students (grades 9--12) to computational thinking through engaging, interactive activities with a $35 STEM robot. Designed for students with little to no prior coding experience, the course leverages the Cytron RP2040 Maker Pi board, a platform featuring DC motors, a time-of-flight sensor, and a 128x64 monochrome OLED display. Students will explore the fundamentals of physical computing, programming in MicroPython using the Thonny IDE, and problem-solving through computational thinking.</p> <p>Through weekly challenges and creative projects, students will gain proficiency in algorithms, decomposition, pattern recognition, and abstraction while building practical programming and engineering skills. This course emphasizes experiential learning, encouraging students to tinker, create, and innovate. The final project empowers students to extend their robot's capabilities by incorporating additional sensors or displays, fostering creativity and technical confidence.</p>"},{"location":"learning-graphs/01-course-description/#learning-objectives","title":"Learning Objectives","text":"<p>Using Bloom's 2001 taxonomy, the course objectives are structured across cognitive levels to ensure comprehensive understanding and skill development:</p>"},{"location":"learning-graphs/01-course-description/#remembering","title":"Remembering","text":"<ul> <li>Identify the key components of computational thinking: algorithms, decomposition, pattern matching, and abstraction.</li> <li>Recognize the primary functions of the Cytron RP2040 Maker Pi board, including its sensors, motors, and display.</li> <li>Recall the syntax and basic commands of MicroPython.</li> </ul>"},{"location":"learning-graphs/01-course-description/#understanding","title":"Understanding","text":"<ul> <li>Explain how physical computing integrates hardware (e.g., sensors, motors, and displays) with software.</li> <li>Describe the purpose of the I2C and SPI communication protocols in robotics.</li> <li>Interpret basic distance measurements from the time-of-flight sensor.</li> </ul>"},{"location":"learning-graphs/01-course-description/#applying","title":"Applying","text":"<ul> <li>Demonstrate how to blink an LED and control a NeoPixel using MicroPython.</li> <li>Write code to control motor movements, such as driving forward and reversing direction.</li> <li>Create simple visualizations on the OLED display, such as text or charts.</li> </ul>"},{"location":"learning-graphs/01-course-description/#analyzing","title":"Analyzing","text":"<ul> <li>Compare different collision avoidance parameters and their effects on robot behavior.</li> <li>Examine the impact of distance sensor readings on motor control logic.</li> <li>Distinguish between hardware and software issues when debugging a robot program.</li> </ul>"},{"location":"learning-graphs/01-course-description/#evaluating","title":"Evaluating","text":"<ul> <li>Assess the efficiency of different algorithms for navigating the robot in various scenarios.</li> <li>Critique student-created programs for clarity, functionality, and adherence to computational thinking principles.</li> <li>Test and validate the accuracy of time-of-flight sensor readings using a visual chart on the OLED display.</li> </ul>"},{"location":"learning-graphs/01-course-description/#creating","title":"Creating","text":"<ul> <li>Design and implement a custom program that integrates additional sensors or displays with the robot.</li> <li>Build a unique robot behavior, such as drawing animated faces or creating interactive games.</li> <li>Develop a creative final project that demonstrates mastery of computational thinking concepts and physical computing skills.</li> </ul>"},{"location":"learning-graphs/01-course-description/#weekly-course-schedule-outline","title":"Weekly Course Schedule Outline","text":""},{"location":"learning-graphs/01-course-description/#weeks-1-2-foundations-of-computational-thinking-and-robotics","title":"Weeks 1--2: Foundations of Computational Thinking and Robotics","text":"<ul> <li>Introduction to computational thinking principles and the benefits of learning through robotics.</li> <li>Overview of robot hardware and physical computing.</li> </ul>"},{"location":"learning-graphs/01-course-description/#weeks-3-5-getting-started-with-micropython-and-thonny-ide","title":"Weeks 3--5: Getting Started with MicroPython and Thonny IDE","text":"<ul> <li>Familiarization with the Cytron Maker Pi board and basic Python syntax.</li> <li>Hands-on activities: blinking LEDs, controlling NeoPixels, and playing sounds.</li> </ul>"},{"location":"learning-graphs/01-course-description/#weeks-6-8-exploring-sensors-motors-and-communication-protocols","title":"Weeks 6--8: Exploring Sensors, Motors, and Communication Protocols","text":"<ul> <li>Coding motor control for driving and reversing.</li> <li>Using the I2C bus for distance sensing and the SPI bus for display communication.</li> </ul>"},{"location":"learning-graphs/01-course-description/#weeks-9-10-advanced-display-programming-and-data-visualization","title":"Weeks 9--10: Advanced Display Programming and Data Visualization","text":"<ul> <li>Drawing shapes, text, and charts on the OLED display.</li> <li>Implementing a collision avoidance program and tuning its parameters.</li> </ul>"},{"location":"learning-graphs/01-course-description/#weeks-11-12-creative-programming-challenges","title":"Weeks 11--12: Creative Programming Challenges","text":"<ul> <li>Drawing animated faces and customizing robot behaviors.</li> <li>Adding new components via breadboarding and extending robot capabilities.</li> </ul>"},{"location":"learning-graphs/01-course-description/#weeks-13-14-final-project-and-course-summary","title":"Weeks 13--14: Final Project and Course Summary","text":"<ul> <li>Student-designed projects integrating sensors, displays, and creative coding.</li> <li>Reflection and discussion on computational thinking skills acquired throughout the course.</li> </ul>"},{"location":"learning-graphs/01-course-description/#assessment-methods","title":"Assessment Methods","text":"<ul> <li>Quizzes: Weekly assessments on coding syntax, robotics concepts, and computational thinking principles.</li> <li>Hands-On Labs: Regular programming assignments and challenges to reinforce skills.</li> <li>Final Project: An open-ended robotics project demonstrating mastery of course objectives.</li> <li>Participation: Active engagement in discussions, labs, and collaborative problem-solving.</li> </ul> <p>This course offers an exciting introduction to computational thinking, sparking curiosity and fostering a lifelong interest in technology and engineering!</p> <p>4o</p>"},{"location":"learning-graphs/02-enumeration/","title":"Enumerating Concepts","text":""},{"location":"learning-graphs/02-enumeration/#prompt","title":"Prompt","text":"<pre><code>Given the course description in the prior section,\ncreate a list of the 150 key concepts that must\nbe taught in this course.  Return a ordered list of the\nconcept labels with under 30 characters per label.\nUse abbreviations when needed.  Order the concepts\nin the order you think they should be taught.\n</code></pre>"},{"location":"learning-graphs/02-enumeration/#response","title":"Response","text":""},{"location":"learning-graphs/02-enumeration/#workflow","title":"Workflow","text":"<p>Identifying key concepts</p> <p>I'm tasked with identifying and listing 150 key concepts for a 14-week course on computational thinking using a STEM robot. The concepts will be ordered from foundational to advanced, spanning areas like algorithm basics, hardware fundamentals, and MicroPython essentials.</p> <p>Categorizing key concepts</p> <p>I'm mapping out a logical progression of 150 key concepts, focusing on computational thinking, MicroPython syntax, hardware, and specific functionalities like controlling LEDs, ensuring clarity and brevity.</p> <p>Mapping the course</p> <p>I'm outlining a 14-week course, categorizing concepts like computational thinking, hardware introduction, MicroPython syntax, and LED control, ensuring clarity with concise labels under 30 characters.</p> <p>Applying abbreviations</p> <p>I'm outlining a course by using abbreviations to efficiently condense key concepts, ensuring each label remains under 30 characters and maintaining clarity in the course structure.</p> <p>Mapping the curriculum</p> <p>I'm listing key concepts like computational thinking, sensors, and MicroPython syntax, ensuring labels are concise and under 30 characters to maintain clarity and progression in the course structure.</p> <p>Refining course concepts</p> <p>I'm refining course concepts, like coding LED actions, wiring sensors, and debugging, ensuring each step is clearly defined and builds upon previous knowledge, maintaining a logical progression.</p> <p>Focusing on details</p> <p>I'm honing in on advanced concepts like servo control, data smoothing, and AI classification, ensuring each label is concise and under 30 characters.</p>"},{"location":"learning-graphs/03-dependency/","title":"Concept Dependency Generation","text":""},{"location":"learning-graphs/03-dependency/#_1","title":"Concept Dependency Generation","text":"<pre><code>Return a single CSV file with the following three columns:\n\n1. The ConceptID from the list above\n2. The ConceptLabel from the list above\n3. The Dependencies which is a list of pipe-delimited ConceptIDs\n\nMake sure that all the concepts have at least one dependency. The only exception\nare foundational prerequisite concepts that are assumed at the start of the course.\n</code></pre> <p>ou did not understand my request.  The third column you returned has all \"1\"s.  This is not useful to me.  I want a pipe-delimited list of the ConceptIDs that each concept depends on for learning.  For example, before you write a Blink LED program you must first understand:</p> <ul> <li>Cytron Board (for pins) ConceptID=13</li> <li>MicroPython Intro which has Concept ID=17</li> <li>The Thonny IED  ConceptID 18, </li> </ul> <p>The line for the Blink LED concept would be:</p> <p>24,Blink LED, 13|17|18</p> <p>Pay careful attention to the third column and make sure it has useful dependency information.</p> <p>Also return the Concept Labels in Title Case.</p>"},{"location":"learning-graphs/03-dependency/#response","title":"Response","text":"<pre><code>ConceptID,ConceptLabel,Dependencies\n1,Computational Think,\n2,Algorithm Basics,1\n3,Decompose Problems,1\n4,Pattern Match,1\n5,Abstraction,1\n6,Robot Learning Fun,1\n7,Low-Cost Robots,6\n8,Physical Computing,7\n9,Sensors Overview,8\n10,Motors Overview,8\n11,Displays Overview,8\n12,Controllers Overview,8\n13,Cytron Rp2040 Bd,12\n14,Dc Motor Ops,10|13\n15,Tof Sensor,9|13\n16,Oled Display,11|13\n17,Micropython Intro,1\n18,Thonny Ide,17\n19,Syntax: Vars,17\n20,Syntax: Loops,19\n21,Syntax: Cond,19\n22,Syntax: Funcs,19\n23,Syntax: Imports,19\n24,Blink Led,13|17|18\n25,Neopixel Intro,24\n26,Change Led Color,25\n27,Move Led Pixel,25\n28,Play Sound,13|17\n29,Drive Motor Fwd,14|17\n30,Drive Motor Rev,29\n31,I2c Bus Intro,13|17\n32,Read Dist Sensor,15|31\n33,Spi Bus Intro,13|17\n34,Oled Init,16|33\n35,Draw Text,34\n36,Draw Line,34\n37,Draw Circle,34\n38,Draw Polygon,34\n39,Chart Dist Data,32|34\n40,Collision Avoid,32|29\n41,Adjust Coll Param,40\n42,Draw Robot Face,35|36|37|38\n43,User Project Intro,1\n44,Add Sensors,9|43\n45,Breadboard Basics,13|43\n46,Add Displays,11|43\n47,Intro To Ai,1\n48,Review Comp Think,1\n49,Robot Assembly,7|13\n50,Robo Wiring,49\n51,Power Mgmt,49\n52,Maker Pi Pins,13\n53,Motor Driver Chip,14|52\n54,Tof Wiring,15|50\n55,Oled Wiring,16|50\n56,Led Blink Code,24\n57,Led On/Off,24\n58,Led Timing,24\n59,Neopxl Set Color,26\n60,Neopxl Strip Idx,27\n61,Neopxl Animate,59|60\n62,Play Tone Freq,28\n63,Play Melody,62\n64,Fwd Motor Code,29\n65,Rev Motor Code,30\n66,Stop Motor Code,29|30\n67,I2c Addrs,31\n68,I2c Read,31\n69,I2c Write,31\n70,Dist Sensor Read,32\n71,Dist Thresholds,70\n72,Spi Concept,33\n73,Spi Data,33\n74,Oled Lib Use,34\n75,Set Oled Pixel,34\n76,Draw Shapes,35|36|37|38\n77,Draw Charts,39\n78,Dist Data Array,39\n79,Coll Avoid Logic,40\n80,Set Coll Limit,41\n81,Face Pixels,42\n82,Face Animate,81\n83,Custom Sensors,44\n84,Extra Breadboard,45\n85,Ext Wiring,50|45\n86,2nd Display,46\n87,Basic Ai Logic,47\n88,If-Else Refine,21\n89,While Loops,20\n90,For Loops,20\n91,Func Params,22\n92,Func Returns,22\n93,Error Handle,17\n94,Debug Print,19\n95,Debug Led,24\n96,Debug Sound,28\n97,Data Types,17\n98,Lists,97\n99,Dict,97\n100,Tuples,97\n101,String Ops,97\n102,Math Ops,17\n103,Comp Ops,17\n104,Logic Ops,17\n105,Servo Ctrl,14\n106,Pwm Signals,52\n107,Motor Calibrate,14|105\n108,Dist Calibrate,32\n109,Sensor Noise,32\n110,Data Smoothing,39|98\n111,Data Logging,17|23\n112,Memory Mgmt,17\n113,File Save,111\n114,Import Modules,23\n115,Time Module,23\n116,Utime Sleep,115\n117,Ufunctools,23\n118,Urandom,23\n119,Pin Config,13\n120,Pull-Ups,119\n121,Gpio Read,119\n122,Gpio Write,119\n123,Encoders,14\n124,Gear Ratios,14\n125,Battery Life,51\n126,Usb Power,51\n127,Project Design,43\n128,Project Planning,127\n129,Idea Generation,43\n130,Proto Build,127|45\n131,Test Cycles,130\n132,Refine Code,19|131\n133,Refine Mech,131\n134,Share Results,43\n135,Doc Code,19\n136,Comment Style,19\n137,Version Ctrl,43|17\n138,Teamwork,43\n139,Problem Solve,1\n140,Bug Fix,132\n141,Feedback Loops,139\n142,Eval Success,139\n143,Scaling Up,43|78\n144,Future Sensors,83\n145,Oled Anim,42|82\n146,Motor Patterns,107\n147,Dist Mapping,78\n148,Ai Classify,87\n149,Final Review,48\n150,Celebrate Learn,149\n</code></pre>"},{"location":"learning-graphs/04-taxonomy/","title":"A Taxonomy of Concepts for STEM Robots","text":""},{"location":"learning-graphs/04-taxonomy/#prompt","title":"Prompt","text":"<p>Here is a cleaned up version of this CSV file.  Now please create a taxonomy with 10 classifiers for this list as well as one Miscellaneous classifier.  Return a list of each of the classifiers with a short classifier name (label) and a short description of each classifier.</p>"},{"location":"learning-graphs/04-taxonomy/#response","title":"Response","text":"<p>Classifier List with Short Names and Descriptions</p> <ol> <li>Computational Thinking: Foundational concepts in computational thinking and problem-solving strategies.</li> <li>MicroPython: Core programming skills in MicroPython, including syntax, control structures, and functions.</li> <li>MicroController Board: Hardware fundamentals related to the Cytron RP2040 board, pin configurations, and wiring practices.</li> <li>Actuators: Motor and servo control concepts, including setup, calibration, and pattern development.</li> <li>Sensors: Sensor usage and integration, focusing on distance measurement, TOF sensors, and sensor data handling.</li> <li>Displays: Working with OLED and other displays---initialization, drawing text, shapes, charts, and animations.</li> <li>Communication Protocols: Communication protocols such as I2C and SPI, including addressing, reading, and writing data.</li> <li>Beginning Electronics: Breadboarding, electronics assembly, power management, and extending hardware capabilities.</li> <li>Debugging Tips: Techniques for debugging, data logging, smoothing, and using tools for refinement and testing.</li> <li>Project Management: Project planning, design, iterative development, version control, and teamwork strategies.</li> <li>Miscellaneous: Advanced topics and additional concepts like AI logic, classification, future sensors, and final review.</li> </ol>"},{"location":"learning-graphs/04-taxonomy/#classified-responses","title":"Classified Responses","text":"<p>STEM Robots CSV File</p>"},{"location":"learning-graphs/04-taxonomy/#workflow","title":"Workflow","text":"<p>Categorizing concepts</p> <p>I'm mapping Computational Thinking and Algorithm Basics to ground-breaking computational thinking, while conceptual robotics introductions align with these foundational ideas. Physical Computing might blend hardware and computation.</p> <p>Breaking down concepts</p> <p>Sensors Overview fits into sensors, Motors Overview matches actuators, Display Overview aligns with displays, Controllers Overview ties to boards/hardware, and Cytron RP2040 Board is rooted in hardware fundamentals.</p> <p>Deciding on category</p> <p>I'm concluding that the 'Blink LED Lab' should be classified under MicroPyProg, as it involves coding to control hardware, specifically the board's LED, making it a coding exercise with a hardware application.</p> <p>Mapping concepts</p> <p>OK, let me see. 'Change NeoPixel Color' and 'Move LED Pixels' clearly belong to MicroPyProg, as they center on controlling software with hardware. Likewise, 'Play Sound' fits here due to its coding-hardware control emphasis.</p> <p>Mapping concepts</p> <p>I'm aligning each concept with its classifier: Drive Motor Forward and Drive Motor Reverse fit under actuators, I2C Bus Intro and SPI Bus Intro go to communication protocols, and Collision Avoid spans sensors and logic.</p> <p>Piecing together concepts</p> <p>Adjusting collision parameters and adding sensors clearly fall under sensors. Projects are classified with project management, while breadboarding is linked to electronics construction and robot assembly to hardware fundamentals.</p> <p>Determining categories</p> <p>OK, let me see: Robot wiring and power management fit electronics construction. Maker Pi Pins align with board hardware, while the Motor Driver Chip is key to controlling actuators.</p> <p>Aligning with classifiers</p> <p>I'm noting that wiring Tof and Oled sensors falls under sensors and displays. Coding LED blink, on/off, timing, and controlling NeoPixels and Motor Driver Chips align with MicroPyProg and actuators.</p> <p>Categorizing sensor data</p> <p>Representing sensor data, especially after a distance reading, logically fits under the Sensors category. This helps us refine our approach to capturing and categorizing data effectively.</p> <p>Integrating collision logic</p> <p>Collision Avoid Logic and setting collision limits align with sensors. DebugPrint, DebugLED, and DebugSound tie data handling to debug data. Data Types, Lists, and Dictionaries link to programming concepts.</p> <p>Organizing concepts</p> <p>I'm putting 'Import Modules' and 'Time Module' under MicroPyProg. Pin Config and Pull-Ups go to BoardHW. Motor encoders and gear ratios fit Actuators. Battery life and USB power management align with ElecConstruct.</p> <p>Assigning concepts</p> <p>Test Cycles relate to project iteration. I'm considering it under ProjMgmt for systematic development progress. Code refinement involves reiteration, fitting into ProjMgmt as part of iterative progress.</p> <p>Focusing on project refinement</p> <p>OK, let me see: Refine Mechanical and Share Results align with project management. Documenting code and maintaining coding style fit under best practices, streamlining our approach to iterative development.</p> <p>Shifting focus</p> <p>I'm aligning concepts with project management methods, adjusting our approach to iterative development. This helps guide towards successful outcomes and effective teamwork.</p>"},{"location":"lessons/","title":"Sample Lessons for STEM Robots","text":""},{"location":"lessons/#base-lessons","title":"Base Lessons","text":"<p>Our base lessons target 9 to 12th grade students. At the end of many lessons, you will find a list of Challenges for more advanced students. You will also find links to other lesson plans that target older or younger students.  If you don't find the grade level you need, you can use generative AI programs such as ChatGPT to customize the lesson plans to a new grade level.</p>"},{"location":"lessons/#lesson-order","title":"Lesson Order","text":"<p>We have used generative AI to suggest the first 100 lessons and their order.  You can generate your own lesson order by modifying the prompts we gave as examples.</p> <p>Lesson Order Prompts and Results</p>"},{"location":"lessons/#using-generative-ai-to-customize-lessons","title":"Using Generative AI to Customize Lessons","text":"<pre><code>Given this lesson plan, generate a new lesson \nplan for a 7th grade robotics class.\n</code></pre>"},{"location":"lessons/01-lesson-order/","title":"Lesson Order","text":""},{"location":"lessons/01-lesson-order/#order-of-lessons-and-concept","title":"Order of Lessons and Concept","text":"<p>This section provides you with sample prompts you can give to any generative AI system.  The first is a general prompt that just returns a list of concepts.  The next prompt is much more detailed and includes exactly the tools you have in your lab.</p>"},{"location":"lessons/01-lesson-order/#sample-general-prompt","title":"Sample General Prompt","text":"<pre><code>You are an expert at teaching MicroPython to high school\nstudents using fun sensors and displays to create fun\nSTEM robots.\n\nList the 100 most important concepts that you would teach\nin your courses.  For each concept, just return the\nname of the concept without any definition. \nReturn the 100 items in the order they should be\ntaught in a class with the simplest first,\nto the most complex at the end of the list.  \n</code></pre>"},{"location":"lessons/01-lesson-order/#chatgpt-response","title":"ChatGPT response","text":"<ol> <li>Introduction to MicroPython</li> <li>Setting Up the Thonny Development Environment</li> <li>Basic Syntax and Variables</li> <li>Data Types</li> <li>Arithmetic Operators</li> <li>Comparison Operators</li> <li>Logical Operators</li> <li>Control Structures: If Statements</li> <li>Control Structures: Else and Elif</li> <li>For Loops</li> <li>While Loops</li> <li>Functions</li> <li>Parameters and Return Values</li> <li>Importing Modules</li> <li>Using Built-in Libraries</li> <li>Working with LEDs</li> <li>Reading Button Inputs</li> <li>Serial Communication Basics</li> <li>Using the REPL</li> <li>Exception Handling</li> <li>Lists</li> <li>Tuples</li> <li>Dictionaries</li> <li>String Manipulation</li> <li>Working with Time and Delays</li> <li>Understanding Analog vs Digital Signals</li> <li>GPIO Pin Basics</li> <li>Pulse Width Modulation (PWM)</li> <li>Reading Analog Sensors</li> <li>Writing to LCD Displays</li> <li>Using I2C Communication</li> <li>Using SPI Communication</li> <li>Handling Interrupts</li> <li>Debouncing Buttons</li> <li>Managing Power Consumption</li> <li>Introduction to Robotics</li> <li>Motor Control Basics</li> <li>Using Servo Motors</li> <li>Using DC Motors</li> <li>Understanding H-Bridge Circuits</li> <li>Using Motor Drivers</li> <li>Reading from Ultrasonic Sensors</li> <li>Using Temperature Sensors</li> <li>Using Light Sensors</li> <li>Using Accelerometers</li> <li>Using Gyroscopes</li> <li>Implementing Serial Protocols</li> <li>Debugging Techniques</li> <li>Introduction to Version Control with Git</li> <li>Project Planning and Design</li> <li>Building a Basic Robot Frame</li> <li>Integrating Sensors and Actuators</li> <li>Using Bluetooth Modules</li> <li>Using Wi-Fi Modules</li> <li>Implementing Bluetooth Communication</li> <li>Implementing Wi-Fi Communication</li> <li>Data Logging Techniques</li> <li>Storing Data on SD Cards</li> <li>Using Real-Time Clocks</li> <li>Implementing Timers</li> <li>PWM for LED Dimming</li> <li>Creating a User Interface</li> <li>Using Touch Sensors</li> <li>Implementing Obstacle Avoidance</li> <li>Line Following Algorithms</li> <li>Introduction to PID Control</li> <li>Using Encoders</li> <li>Implementing Feedback Loops</li> <li>Basics of Machine Learning</li> <li>Creating Autonomous Behaviors</li> <li>Implementing Remote Control</li> <li>Introduction to Speech Recognition</li> <li>Using Camera Modules</li> <li>Basics of Image Processing</li> <li>Integrating Multiple Sensors</li> <li>Power Management for Robots</li> <li>Wireless Charging Basics</li> <li>Safety Practices in Robotics</li> <li>Designing for Modularity</li> <li>Implementing Error Recovery</li> <li>Advanced Data Structures</li> <li>Using Queues and Stacks</li> <li>Multithreading in MicroPython</li> <li>Asynchronous Programming</li> <li>Implementing State Machines</li> <li>Networking Protocols</li> <li>Cloud Integration Basics</li> <li>Using MQTT Protocol</li> <li>Implementing REST APIs</li> <li>Secure Communication Practices</li> <li>Basics of Encryption</li> <li>Advanced Sensor Fusion</li> <li>Path Planning Algorithms</li> <li>Introduction to SLAM (Simultaneous Localization and Mapping)</li> <li>Using GPS Modules</li> <li>Integrating with Mobile Devices</li> <li>Using NFC Modules</li> <li>Implementing Gesture Control</li> <li>Voice Command Integration</li> <li>Advanced AI for Object Recognition</li> </ol>"},{"location":"lessons/01-lesson-order/#stem-robotics-course","title":"STEM Robotics Course","text":"<pre><code>You are an expert at teaching MicroPython to high\nschool students using fun sensors and displays to\ncreate fun STEM robots.  In your lab,\nyou have the following equipment:\n\n1. Computers running the Thonny IDE\n2. Raspberry Pi Picos mounted on breadboards\n3. Basic electronic components (LEDs, resistors, transistors, motors, etc.)\n4. A Smart Car robot chassis with 2 DC motors and a battery pack of 4 AA batteries\n5. The Cytron motor controller board with the RP2040 chip that supports DC motors, servos, I2C, and SPI interfaces\n6. 128x64 OLED displays that use the SPI interface\n7. WS2816 LED strips (neopixels)\n\nList the 100 most important concepts that you would\nteach in your STEM Robots course that puts a focus\non computational thinking.  For each concept,\njust return the name of the concept and a short definition.\nReturn the 100 items in the order they should be taught\nin a class, with the simplest first to the most\ncomplex at the end of the list.\n</code></pre> <ol> <li> <p>Introduction to Robotics     Overview of robotics, course objectives, and the role of robots in STEM.</p> </li> <li> <p>Introduction to MicroPython     Understanding MicroPython and its applications in embedded systems.</p> </li> <li> <p>Setting Up the Development Environment     Installing Thonny IDE and configuring it for Raspberry Pi Pico.</p> </li> <li> <p>Connecting Raspberry Pi Pico to Computer     Physical setup of the Pico with the computer for programming.</p> </li> <li> <p>Basic Syntax and Variables     Learning the fundamental syntax of MicroPython and how to declare variables.</p> </li> <li> <p>Data Types in MicroPython     Exploring different data types such as integers, floats, strings, and booleans.</p> </li> <li> <p>Basic Electronics Principles     Introduction to voltage, current, and basic electronic components.</p> </li> <li> <p>Using a Breadboard     Understanding breadboard layout and how to create simple circuits.</p> </li> <li> <p>Working with LEDs     Connecting and controlling LEDs using the Raspberry Pi Pico.</p> </li> <li> <p>Understanding Resistors     Learning the purpose of resistors and how to calculate resistance values.</p> </li> <li> <p>GPIO Pin Basics     Overview of General Purpose Input/Output pins on the Pico.</p> </li> <li> <p>Digital Input and Output     Reading digital inputs and controlling digital outputs.</p> </li> <li> <p>Using Push Buttons     Connecting and reading input from push buttons.</p> </li> <li> <p>Control Structures: If Statements     Implementing conditional logic in MicroPython.</p> </li> <li> <p>Control Structures: Else and Elif     Expanding conditional logic with else and elif statements.</p> </li> <li> <p>For Loops     Creating loops to execute code multiple times.</p> </li> <li> <p>While Loops     Implementing loops that run based on a condition.</p> </li> <li> <p>Functions in MicroPython     Defining and calling functions to organize code.</p> </li> <li> <p>Parameters and Return Values     Using parameters and return values in functions.</p> </li> <li> <p>Lists in MicroPython     Creating and manipulating lists to store multiple values.</p> </li> <li> <p>String Manipulation     Working with strings, including concatenation and formatting.</p> </li> <li> <p>Basic Arithmetic Operations     Performing arithmetic calculations in code.</p> </li> <li> <p>Using Built-in Libraries     Importing and utilizing MicroPython's built-in libraries.</p> </li> <li> <p>Serial Communication Basics     Understanding serial communication between devices.</p> </li> <li> <p>Using the REPL     Utilizing the Read-Eval-Print Loop for interactive coding.</p> </li> <li> <p>Exception Handling     Managing errors and exceptions in your programs.</p> </li> <li> <p>Introduction to PWM (Pulse Width Modulation)     Understanding PWM and its applications in controlling devices.</p> </li> <li> <p>Controlling LED Brightness with PWM     Using PWM to adjust LED brightness levels.</p> </li> <li> <p>Working with Transistors     Learning how transistors can control larger currents.</p> </li> <li> <p>Introduction to the Cytron Motor Controller     Overview of the Cytron board and its capabilities.</p> </li> <li> <p>Connecting DC Motors     Wiring DC motors to the motor controller and Pico.</p> </li> <li> <p>Basic Motor Control     Writing code to start and stop DC motors.</p> </li> <li> <p>Controlling Motor Speed with PWM     Using PWM to adjust the speed of DC motors.</p> </li> <li> <p>Understanding Motor Direction     Changing the direction of motor rotation.</p> </li> <li> <p>Building a Simple Robot Frame     Assembling the Smart Car chassis with motors and battery pack.</p> </li> <li> <p>Powering the Raspberry Pi Pico     Connecting the battery pack to power the Pico and motors.</p> </li> <li> <p>Using Servo Motors     Connecting and controlling servo motors for precise movements.</p> </li> <li> <p>Introduction to I2C Communication     Understanding the I2C protocol for connecting peripherals.</p> </li> <li> <p>Connecting the OLED Display via SPI     Wiring the 128x64 OLED display using the SPI interface.</p> </li> <li> <p>Displaying Text on OLED     Writing code to show text messages on the OLED screen.</p> </li> <li> <p>Using the WS2816 LED Strips (Neopixels)     Connecting and controlling Neopixel LED strips.</p> </li> <li> <p>Creating LED Animations     Programming dynamic lighting effects on LED strips.</p> </li> <li> <p>Reading Analog Inputs     Using analog sensors to read varying voltage levels.</p> </li> <li> <p>Using Light Sensors     Connecting light sensors and interpreting their data.</p> </li> <li> <p>Using Temperature Sensors     Reading temperature data from connected sensors.</p> </li> <li> <p>Debouncing Buttons     Implementing software techniques to stabilize button inputs.</p> </li> <li> <p>Implementing Timers and Delays     Managing timing in your programs for precise control.</p> </li> <li> <p>Introduction to Dictionaries     Using dictionaries to store key-value pairs of data.</p> </li> <li> <p>Using Tuples     Understanding and utilizing tuples for immutable data.</p> </li> <li> <p>Advanced String Operations     Performing complex manipulations on string data.</p> </li> <li> <p>Storing and Accessing Data with Lists     Managing and accessing data stored in lists.</p> </li> <li> <p>Introduction to the Smart Car Chassis     Detailed overview of the Smart Car components and functionality.</p> </li> <li> <p>Connecting Multiple LEDs     Wiring and controlling multiple LEDs in a circuit.</p> </li> <li> <p>Using the Motor Controller's I2C Interface     Communicating with the motor controller via I2C.</p> </li> <li> <p>Basic Sensor Integration     Connecting simple sensors to the Raspberry Pi Pico.</p> </li> <li> <p>Reading Sensor Data     Collecting and interpreting data from various sensors.</p> </li> <li> <p>Displaying Sensor Data on OLED     Showing real-time sensor information on the OLED display.</p> </li> <li> <p>Using Transistors for Motor Control     Enhancing motor control with transistor circuits.</p> </li> <li> <p>Introduction to PWM for Servo Control     Using PWM signals to precisely control servos.</p> </li> <li> <p>Creating Interactive LED Displays     Programming LEDs to respond to sensor inputs.</p> </li> <li> <p>Implementing Basic Obstacle Avoidance     Using sensors to detect and avoid obstacles.</p> </li> <li> <p>Building a Line-Following Robot     Programming the robot to follow a line using sensors.</p> </li> <li> <p>Introduction to Encoders     Understanding encoders for tracking motor rotation.</p> </li> <li> <p>Implementing Motor Feedback     Using encoder data to control motor movements accurately.</p> </li> <li> <p>Using Accelerometers     Integrating accelerometers to measure movement and orientation.</p> </li> <li> <p>Using Gyroscopes     Adding gyroscopes for detecting rotational motion.</p> </li> <li> <p>Basic Data Logging     Recording sensor data for later analysis.</p> </li> <li> <p>Storing Data on SD Cards     Writing and reading data to/from SD cards.</p> </li> <li> <p>Using Real-Time Clocks (RTC)     Keeping track of time in your projects with RTC modules.</p> </li> <li> <p>Implementing State Machines     Managing complex behaviors using state machines.</p> </li> <li> <p>Introduction to Interrupts     Handling asynchronous events in your programs.</p> </li> <li> <p>Using Queues and Stacks     Managing data flow with queues and stacks.</p> </li> <li> <p>Multithreading in MicroPython     Running multiple threads for concurrent tasks.</p> </li> <li> <p>Asynchronous Programming     Implementing non-blocking code for efficient processing.</p> </li> <li> <p>Introduction to PID Control     Understanding Proportional-Integral-Derivative control for precise movement.</p> </li> <li> <p>Implementing Feedback Loops     Using sensor feedback to adjust motor control dynamically.</p> </li> <li> <p>Basic Networking Concepts     Understanding how devices communicate over networks.</p> </li> <li> <p>Using Bluetooth Modules     Connecting and communicating with Bluetooth devices.</p> </li> <li> <p>Using Wi-Fi Modules     Integrating Wi-Fi for wireless communication and control.</p> </li> <li> <p>Implementing Bluetooth Communication     Setting up Bluetooth to send and receive data.</p> </li> <li> <p>Implementing Wi-Fi Communication     Configuring Wi-Fi for internet connectivity and data exchange.</p> </li> <li> <p>Introduction to Version Control with Git     Managing code versions and collaborating using Git.</p> </li> <li> <p>Project Planning and Design     Planning and designing robotics projects effectively.</p> </li> <li> <p>Integrating Multiple Sensors     Combining data from various sensors for complex behaviors.</p> </li> <li> <p>Advanced Data Structures     Utilizing advanced structures like linked lists and trees.</p> </li> <li> <p>Introduction to Machine Learning     Basics of machine learning and its applications in robotics.</p> </li> <li> <p>Creating Autonomous Behaviors     Programming robots to operate independently without user input.</p> </li> <li> <p>Implementing Remote Control     Controlling the robot remotely via wireless connections.</p> </li> <li> <p>Using Touch Sensors     Integrating touch sensors for interactive control.</p> </li> <li> <p>Implementing Gesture Control     Using sensors to interpret and respond to user gestures.</p> </li> <li> <p>Voice Command Integration     Adding voice recognition to control the robot through speech.</p> </li> <li> <p>Using Camera Modules     Connecting and utilizing camera modules for vision-based tasks.</p> </li> <li> <p>Basics of Image Processing     Processing and interpreting images captured by the camera.</p> </li> <li> <p>Advanced Sensor Fusion     Combining multiple sensor inputs for accurate data interpretation.</p> </li> <li> <p>Path Planning Algorithms     Designing algorithms for efficient navigation and movement paths.</p> </li> <li> <p>Introduction to SLAM (Simultaneous Localization and Mapping)     Enabling robots to build maps and locate themselves within them.</p> </li> <li> <p>Using GPS Modules     Integrating GPS for location tracking and navigation.</p> </li> <li> <p>Integrating with Mobile Devices     Connecting the robot to smartphones or tablets for control and feedback.</p> </li> <li> <p>Using NFC Modules     Adding Near Field Communication for short-range interactions.</p> </li> <li> <p>Advanced AI for Object Recognition     Implementing artificial intelligence techniques to recognize and respond to objects.</p> </li> </ol>"},{"location":"lessons/03-robot-parts/","title":"Robot Parts","text":"<p>What are the key parts of a robot?  In our first lessons we will review the key components of a robot and how they </p>"},{"location":"lessons/03-robot-parts/#batteries","title":"Batteries","text":""},{"location":"lessons/03-robot-parts/#motors","title":"Motors","text":""},{"location":"lessons/03-robot-parts/#sensors","title":"Sensors","text":""},{"location":"lessons/03-robot-parts/#displays","title":"Displays","text":""},{"location":"lessons/03-robot-parts/#microcontrollers","title":"Microcontrollers","text":""},{"location":"lessons/05-batteries/","title":"STEM Robot Batteries","text":"<p>The standard STEM robot kit comes with a battery pack that holds 4 AA batteries.  We will review this strategy and discuss rechargeable options.</p>"},{"location":"lessons/05-batteries/#4-aa-batteries","title":"4 AA Batteries","text":""},{"location":"lessons/05-batteries/#rechargeable-lipo-batteries","title":"Rechargeable LiPo Batteries","text":""},{"location":"lessons/05-batteries/#18650-batteries","title":"18650 Batteries","text":""},{"location":"lessons/07-config-file/","title":"Hardware Configuration File","text":"<p>This file defines all the hardware in a robot and the pin  assignments of the motors, sensors, speakers, and displays.</p> <p>Because most of our robots use the Cytron board, the pins are standardized for most of our kits.</p> <p>Using a configuration file has tradeoffs.  The pros is that it allows you to change a single file when you change the wiring in your robot.  All the example programs that use the config file  will be automatically updated.</p> <p>The disadvantage is that it makes your programs  a little more abstract.  New users will take  some time to learn how to see how the configuration  file is used to map a variable to the underlying  hardware pins.</p> <p>## Sample Config File</p> <p>All of the hardware pins should be defined in this file.</p> <pre><code>NUMBER_PIXELS = 2\nNEOPIXEL_PIN = 18\nSPEAKER_PIN = 22\n</code></pre> <p>Note</p> <p>Make sure there are no spaces in front of the variable names.</p> <p>Now in your main code you must do the following:</p> <ol> <li>Ddd the <code>import config</code> (without the .py)</li> <li>place the string <code>config.</code> in front of each variable.</li> </ol> <p>```python  import config</p> <p># Get the data from the config file NUMBER_PIXELS = config.NUMBER_PIXELS NEOPIXEL_PIN = config.NEOPIXEL_PIN   ```</p> <p>By placing the <code>config</code> in front of the variable name, you   tell the Python interpreter to read the variable from that file.</p>"},{"location":"lessons/07-config-file/#standard-neopixel-blink","title":"Standard NeoPixel Blink","text":"<pre><code>from machine import Pin\nfrom time import sleep\nfrom neopixel import NeoPixel\n\nNUMBER_PIXELS = 8\nNEOPIXEL_PIN = 15\n\nstrip = NeoPixel(Pin(NEOPIXEL_PIN), NUMBER_PIXELS)\n\nwhile True:\n    strip[0] = (255,0,0) # red=255, green and blue are 0\n    strip.write()        # send the data from RAM down the wire\n    sleep(1)             # keep on 1/10 of a second\n    strip[0] = (0,0,0)   # change the RAM back but don't resend the data\n    strip.write()\n    sleep(1)\n</code></pre>"},{"location":"lessons/07-config-file/#blink-using-config-file","title":"Blink Using Config  File","text":""},{"location":"lessons/10-dc-motors/","title":"Lesson Using 6-Volt DC Hobby Motors","text":""},{"location":"lessons/10-dc-motors/#sample-prompt","title":"Sample Prompt","text":"<pre><code>Create a lesson plan using two 6-volt DC hobby\nmotors with wheels for a 5th grade\nclassroom that is interested in building robots.\nAssume you have a battery pack of 3 AA batteries,\nwires, and a glue gun.\n</code></pre>"},{"location":"lessons/10-dc-motors/#sample-response","title":"Sample Response","text":""},{"location":"lessons/10-dc-motors/#lesson-plan-building-a-simple-robot-with-dc-motors","title":"Lesson Plan: Building a Simple Robot with DC Motors","text":""},{"location":"lessons/10-dc-motors/#objective","title":"Objective:","text":"<p>Students will learn about basic electronics and robotics by building a simple robot using DC motors and a battery pack.</p>"},{"location":"lessons/10-dc-motors/#materials","title":"Materials:","text":"<ul> <li>2 DC motors (as shown in the image)</li> <li>1 battery pack for 3 AA batteries</li> <li>3 AA batteries</li> <li>2 wheels (one attached to each motor)</li> <li>Chassis (can be a small plastic container or cardboard)</li> <li>Electrical tape and/or heat shrink tubing</li> <li>Small switch (optional)</li> <li>Connecting wires</li> <li>Hot glue gun and glue sticks</li> <li>Screwdriver</li> <li>Scissors or wire cutters</li> </ul> <p>Duration: About 2 hours</p>"},{"location":"lessons/10-dc-motors/#lesson-steps","title":"Lesson Steps:","text":"<p>1. Introduction to DC Motors and Robotics (15 minutes)</p> <ul> <li>Explain what a DC motor is and how it works.</li> <li>Discuss how robots use motors to move.</li> <li>Show examples of simple robots (videos or images).</li> </ul> <p>2. Safety Briefing (5 minutes)</p> <ul> <li>Explain the importance of safety when working with batteries and hot glue.</li> <li>Demonstrate how to safely use the hot glue gun.</li> </ul> <p>3. Building the Robot (90 minutes)</p>"},{"location":"lessons/10-dc-motors/#step-1-prepare-the-motors","title":"Step 1: Prepare the Motors","text":"<ul> <li>Attach a wheel to each motor securely.</li> <li>Connect wires to the motor terminals if not already connected. Red wire to one terminal and black (or blue) to the other.</li> </ul>"},{"location":"lessons/10-dc-motors/#step-2-construct-the-chassis","title":"Step 2: Construct the Chassis","text":"<ul> <li>Use a small plastic container or piece of cardboard as the base.</li> <li>Attach the motors to the bottom of the chassis using hot glue, making sure the wheels can rotate freely.</li> </ul>"},{"location":"lessons/10-dc-motors/#step-3-connect-the-motors-to-the-battery-pack","title":"Step 3: Connect the Motors to the Battery Pack","text":"<ul> <li>Attach the battery pack to the top of the chassis using hot glue or tape.</li> <li>Connect the red wire from each motor to the red wire from the battery pack.</li> <li>Connect the black wire from each motor to the black wire from the battery pack.</li> <li>Optionally, include a switch between the battery pack and the motors to turn the robot on and off.</li> </ul>"},{"location":"lessons/10-dc-motors/#step-4-test-the-robot","title":"Step 4: Test the Robot","text":"<ul> <li>Insert the AA batteries into the battery pack.</li> <li>Turn on the switch (if included) and observe the robot move.</li> <li>If the robot doesn't move, check the connections and ensure the batteries are inserted correctly.</li> </ul>"},{"location":"lessons/10-dc-motors/#step-5-customize-the-robot","title":"Step 5: Customize the Robot","text":"<ul> <li>Allow students to decorate their robots with markers, stickers, or other craft supplies.</li> <li>Encourage students to experiment with different chassis designs and motor placements.</li> </ul>"},{"location":"lessons/10-dc-motors/#wrap-up-and-discussion-10-minutes","title":"Wrap-Up and Discussion (10 minutes)**","text":"<ul> <li>Ask students to share their experiences building the robot.</li> <li>Discuss what they learned about motors and robotics.</li> <li>Talk about potential improvements and modifications they could make to their robots.</li> </ul> <p>5. Clean-Up (10 minutes)</p> <ul> <li>Ensure all materials are put away properly.</li> <li>Make sure the classroom is tidy and free of any hazards.</li> </ul>"},{"location":"lessons/10-dc-motors/#additional-resources","title":"Additional Resources:","text":"<ul> <li>Provide links to simple robotics projects and tutorials.</li> <li>Suggest books or websites for further reading on robotics and electronics.</li> </ul>"},{"location":"lessons/10-dc-motors/#assessment","title":"Assessment:","text":"<ul> <li>Observe students during the activity to ensure they are following instructions and working safely.</li> <li>Assess the functionality of each student's robot.</li> <li>Encourage students to explain how their robot works and what they learned from the activity.</li> </ul> <p>This lesson plan aims to provide a hands-on, engaging introduction to robotics and electronics, suitable for 5th-grade students.</p>"},{"location":"lessons/15-motor-direction/","title":"Motor Direction Lab","text":"<p>In this lesson, we want to make a motor go both forward and reverse.</p> <p>For an example simulation, see the H-Bridge Simulation.</p>"},{"location":"lessons/15-motor-direction/#sample-prompt","title":"Sample Prompt","text":"<pre><code>Create a lesson plan for a 5th grade class that is interested in\nlearning how to make a robot move forward and backward.\nAssume the students have access to a 6-volt DC hobby motors,\nwheels, switches, and a battery pack with 3 AA batteries.\nGenerate a lesson plan that will get the students to learn how to connect\nthe battery so that the motors go forward or reverse.\n</code></pre>"},{"location":"lessons/15-motor-direction/#lesson-plan-making-a-robot-move-forward-and-backward","title":"Lesson Plan: Making a Robot Move Forward and Backward","text":""},{"location":"lessons/15-motor-direction/#objective","title":"Objective:","text":"<p>By the end of the lesson, students will understand the basics of connecting a battery to motors to make a robot move forward and backward.</p>"},{"location":"lessons/15-motor-direction/#materials","title":"Materials:","text":"<ul> <li>6-volt DC hobby motors</li> <li>Wheels compatible with the motors</li> <li>Switches (DPDT or SPDT)</li> <li>Battery pack with 3 AA batteries</li> <li>Connecting wires</li> <li>Screwdrivers</li> <li>Electrical tape</li> <li>Small robot chassis (optional)</li> <li>Whiteboard and markers</li> <li>Handouts with circuit diagrams and instructions</li> </ul> <p>Duration: 1 hour</p>"},{"location":"lessons/15-motor-direction/#lesson-breakdown","title":"Lesson Breakdown:","text":""},{"location":"lessons/15-motor-direction/#introduction-10-minutes","title":"Introduction (10 minutes)","text":""},{"location":"lessons/15-motor-direction/#greeting-and-introduction","title":"Greeting and Introduction","text":"<ul> <li>Welcome the students and introduce the topic: \"Today, we will learn how to make a simple robot move forward and backward using motors, switches, and a battery pack.\"</li> <li>Briefly explain what each component does: motors convert electrical energy into motion, switches control the direction, and the battery pack provides power.</li> </ul>"},{"location":"lessons/15-motor-direction/#explanation-and-demonstration-15-minutes","title":"Explanation and Demonstration (15 minutes)","text":"<ol> <li> <p>Basic Circuit Concepts</p> </li> <li> <p>Explain the basic concept of an electrical circuit.</p> </li> <li> <p>Show how connecting the battery pack to the motor makes it spin.</p> </li> <li> <p>Direction Control with Switches</p> </li> <li> <p>Explain how switches can change the direction of the motor.</p> </li> <li>Demonstrate using a Double Pole Double Throw (DPDT) switch or a Single Pole Double Throw (SPDT) switch.</li> </ol>"},{"location":"lessons/15-motor-direction/#hands-on-activity-30-minutes","title":"Hands-On Activity (30 minutes)","text":"<ol> <li> <p>Building the Circuit</p> </li> <li> <p>Divide the students into small groups and distribute the materials.</p> </li> <li> <p>Provide step-by-step instructions on how to connect the components:</p> </li> <li> <p>Connecting the Motors and Wheels:</p> <ul> <li>Attach the wheels to the motors.</li> </ul> </li> <li>Connecting the Battery Pack:<ul> <li>Connect the battery pack to the motor terminals using connecting wires.</li> </ul> </li> <li>Adding the Switch:<ul> <li>Connect the switch between the battery pack and the motors.</li> <li>Show how flipping the switch changes the motor's direction, making the robot move forward or backward.</li> </ul> </li> </ol>"},{"location":"lessons/15-motor-direction/#testing-and-troubleshooting","title":"Testing and Troubleshooting","text":"<ul> <li>Allow students to test their connections.</li> <li>Encourage them to troubleshoot and correct any issues, such as loose connections or incorrect wiring.</li> <li>Walk around the room to assist and answer questions.</li> </ul>"},{"location":"lessons/15-motor-direction/#conclusion-5-minutes","title":"Conclusion (5 minutes)","text":"<ol> <li> <p>Review and Reflect</p> <ul> <li>Recap the key points: how to connect the battery to the motors, how switches control the direction, and the importance of secure connections.</li> <li>Ask students to share what they learned and any challenges they faced.</li> </ul> </li> <li> <p>Preview of Next Lesson</p> </li> <li> <p>Briefly introduce what they will learn next (e.g., changing motor speed, adding more controls, using sensors, programming the robot).</p> </li> </ol>"},{"location":"lessons/15-motor-direction/#handouts","title":"Handouts:","text":"<ul> <li>Simple circuit diagram showing the battery pack, motors, and switch connections.</li> <li>Step-by-step instructions with illustrations.</li> <li>Troubleshooting tips.</li> </ul> <p>This lesson plan should help 5th graders understand the basics of building a simple robot and controlling its movement.</p>"},{"location":"lessons/15-motor-direction/#h-bridge","title":"H-Bridge","text":""},{"location":"lessons/15-motor-direction/#lesson-plan-using-an-h-bridge-circuit-to-change-motor-direction","title":"Lesson Plan: Using an H-Bridge Circuit to Change Motor Direction","text":""},{"location":"lessons/15-motor-direction/#objective_1","title":"Objective:","text":"<p>By the end of the lesson, students will understand how to use  an H-Bridge circuit with four Single Pole Single Throw (SPST) switches to change the direction of a motor.</p>"},{"location":"lessons/15-motor-direction/#materials_1","title":"Materials:","text":"<ul> <li>Web-based simulation of the H-Bridge circuit</li> <li>Computers with internet access</li> <li>Whiteboard and markers</li> <li>Handouts with H-Bridge circuit diagrams and instructions</li> </ul> <p>Duration: 1 hour</p>"},{"location":"lessons/15-motor-direction/#lesson-breakdown_1","title":"Lesson Breakdown:","text":""},{"location":"lessons/15-motor-direction/#introduction-10-minutes_1","title":"Introduction (10 minutes)","text":"<ol> <li>Greeting and Introduction<ul> <li>Welcome the students and introduce the topic: \"Today, we will learn how to use an H-Bridge circuit to control the direction of a motor using four SPST switches.\"</li> <li>Explain what an H-Bridge is and its importance in controlling motor direction.</li> </ul> </li> </ol>"},{"location":"lessons/15-motor-direction/#explanation-and-demonstration-15-minutes_1","title":"Explanation and Demonstration (15 minutes)","text":"<ol> <li> <p>Basic Concept of H-Bridge</p> </li> <li> <p>Explain the basic concept of an H-Bridge circuit: it allows a voltage to be applied across a load in either direction.</p> </li> <li> <p>Draw the H-Bridge diagram on the whiteboard and label each part: four switches (S1, S2, S3, S4), motor (M), and power source (V).</p> </li> <li> <p>How H-Bridge Works</p> <ul> <li>Explain the different states of the switches to change the motor direction:<ul> <li>Forward: S1 and S4 are closed, S2 and S3 are open.</li> <li>Reverse: S2 and S3 are closed, S1 and S4 are open.</li> <li>Stop: All switches are open or opposing switches are closed (S1 and S2 or S3 and S4).</li> </ul> </li> <li>Demonstrate these states using the web-based simulation.</li> </ul> </li> </ol>"},{"location":"lessons/15-motor-direction/#hands-on-activity-30-minutes_1","title":"Hands-On Activity (30 minutes)","text":"<ol> <li> <p>Setting Up the Simulation</p> </li> <li> <p>Guide students to open the web-based simulation tool on their computers.</p> </li> <li> <p>Provide step-by-step instructions to set up the H-Bridge circuit in the simulation:</p> <ol> <li>Creating the Circuit:<ul> <li>Place the motor, power source, and four SPST switches in the simulation.</li> </ul> </li> <li>Wiring the Circuit:<ul> <li>Connect the components to form an H-Bridge circuit as shown in the diagram.</li> </ul> </li> <li>Testing the Circuit:<ul> <li>Simulate closing different combinations of switches to see how the motor direction changes.</li> </ul> </li> </ol> </li> <li> <p>Exploration and Experimentation:</p> </li> <li> <p>Allow students to experiment with the circuit in the simulation.</p> </li> <li>Encourage them to try different combinations of switch states and observe the motor's behavior.</li> <li>Walk around the room to assist and answer questions.</li> </ol>"},{"location":"lessons/15-motor-direction/#conclusion-5-minutes_1","title":"Conclusion (5 minutes)","text":"<ol> <li> <p>Review and Reflect</p> </li> <li> <p>Recap the key points: how an H-Bridge circuit works, the role of SPST switches, and how to control motor direction.</p> </li> <li> <p>Ask students to share their observations and any challenges they faced during the simulation.</p> </li> <li> <p>Preview of Next Lesson</p> </li> <li> <p>Briefly introduce what they will learn next lesson.  Discuss the need to control both the direction and speed of a motor.</p> </li> </ol>"},{"location":"lessons/15-motor-direction/#handouts_1","title":"Handouts:","text":"<ul> <li>H-Bridge circuit diagram showing the motor, power source, and four SPST switches or a single DPDT switch.</li> <li>Step-by-step instructions with illustrations for setting up the circuit in the simulation.</li> <li>Troubleshooting tips for common issues in the simulation.</li> </ul> <p>This lesson plan should help 5th graders understand the concept and application of an H-Bridge circuit for motor control using simulations.</p>"},{"location":"lessons/16-h-bridge/","title":"H-Bridge Lab","text":"<p>The H-bridge circuit allows us to make a motor turn in opposite directions if we close opposite switches.  To make the motor move one direction we close the upper left (Switch 1) and the lower right (Switch 4) switches.  To make the motor move in the opposite direction we close the lower left (Switch 2) and upper right (Switch 3) switches.</p> <p>It is called an \"H\" bridge because the circuit forms the shape of the letter \"H\".</p> <p></p> <p>In the figure above:</p> <ol> <li>To move forward, close switches 1 and 4</li> <li>To move in reverse, close switches 2 and 3</li> </ol> <p>This circuit can also be demonstrated by using a single double-pole, double throw switch.</p> <p></p>"},{"location":"lessons/20-motor-speed/","title":"Controlling Motor Speed","text":""},{"location":"lessons/20-motor-speed/#battery-voltage","title":"Battery Voltage","text":""},{"location":"lessons/20-motor-speed/#adjusting-a-potentiometer","title":"Adjusting a Potentiometer","text":""},{"location":"lessons/25-pwm/","title":"Pulse Width Modulation Lab","text":""},{"location":"lessons/30-testing-motor-connections/","title":"Testing Motor Connections","text":""},{"location":"lessons/35-dance/","title":"Making Your Robot Dance","text":""},{"location":"lessons/40-i2c-bus/","title":"The I2C Bus","text":""},{"location":"lessons/40-i2c-bus/#the-i2c-scanner","title":"The I2C Scanner","text":""},{"location":"lessons/40-i2c-bus/#testing-for-your-sensor","title":"Testing For Your Sensor","text":""},{"location":"lessons/45-sensors/","title":"Sensors","text":"<ol> <li>Bump sensors - microswitches</li> <li>IR Sensors - Infrared distance sensors</li> <li>Ultrasonic Sensors - using sound to measure distance</li> <li>Time of Flight Sensors - our favorite sensor</li> <li>LIDAR - high end sensors for moving robots</li> </ol>"},{"location":"lessons/50-tof-sensors/","title":"The Time of Flight Sensor","text":"<p>In this lab, we will learn how to use a powerful low-cost Time-of-Flight sensor.</p>"},{"location":"lessons/60-ir-sensors/","title":"IR Distance Sensors","text":""},{"location":"lessons/70-using-perf-boards/","title":"Using Perfboards in Beginning Electronics Classes","text":""},{"location":"lessons/70-using-perf-boards/#sample-prompt","title":"Sample Prompt","text":"<p>``` prompt \"Prompt Text\"     Create a five-page tutorial on using perf boards for a junior high school student.     Return the tutorial using a single Markdown file using the following outline:</p> <pre><code># Using Perfboards in Beginning Electronics Classes\n## What is a PerfBoard\n## Different Types of PerfBoards\n## When to use a PerfBoard vs. Solderless Breadboard\n\nSuggest various photos to use when appropriate.  For each photo, give a detailed description of the photo.\n\nYou can assume the following photos are available:\n\n1. A photo of a perfboard for sale on e-bay\n2. A photo showing the different types of perfboards\n\nInclude a list of supplies like solder, wire etc.\n</code></pre> <p>This tutorial is designed to introduce junior high school students to the basics of using perfboards in electronics projects. In it, we will discuss what a perfboard is, explain different types of perfboards, and help you understand when you should use a perfboard instead of a solderless breadboard. By the end of this tutorial, you should feel comfortable choosing and using a perfboard for your own electronic creations.</p> <p>Note: Perfboards are sometimes called \u201cprotoboards\u201d and come in many varieties. The skills you learn here will be useful no matter which type you use.</p>"},{"location":"lessons/70-using-perf-boards/#what-is-a-perfboard","title":"What is a PerfBoard","text":"<p>A perfboard is a flat board made of a rigid material (often fiberglass or phenolic) that is perforated with a grid of evenly spaced holes. These holes are usually spaced about 0.1 inches (2.54 mm) apart. Each hole is surrounded by a small copper pad (a little ring of copper) on one side of the board. You can insert electronic components such as resistors, LEDs, capacitors, integrated circuits, and wires through these holes, and then solder the component leads on the other side. This creates a permanent (or semi-permanent) connection between components.</p> <p>Perfboards are commonly used when you move beyond the initial planning and experimentation stage of your project. After you\u2019ve tested a circuit on a solderless breadboard, a perfboard lets you solder it all together into a more stable and durable form. While not as fancy or as permanent as a fully designed printed circuit board (PCB), a perfboard is a great stepping stone that helps turn your prototype into a more reliable device.</p> <p>Suggested Photo: - Photo of a perfboard for sale on e-bay: Show a standard rectangular perfboard with regularly spaced holes and copper pads visible on one side. The photo would likely be a close-up image focusing on the uniform grid of holes, clearly showing the copper pads around them. This will give a good idea of the material, size, and typical appearance of a basic perfboard.</p>"},{"location":"lessons/70-using-perf-boards/#different-types-of-perfboards","title":"Different Types of PerfBoards","text":"<p>Perfboards are not all the same. You can find different types that vary in size, material, and how their copper pads are arranged.</p> <ol> <li> <p>Basic Single-Sided Perfboards:    These have copper pads on one side only. Each hole has its own separate copper pad. This is the most common and straightforward type. You must connect pads together by soldering wires, component leads, or by using small pieces of wire to bridge connections between holes.</p> </li> <li> <p>Stripboard (Veroboard):    Similar to a perfboard but with rows (or strips) of copper pads connected together. Instead of each pad being isolated, a stripboard\u2019s holes are arranged along copper tracks. These tracks can be cut if needed. Stripboards make it easier to create rows of connected pads, reducing the amount of wiring you need.</p> </li> <li> <p>Double-Sided Perfboards:    These have copper pads on both sides of the board. Double-sided boards make it possible to connect circuits on either side and sometimes simplify more complicated projects because you can route connections more easily.</p> </li> <li> <p>Pre-Soldered Protoboards with Buses:    Some perfboards come with pre-connected power rails or \u201cbuses\u201d to make it easier to provide power (e.g., 5V or ground) to all your components. This can reduce the amount of wiring you do for the common connections.</p> </li> </ol> <p>Suggested Photo: - Photo showing different types of perfboards: A photo with multiple perfboards laid out side-by-side. Include a basic single-sided perfboard, a stripboard, and a double-sided perfboard. The image might show them at an angle so the viewer can see the copper pads and strips. Perhaps labels or captions in the image help identify each type. It might also show some boards partially populated with a few components so that students can see how they\u2019re used.</p>"},{"location":"lessons/70-using-perf-boards/#when-to-use-a-perfboard-vs-solderless-breadboard","title":"When to Use a PerfBoard vs. Solderless Breadboard","text":"<p>Solderless breadboards are great tools for beginners. They let you quickly build and change circuits without any soldering. Perfect for experiments and for making sure your design is correct before you commit to soldering.</p> <p>Perfboards, on the other hand, require soldering. That\u2019s a more advanced skill, but once you\u2019ve tested your circuit and you\u2019re confident it\u2019s correct, moving it to a perfboard is a natural next step. Consider the following points:</p> <ul> <li>Use a Solderless Breadboard: </li> <li>When you\u2019re designing a new circuit and not sure if it will work.  </li> <li>If you want to quickly rearrange components and test new ideas.  </li> <li> <p>In a classroom setting where you want to focus on understanding circuit theory before worrying about soldering technique.</p> </li> <li> <p>Use a PerfBoard: </p> </li> <li>After you\u2019ve tested your circuit on a breadboard and know it works well.  </li> <li>When you\u2019re ready to make your circuit more reliable and long-lasting.  </li> <li>If you\u2019re creating a project you want to keep and show off rather than just experiment with.</li> </ul> <p>By thinking of a perfboard as a \u201cnext step\u201d after breadboards, you\u2019re moving along the path from concept to a more permanent, usable device.</p>"},{"location":"lessons/70-using-perf-boards/#how-to-use-a-perfboard","title":"How to Use a PerfBoard","text":"<ol> <li> <p>Plan Your Layout:    Before you start soldering, draw out where each component will go. Think about where your power and ground lines should run, and how your signal paths should flow. Good planning makes soldering much simpler.</p> </li> <li> <p>Place Your Components on the Board:    Insert the leads of your resistors, capacitors, IC sockets, or other components through the holes. Make sure to align integrated circuits so their notch or marking is oriented correctly. Keep similar parts grouped together to reduce confusion.</p> </li> <li> <p>Solder the Connections:    Once components are placed, flip the board over to the copper pad side. Heat the pad and the component lead with your soldering iron, then apply a small amount of solder. The solder should flow nicely around the pad and the lead. Avoid using too much solder, as you could create solder bridges (unwanted connections between pads).</p> </li> <li> <p>Add Wires for Additional Connections:    If certain pads need to be connected, solder in small pieces of wire between them. Pre-cut wire \u201cjumpers\u201d or stripped solid-core wire pieces work best. Keep your connections neat to avoid confusion.</p> </li> <li> <p>Check Your Work:    After soldering, double-check your connections against your circuit diagram. Make sure there are no accidental shorts and that each component is correctly placed. Use a magnifying glass if needed.</p> </li> </ol>"},{"location":"lessons/70-using-perf-boards/#useful-tips-supplies-and-tools","title":"Useful Tips, Supplies, and Tools","text":"<p>Tips: - Start with a simple circuit you already understand well. - Keep track of the polarity of components like electrolytic capacitors and LEDs. - Practice soldering on a spare perfboard first to build your confidence. - Use color-coded wires (e.g., red for power, black for ground) to keep your circuit organized.  </p> <p>Basic Supplies: - PerfBoard: A medium-sized, single-sided perfboard for your first project. - Soldering Iron: A low-wattage (around 25-40 watts) soldering iron with a fine tip is perfect for beginners. - Solder: Thin solder (e.g., rosin core 60/40) works well and melts easily. - Wire: Solid-core hookup wire for making connections on the perfboard and flexible stranded wire for external leads. - Components: Resistors, LEDs, capacitors, integrated circuits, switches, and any other parts for your project. - Wire Strippers and Cutters: To prepare your wires before soldering. - Needle-Nose Pliers: Helps in bending component leads and holding small parts in place. - Multimeter: Useful for checking continuity and verifying that connections are correct.</p> <p>With these tools and knowledge, you\u2019re ready to move beyond the breadboard stage. Experiment, have fun, and remember that practice makes perfect!</p>"},{"location":"lessons/70-using-perf-boards/#references","title":"References","text":"<p>Using Perf Boards on Instructables</p>"},{"location":"prompts/","title":"STEM Robotics Prompts","text":""},{"location":"setup/","title":"STEM Robots","text":""},{"location":"setup/05-thonny-installation/","title":"Thonny Setup","text":""},{"location":"setup/10-base-kit-assembly/","title":"Base Kit Assembly","text":""},{"location":"setup/10-base-kit-assembly/#assembling-your-maker-pi-rp2040-robot","title":"Assembling Your Maker Pi RP2040 Robot","text":"<p>This kit is a $25 robot kit that we will use in our CoderDojo robotics classes.  This kit includes:</p> <ol> <li>A SmartCar Chassis<ol> <li>Two 3 to 6-volt DC geared hobby motors and wheels</li> <li>Plexiglass (acrylic) main-board</li> <li>Screws and nuts</li> <li>4 AA battery pack</li> <li>Power switch</li> </ol> </li> <li>Cytron Maker Pi RP2040 kit<ol> <li>Maker Pi RP2040 board</li> <li>4x Grove to female header cables</li> <li>Screwdriver</li> <li>Silicone rubber feet (pack of 4)</li> </ol> </li> <li>Ultrasonic sensor<ol> <li>mounting bracket</li> <li>2 M2 6mm screws and nuts</li> </ol> </li> </ol> <p>You will need to provide 4 AA batteries and a Micro USB connector that works with your PC or Mac.</p>"},{"location":"setup/10-base-kit-assembly/#assemble-the-smartcar-chassis","title":"Assemble the SmartCar Chassis","text":"<p>Robot configured with Time-of-Flight distance sensor.</p> <p></p> <p>Here is the bottom view of the robot with the batteries mounted on the bottom. </p> <p>In this version of the kit, the wires are pre-soldered onto the motors.</p>"},{"location":"setup/10-base-kit-assembly/#parts-in-packages","title":"Parts in Packages","text":"<p>Here is the robot kit in all the packaging: </p>"},{"location":"setup/10-base-kit-assembly/#parts-check","title":"Parts Check","text":"<p>Your first task is to remove the protective backing from the Plexiglass body. </p> <p>Here are all the parts removed from the packaging: </p>"},{"location":"setup/10-base-kit-assembly/#exploded-view","title":"Exploded View","text":"<p>Here is an exploded view showing how the motors are connected: </p>"},{"location":"setup/10-base-kit-assembly/#wires-on-motors","title":"Wires on Motors","text":"<p>We mount the motors with the wires on the inside and the heads of the bolts on the outside. </p> <p>This photo shows cable ties I have added so that the wires don't get pulled out by our students.  These cable ties are optional.</p> <p></p>"},{"location":"setup/10-base-kit-assembly/#battery-pack-on-bottom","title":"Battery Pack on Bottom","text":"<p>We like to mount the battery pack on the bottom.  This leaves more room on the top for customization and a breadboard.</p> <p>Next, we position the battery pack on the BOTTOM so  that we have more room on the top for our circuit board,  sensors and add-on displays.</p> <p>The rear of the robot with battery pack mounted.</p> <p></p> <p></p> <p></p>"},{"location":"setup/10-base-kit-assembly/#mounting-the-drag-wheel","title":"Mounting the Drag Wheel","text":"<p>Next, we put the four screws and spacers in the four holes at the  bottom rear of the robot directly behind the battery pack.</p> <p>We then add the four screws to mount the drag wheel.</p> <p>Standoffs</p> <p></p> <p>Drag Wheel on Standoffs</p> <p></p> <p>Next, line up the printed circuit board with the USB connector facing the rear.  Note where the holes are in the board and drill two 1/8\" holes to mount the board.</p> <p></p> <p>I used a 1/8th inch drill bit to put holes where the battery pack should be mounted.</p> <p>Next, I put the flat-head screws in the battery pack.  We want to make sure the top of the screw is all the way in so that it does not get in the way of the battery.</p>"},{"location":"setup/10-base-kit-assembly/#optional-power-switch","title":"Optional Power Switch","text":"<p>The Cytron board has its own power switch.  So this switch does not need to be used.</p> <p></p>"},{"location":"setup/10-base-kit-assembly/#mounting-cytron-board","title":"Mounting Cytron Board","text":"<p>Next, we mount the rubber feet on the bottom of the Maker Pi RP2040 circuit board so that we have some space between the PC board and the main chassis.  I use the space next to the four corners to mount the feet.  Note that we must put the drag wheel on before we put the PC board on top of the chassis.</p> <p>Now is a good time to check the spacing of the battery pack and the read drag wheel.  The rear drag wheel must be able to spin freely in a full circle without bumping into the battery.  If it bumps you might need to remount the battery pack before you proceed to the next step.</p> <p>This figure has the switch that comes with the battery pack.  For our work, we will not need this switch since the Maker Pi RP2040 circuit board has an no-board power switch.  Most of our students put the switch in if they ever need to change circuit boards that don't have a built-in power switch.  If you do this, you can solder the switch between the red power of the battery and the positive terminal of VIN.</p> <p>This photo shows the holes drilled with the screws in them.</p> <p>This is the side view from the rear of the screws holding on the circuit board. </p> <p>Next use two 6 mm M3 screws to mount the ultrasonic distance sensor on top front of the robot.</p> <p>Some of our students like to mount the ultrasonic sensor under the chassis and point the sensor up a little so the sensor does not reflect off the floor.  You can use a heat gun to soften the plastic mount to change the angle.</p> <p>Next, I added a drop of hot glue under the front screws that mount the pc board.  I did this because the battery pack and motor mounts get in the way of adding a nut under the board.</p> <p>I used a small rubber-coated twist tie to keep the wires under the robot away from the wheels and battery.  We don't want them to drag on the floor.</p> <p>Next, we connect the motors to the screw headers on the printed circuit board.  There is a screwdriver that comes with the Cytron Maker Pi RP2040 that is handy for tightening the screws.</p> <p>Don't worry about getting the connections all correct.  They can be adjusted in your software.</p> <p>Press the wheels on the motors.</p> <p>Lastly, we connect the battery to the VIN jumper, making sure to connect the red wire to the \"+\" terminal and the black wire to the \"-\" terminal.</p> <p>Connect the Maker Pi RP2040 board to the top with the USB connector facing the rear.</p> <p>Next, we put the four screws and spacers in the four holes at the  bottom rear of the robot directly behind the battery pack.</p>"},{"location":"setup/10-base-kit-assembly/#motor-and-power-connections","title":"Motor and Power Connections","text":"<p>Connections of the two DC motors and 4AA battery pack: </p> <p>LiPi battery connection: </p>"},{"location":"setup/10-base-kit-assembly/#wire-management","title":"Wire Management","text":"<p>We then add the four screws to mount the drag wheel.</p> <p>Here is a short video of the assembly of a SmartCar Chassis.  Note that this video puts the battery on the top, where we put it on the bottom.</p> <p>There are many videos online how to assemble to motors to the chassis.  The trick is orienting the motors correctly and making sure the bolts don't get in the way of the wheels.</p>"},{"location":"setup/20-parts-list/","title":"Purchasing Your Own Parts","text":"<p>Many schools have received sample kits from our programs. But you can buy your own parts and assemble your own kits.</p>"},{"location":"setup/20-parts-list/#2wd-smart-car-kit","title":"2WD \"Smart Car\" Kit","text":"<p>There are many \"Smart Car\" kits available online retailers such as eBay, Amazon and Walmart. Purchasing these kits in quantity 10 or more can help you save on shipping costs.</p> <p>Note that these kits often come with two black circular wheel encoders.  We do not use these parts and they can be discarded.  We also do not use the power switch since the Cytron board has its own power switch.</p> <p>Our preferred vendor is the Cytron 2WD Smart Robot Car Chassis at $4.80.</p> <p>We like the Cytron kit because the motors come with the wires soldered in place.  We also use a small cable tie to keep the wires from breaking off.  These kits frequently come with a small screwdriver for tightening the screws.</p> <p>Note that the prices for these kits vary widely, so be careful what you purchase.</p>"},{"location":"setup/20-parts-list/#cytron-motor-control-board","title":"Cytron Motor Control Board","text":"<p>There are many robotics controllers available that can be programmed with MicroPython. But the one from Cytron stands out as having all the features we need for our STEM Robot, and at $12.00 it is a great value.</p> <p>Our Review of the Cytron Maker Pi RP2040 Board on Medium</p> <p>Cytron Maker Pi RP2040 Board</p> <ol> <li>Powered by Raspberry Pi RP2040 MicroController<ol> <li>Dual-core Arm Cortex-M0+ processor</li> <li>264KB internal RAM</li> <li>2MB of Flash memory</li> </ol> </li> <li>4x Servo motors</li> <li>2x DC motors with quick test buttons</li> <li>Versatile power circuit</li> <li>Automatic power selection: USB 5V, LiPo (1-cell) or Vin (3.6-6V)</li> <li>Built-in 1-cell LiPo/Li-Ion charger (over-charged &amp; over-discharged protection)</li> <li>Power on/off switch</li> <li>13x Status indicator LEDs for GPIO pins</li> <li>1x Piezo buzzer with mute switch</li> <li>2x Push button</li> <li>2x RGB LED (Neopixel Compatible)</li> <li>7x Grove ports (flexible I/O options: digital, analog, I2C, SPI, UART...)</li> <li>6x M3 screw hole</li> </ol> <p>The Cytron board comes with a screwdriver and four rubber mounting tabs.</p>"},{"location":"setup/20-parts-list/#cytron","title":"Cytron","text":"<p>Cytron Maker Pi RP2040</p>"},{"location":"setup/20-parts-list/#digikey","title":"Digikey","text":"<p>Maker Pi RP2040 Board - listed for $11</p>"},{"location":"setup/20-parts-list/#adafruit","title":"Adafruit","text":"<p>Adafruit $14.90</p>"},{"location":"setup/20-parts-list/#time-of-flight-distance-sensor","title":"Time of Flight Distance Sensor","text":"<p>VL53L0X Time-of-Flight Laser Ranging Module IR Distance Sensor</p> <p>The VL53L0X is a low-cost ($5) time-of-flight light-based distance sensor that is easy to use. It comes packaged in an I2C board and gives precise distance measurements up to 1.5 meters away. It measures the time that light pulses take to travel to an object and back to estimate distance. Light travels about 1 foot every nanosecond, so the timing inside this little chip must be very accurate.</p> <p>The VL53L0X integrates a group of Single Photon Avalanche Diodes (SPAD) and embeds ST Electronic's second generation FlightSense\u2122 patented technology. The VL53L0X\u2019s 940 nm emitter Vertical Cavity Surface-Emitting Laser (VCSEL), is safe for kids and totally invisible to the human eye. Coupled with internal physical infrared filters, the sensor enables longer-ranging distances, higher immunity to ambient light, and better robustness to cover glass optical crosstalk.</p> <p>Review and 3D Printed Mount</p>"},{"location":"setup/20-parts-list/#m3-bolts-and-nuts","title":"M3 Bolts and Nuts","text":"<p>We use M3 metric screws for mounting the Cytron board to the back of the chassis and mounting the time-of-flight sensor to the front of the robot.  We use 4x 10 mm screws on the Cytron board and 2x 6mm screws for the time-fight sensor.</p> <p>eBay M3 pan head bolts</p> <p>M3 STAINLESS HEX FULL NUTS QTY 100 PACK $6 US</p>"},{"location":"setup/30-tof-sensor/","title":"Time of Flight Distance Sensor","text":""},{"location":"sims/collision-avoidance/","title":"Collision Avoidance Robot","text":"![Image Name](./collision-avoidance-robot.png){ width=\"400\" }    Collision Avoidance Robot <p>Link to Collision Avoidance Demo</p> <p>Edit MicroSim</p>"},{"location":"sims/collision-avoidance/#sample-prompt","title":"Sample Prompt","text":"<pre><code>Create a p5.js simulation of a collision avoidance robot on a 400x400 canvas.\nThe robot moves in a circle of radius 200 which is centered in the canvas.\nThe robot is drawn as blue filled rectangle 40x40 with a 20 long red line\npointing at the front.\nThe robot has four modes: stopped, forward, backing up a turning.\nThere are three buttons at the bottom of the drawing region: Start, Stop\nand Reset.\nThe initial state is stopped.  Place the robot in the center facing right.\nWhen the user presses Start the robot goes into forward mode.\nWhen the robot comes within 20 of the edge of the circle it will\nbackup 20 and then turn.\nThe turn will be 120 degrees either right or left.\nAfter the robot turns it will then go forward.\nWhen the user presses Stop the mode will be stopped.\nWhen the user presses Reset the robot will be placed stopped\nat the center of the canvas.\n</code></pre>"},{"location":"sims/h-bridge/","title":"H-Bridge Circuit","text":"<p>An H-bridge circuit is four switches around a motor in the shape of the letter \"H\". The motor is at the center of the letter \"H\". When the upper-left and lower-right switches are closed, the motor spins one direction. When the lower-left and upper-right switches are closed, the motor spins in the opposite direction.</p> <p></p> <p>H-Bridge Demo</p> <pre><code>Generate a single p5.js sketch file.\n\nDraw an H-bridge circuit for reversing the direction of a DC motor.\n\nHave three state buttons for \"Forward\", \"Stop\" and \"Reverse\".\nPlace the positive power rail at the top of the circuit.\nPlace the negative rail at the bottom of the circuit.\nPlace the motor in the center of the H-brige ciricut.\nAnimate the motor moving clockwise for the Forward state.\nAnimate the motor going counter-clockwise for the Reverse state.\nMake the motor stopped for the Stop state.\nHave the upper left and lower right wires animate current for the Forward state.\nHave the upper right and lower left wires animate current for the Reverse state.\nTurn off all wire animation for the Stop state.\n\nCreate four knife switches.\nHave the upper left and lower right be closed for Forward.\nHave the upper right and lower left be closed for Reverse.\nHave all the switches be open for Stop.\n\nUse the following function to draw current in a wire:\n\nfunction drawAnimatedWire(x1, y1, x2, y2, speed1, state) {\n    if (state) {\n        let distance = dist(x1, y1, x2, y2);\n        let circlePos = map((millis() * speed1) % distance, 0, distance, 0, 1);\n\n        // lerp generates the percent between two values\n        let x = lerp(x1, x2, circlePos);\n        let y = lerp(y1, y2, circlePos);\n\n        stroke(0);\n        strokeWeight(lineWidth)\n        line(x1, y1, x2, y2); // Draw the wire\n\n        fill(255, 0, 0);\n        noStroke();\n        circle(x, y, 10); // Draw the moving circle (electron)\n    } else {\n        stroke(0);\n        strokeWeight(lineWidth)\n        line(x1, y1, x2, y2); // Draw the wire\n    }\n}\n</code></pre>"},{"location":"sims/h-bridge/#response","title":"Response","text":"<p>Sure! Here's a p5.js sketch file that implements the H-bridge circuit with state buttons for \"Forward,\" \"Stop,\" and \"Reverse\":</p> <pre><code>let forwardButton;\nlet stopButton;\nlet reverseButton;\n\nconst lineWidth = 2;\n\nfunction setup() {\n  createCanvas(400, 400);\n\n  forwardButton = createButton('Forward');\n  forwardButton.position(10, 10);\n  forwardButton.mousePressed(forward);\n\n  stopButton = createButton('Stop');\n  stopButton.position(90, 10);\n  stopButton.mousePressed(stop);\n\n  reverseButton = createButton('Reverse');\n  reverseButton.position(150, 10);\n  reverseButton.mousePressed(reverse);\n}\n\nfunction forward() {\n  // Code to control the H-bridge for forward motion\n}\n\nfunction stop() {\n  // Code to stop the motor\n}\n\nfunction reverse() {\n  // Code to control the H-bridge for reverse motion\n}\n\nfunction draw() {\n  background(220);\n\n  // Draw positive power rail\n  stroke(0);\n  strokeWeight(lineWidth);\n  line(40, 60, width - 40, 60);\n\n  // Draw negative power rail\n  stroke(0);\n  strokeWeight(lineWidth);\n  line(40, height - 60, width - 40, height - 60);\n\n  // Draw H-bridge circuit\n  stroke(0);\n  strokeWeight(lineWidth);\n  line(width / 2 - 40, 60, width / 2 - 40, height - 60);\n  line(width / 2 + 40, 60, width / 2 + 40, height - 60);\n  line(width / 2 - 40, height / 2, width / 2 + 40, height / 2);\n\n  // Draw motor\n  noFill();\n  stroke(0);\n  strokeWeight(lineWidth);\n  rect(width / 2 - 20, height / 2 - 20, 40, 40);\n\n  // Draw wires with current\n  let speed1 = 0.01;\n  drawAnimatedWire(40, 60, width / 2 - 40, 60, speed1, forwardButton.elt.disabled);\n  drawAnimatedWire(width / 2 + 40, 60, width - 40, 60, speed1, reverseButton.elt.disabled);\n  drawAnimatedWire(40, height - 60, width / 2 - 40, height - 60, speed1, reverseButton.elt.disabled);\n  drawAnimatedWire(width / 2 + 40, height - 60, width - 40, height - 60, speed1, forwardButton.elt.disabled);\n}\n\nfunction drawAnimatedWire(x1, y1, x2, y2, speed1, state) {\n  if (state) {\n    let distance = dist(x1, y1, x2, y2);\n    let circlePos = map((millis() * speed1) % distance, 0, distance, 0, 1);\n\n    // lerp generates the percent between two values\n    let x = lerp(x1, x2, circlePos);\n    let y = lerp(y1, y2, circlePos);\n\n    stroke(0);\n    strokeWeight(lineWidth);\n    line(x1, y1, x2, y2); // Draw the wire\n\n    fill(255, 0, 0);\n    noStroke();\n    circle(x, y, 10); // Draw the moving circle (electron)\n  } else {\n    stroke(0);\n    strokeWeight(lineWidth);\n    line(x1, y1, x2, y2); // Draw the wire\n  }\n}\n</code></pre>"},{"location":"sims/learning-graph/","title":"Concept Graph Viewer","text":"<p>A learning graph is a network graph data structure where each vertex is a concept a student will learn.  Arrows between the concepts represent dependencies or prerequisites.</p> <p>THe following graph was created by ChatGPT using three prompts:</p> <ol> <li>Course Description using Bloom's 2001 taxonomy</li> <li>Concept Enumeration</li> <li>Concept Dependency</li> <li>Concept Taxonomy</li> </ol> <p>View STEM Robotics Learning Graph</p> <p>Tip</p> <p>You can use your mouse and scroll wheel to navigate around the graph. You can zoom in, pan and move the nodes around the graph.</p>"},{"location":"sims/pwm/","title":"Pulse-Width Modulation","text":"<p>Run the Pulse-Width Modulation Demo</p> <p>Edit the MicroSim</p> <p>Pulse-width modulation is the way for microcontrollers to send a precise signal to a  device such as a motor controller to control motor speed.  PWM signals can also be used to change the brightness of an LED. This simulation has a slider that allows the user to change the \"duty cycle\" of a waveform.  The simulation is a bright green line on a black background, just like the old CRT oscilloscope displays.</p>"},{"location":"sims/pwm/#sample-chatgpt-prompt","title":"Sample ChatGPT Prompt","text":"<pre><code>Generate a p5.js sketch file of a simulation of a static pulse width\n   modulation (PWM) waveform on a 600x300 canvas.\nAdd a range control slider to adjust the Duty Cycle of the waveform.\nMake the default Duty Cycle be 50%.\nThe min should be 0% and the max should be 100%.\nPlace the range control slider at the bottom of the canvas.\nMake the leftSliderMargin be 155.\nMake sure the range control slider has a width of canvasWidth-leftSliderMargin-20 using the \n   style attribute.\nAt the end of the draw() function add a text() function that displays\n   the label and value of the duty cycle.\n</code></pre> <p>I have tested this prompt several times using GPT-4 and it seems to work very well except for the precise layout of the duty cycle label, value and slider positioning. I had to tweak these by hand.</p> <p>Edit This MicroSim Using the P5.js Editor</p>"},{"location":"sims/pwm/#sample-response","title":"Sample Response","text":"<pre><code>/// Pulse Wave Modulation (PWM) simulation\n// Made to render like an old oscilloscope - lime green on black\n// Most of this sim was generated by GPT-4 with some cleanup on placement of the slider\nlet canvasWidth = 600;\nlet canvasHeight = 200;\nlet dutyCycleSlider;\nlet dutyCycle = 0.5; // Initialize to 50%\nlet cycles = 6;\nlet waveHeight = canvasHeight/3;\nlet leftSliderMargin = 155; // at 16 point font\n\nfunction setup() {\n  const canvas = createCanvas(canvasWidth, canvasHeight);\n  // uncomment if you are placing in an HTML page\n  // canvas.parent('canvas-container');\n  textSize(16);\n\n  dutyCycleSlider = createSlider(0, 1, 0.5, 0.01); // Range from 0 to 1, default value 0.5, step size 0.01\n  dutyCycleSlider.position(leftSliderMargin, canvasHeight - 35); // Position slider\n  dutyCycleSlider.style('width', canvasWidth - leftSliderMargin - 20 + 'px'); // Set width of slider\n}\n\nfunction draw() {\n  background('black');\n\n  // Update duty cycle\n  dutyCycle = dutyCycleSlider.value();\n\n  // Set stroke for waveform\n  stroke('limegreen');\n  // disable the fill in the waveform\n  noFill();\n  // make the line be double wide\n  strokeWeight(2);\n\n  // Generate PWM waveform\n  beginShape();\n  for (let x = 0; x &lt; width; x++) {\n    // Map x to time period of waveform\n    let t = map(x, 0, width, 0, TWO_PI * cycles);\n\n    // Calculate value of waveform at this point in time\n    // Draw high if in duty cycle, low otherwise\n    let y = (sin(t) &gt; 2 * dutyCycle - 1) ? \n        2*height/3 : height/3; \n\n    // Add vertex to waveform\n    vertex(x, y);\n  }\n  endShape();\n\n  // Display duty cycle\n  fill('white');\n  noStroke();\n  // Display duty cycle as percentage\n  text(\"Duty Cycle: \" + nf(dutyCycle*100, 0, 0) + \"%\", 20, height - 20); \n}\n</code></pre>"},{"location":"sims/pwm/#key-learnings-from-the-simulation","title":"Key Learnings from the Simulation","text":"<ol> <li>We can use the <code>map()</code> function to transform the x coordinate into the time period of a waverform (t.)</li> <li>We can draw a square wave using a <code>sin()</code> function with a threshold test.</li> <li>We can use the <code>beginShape()</code> and <code>endShape()</code> around as set of <code>vertex()</code> point placements to generate waveforms.</li> <li>We can use the \"number format\" function <code>nf()</code>  to display the percentage without a decimal point.</li> </ol>"},{"location":"sims/pwm/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/pwm/#lesson-plan-prompt","title":"Lesson Plan Prompt","text":"<pre><code>I have a webpage that simulates a pulse-width-modulation waveform. \nThe page has a slider that allows students to change the duty cycle from 0% to 100%.\nWhen the students change the slider, the waveform is updated with the duty cycle.\nGenerate a lesson plan for a 9th-grade robotics class that uses this simulation.\nFor follow up activities, we have Raspberry Pi Picos that we program with MicroPython.\nReturn the response in a single raw markdown file.\n</code></pre>"},{"location":"sims/pwm/#lesson-plan-understanding-pulse-width-modulation-in-robotics","title":"Lesson Plan: Understanding Pulse-Width Modulation in Robotics","text":""},{"location":"sims/pwm/#objective","title":"Objective:","text":"<p>Students will understand the concept of PWM and its application in controlling robotic components like motors and LEDs.</p>"},{"location":"sims/pwm/#materials-needed","title":"Materials Needed:","text":"<ul> <li>Computers with internet access for the PWM simulation webpage.</li> <li>Projector for demonstrations.</li> <li>Optional: Physical components such as a small motor, LED, and Arduino for real-world demonstration.</li> </ul>"},{"location":"sims/pwm/#duration","title":"Duration:","text":"<p>1 hour</p>"},{"location":"sims/pwm/#lesson-outline","title":"Lesson Outline:","text":""},{"location":"sims/pwm/#1-introduction-to-pwm-15-minutes","title":"1. Introduction to PWM (15 minutes)","text":"<ul> <li>Begin with a brief overview of PWM and its significance in robotics.</li> <li>Explain key terms: duty cycle, frequency, analog vs. digital signals.</li> </ul>"},{"location":"sims/pwm/#2-demonstration-of-pwm-simulation-10-minutes","title":"2. Demonstration of PWM Simulation (10 minutes)","text":"<ul> <li>Project the PWM simulation on the screen.</li> <li>Show how changing the duty cycle affects the waveform.</li> <li>Relate this to how it would affect a motor's speed or an LED's brightness.</li> </ul>"},{"location":"sims/pwm/#3-hands-on-activity-with-the-simulation-20-minutes","title":"3. Hands-On Activity with the Simulation (20 minutes)","text":"<ul> <li>Students will use the simulation on their computers.</li> <li>Tasks:</li> <li>Set the duty cycle to various levels (0%, 25%, 50%, 75%, 100%) and observe changes.</li> <li>Students note their observations regarding the waveform changes.</li> </ul>"},{"location":"sims/pwm/#4-real-world-application-discussion-10-minutes","title":"4. Real-World Application Discussion (10 minutes)","text":"<ul> <li>Discuss how PWM is used in real-world robotics.</li> <li>If available, demonstrate using a motor or LED with an Arduino.</li> <li>Encourage students to think of examples where PWM might be used in everyday technology.</li> </ul>"},{"location":"sims/pwm/#5-reflection-and-qa-5-minutes","title":"5. Reflection and Q&amp;A (5 minutes)","text":"<ul> <li>Encourage students to ask questions.</li> <li>Discuss the importance of PWM in precise control in robotics.</li> </ul>"},{"location":"sims/pwm/#assessment","title":"Assessment:","text":"<ul> <li>Students will submit a brief report on their findings from the simulation.</li> <li>Include a few quiz questions at the end of the session to gauge understanding.</li> </ul>"},{"location":"sims/pwm/#extension-activity","title":"Extension Activity:","text":"<ul> <li>For advanced students or as a follow-up lesson, introduce a Python program that uses PWM to control a motor speed using a motor driver chip such as an L293D or control an LED brightness.</li> </ul>"},{"location":"sims/pwm/#notes","title":"Notes:","text":"<ul> <li>Ensure that all students understand the basic concepts before moving to the hands-on activity.</li> <li>Assist students who might have difficulty with the simulation or concepts.</li> <li>Encourage group discussions and peer learning.</li> </ul>"},{"location":"sims/template/","title":"MicroSim Template","text":"![Image Name](./image.png){ width=\"400\" }    Figure caption. <p>Link to Demo</p>"},{"location":"sims/template/#about-this-microsim","title":"About this MicroSim","text":"<p>This MicroSim teaches us how to specify the drawing of a static filled circle.</p>"},{"location":"sims/template/#sample-prompt","title":"Sample Prompt","text":"<pre><code>Create a single file p5.js sketch.\nDraw a green circle on a 600x400 canvas with a radius of 200.\n</code></pre>"},{"location":"sims/template/#sample-response","title":"Sample Response","text":"<pre><code>let canvasHeight = 400;\nlet aspectRatio = 1.91; // Open Graph standard\nlet canvasWidth = canvasHeight * aspectRatio;\nlet radius = 200;\nfunction setup() {\nconst canvas = createCanvas(canvasWidth, canvasHeight);\n  canvas.parent('canvas-container');\n  fill(245);\n  rect(0,0, canvasWidth, canvasHeight);\n  fill('green');\n  circle(canvasWidth/2, canvasHeight/2, radius);\n}\n</code></pre>"},{"location":"sims/template/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/template/#grade-level-subject-and-topic","title":"Grade Level, Subject and Topic","text":"<p>9th grade geometry. Circle and radius.</p>"},{"location":"sims/template/#activities","title":"Activities","text":""},{"location":"sims/template/#fill-color","title":"Fill Color","text":"<p>Change the color in the prompt.  You can specify any one of the 140 named colors.</p>"},{"location":"sims/template/#border-weight","title":"Border Weight","text":"<p>Change the prompt to include a black border of width 10.</p>"},{"location":"sims/template/#border-color","title":"Border Color","text":"<p>Change the prompt to make the border purple.</p>"},{"location":"sims/template/#change-the-radius","title":"Change the Radius","text":"<p>Change the prompt to make the circle smaller or larger by changing the radius from 10 to 200.</p>"},{"location":"sims/template/#change-the-location","title":"Change the Location","text":"<p>Change the prompt to move the circle to the left or right.</p>"}]}